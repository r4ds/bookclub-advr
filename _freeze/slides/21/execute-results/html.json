{
  "hash": "f1c767290a410387fae49b53689d97ce",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Translating R code\n---\n\n## Learning objectives:\n\n-   Understand what it means to *translate* R code\n-   Treat code as data to enable domain-specific languages (DSLs)\n-   Create HTML and LaTeX DSLs\n-   Learn how environments, S3, and metaprogramming work together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(purrr)\n```\n:::\n\n\n\n\n# What does translating R code mean?\n\n## R code → another language\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"DiagrammeR html-widget html-fill-item\" id=\"htmlwidget-8d17126d6537a8bdc756\" style=\"width:960px;height:480px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-8d17126d6537a8bdc756\">{\"x\":{\"diagram\":\"\\ngraph LR\\n\\nexpressions --> R\\nquasiquotation --> R\\nevaluation --> R\\n\\nR --> HTML\\nR --> LaTeX\\n\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n## Translating code is not the same as evaluating code\n\n``` r\n# Evaluation\nsqrt(9)\n\n# Translation\nexpr <- quote(sqrt(x))\nexpr\n```\n\n-   Evaluation produces a value (`3`)\n-   Translation preserves structure (`sqrt(x)`)\n-   The result is code, not a computed number\n\n## Code translation relies on metaprogramming\n\n``` r\nlibrary(rlang)\n\nexpr <- expr(mean(x, na.rm = TRUE))\nexpr\n```\n\n-   Expressions are captured with `expr()` / `enexpr()`\n-   Calls, symbols, etc... can be inspected\n-   Translation operates on the AST, not on values\n\n## The practical goal of translation is domain-specific languages\n\n-   DSLs embed a small language inside R\n-   R syntax becomes a frontend for another language\n-   `dbplyr` as an example: R → SQL\n\n# Fundamentals of R → HTML\n\n## We can generate HTML code from R\n\n-   We can do this...\n\n``` html\n<body>\n  <h1 id='first'>A heading</h1>\n  <p>Some text &amp; <b>some bold text.</b></p>\n  <img src='myimg.png' width='100' height='100' />\n</body>\n```\n\n-   By doing this...\n\n``` r\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n```\n\nBasically, HTML tags become \"ordinary\" R functions\n\n## Our DSL makes translation easy\n\n-   **Same structure**: nesting of function calls == nesting of tags.\n\n-   **Similar logic**: unnamed arguments -> tag content, named arguments -> tag attributes.\n\n-   **User experience**: special characters automatically escaped (e.g. `\"&\"` -> `\"&amp;\"`).\n\n## We need five basic HTML tags for this exercise\n\n``` html\n<body>\n  <h1 id='first'>A heading</h1>\n  <p>Some text &amp; <b>some bold text.</b></p>\n  <img src='myimg.png' width='100' height='100' />\n</body>\n```\n\n-   `<body>` is the top-level tag that contains all content.\n-   `<h1>` defines a top level heading.\n-   `<p>` defines a paragraph.\n-   `<b>` emboldens text.\n-   `<img>` embeds an image.\n\n## We need to know the main structure of tags\n\n-   Main tags structure: `<tag> </tag>`\n-   Void tags structure: `<tag />`\n-   Tags can have attributes: `<tag name1='value1' name2='value2'></tag>`\n\nExamples\n\n``` html\n<!-- Main tag with some atributes -->\n<h1 id='first'>A heading</h1>\n\n<!-- Void tag with some atributes -->\n<img src='myimg.png' width='100' height='100' />\n```\n\n## We need to know how to escape some characters\n\n-   `&` is escaped with `&amp;`\n-   `<` is escaped with `&lt;`\n-   `>` is escaped with `&gt;`\n\n# How to R → HTML\n\n## Follow a micro-macro procedure to create HTML DSL\n\n``` r\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n```\n\nThe steps...\n\n-   Create an S3 that translates & automatically escapes user's input\n-   Create a basic structure for tag functions\n-   Create a function factory for creating tag functions\n-   Create an HTML environment of evaluation\n\n## We can translate R to HTML via S3\n\nClass constructor and dispatch\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml <- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html <- function(x, ...) {\n  out <- paste0(\"<HTML> \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\n```\n:::\n\n\nMethods that consider automatic escaping\n\n\n::: {.cell}\n\n```{.r .cell-code}\nescape <- function(x) UseMethod(\"escape\")\n\nescape.character <- function(x) {\n  # Method for escaping\n  x <- gsub(\"&\", \"&amp;\", x)\n  x <- gsub(\"<\", \"&lt;\", x)\n  x <- gsub(\">\", \"&gt;\", x)\n\n  html(x)\n}\n\nescape.advr_html <- function(x) x # Method when escaping not needed\n```\n:::\n\n\n## Our S3 translates and automatically escapes user's input\n\n\n::: {.cell}\n\n```{.r .cell-code}\nescape(\"This is some text.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> This is some text.\n```\n\n\n:::\n\n```{.r .cell-code}\nescape(\"x > 1 & y < 2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> x &gt; 1 &amp; y &lt; 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Double escaping is not a problem\nescape(escape(\"This is some text. 1 > 2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> This is some text. 1 &gt; 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# And text we know is HTML doesn't get escaped.\nescape(html(\"<hr />\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <hr />\n```\n\n\n:::\n:::\n\n\n## We create R functions for HTML tags\n\n-   `<p>` tag -> `p()` function\n    -   Distinguish between content and attributes\n    -   Manage the big amount of attributes that exists (also customs ones)\n-   Same logic to create other tags\n\n``` r\np(\"Some text. \", b(i(\"some bold italic text\")), class = \"mypara\")\n```\n\n## We must distinguish between content and attributes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Separate named and unnamed arguments\ndots_partition <- function(...) {\n  dots <- list2(...)\n\n  if (is.null(names(dots))) {\n    is_named <- rep(FALSE, length(dots))\n  } else {\n    is_named <- names(dots) != \"\"\n  }\n\n  list(\n    named = dots[is_named], # Attributes\n    unnamed = dots[!is_named] # Contents\n  )\n}\n\nstr(dots_partition(a = 1, 2, b = 3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 2\n#>  $ named  :List of 2\n#>   ..$ a: num 1\n#>   ..$ b: num 3\n#>  $ unnamed:List of 2\n#>   ..$ : num 2\n#>   ..$ : num 4\n```\n\n\n:::\n:::\n\n\n## We can create `<p>` tag via `p()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- function(...) {\n  dots <- dots_partition(...) # List with named and unnamed args\n  attribs <- html_attributes(dots$named)\n  children <- map_chr(dots$unnamed, escape)\n\n  html(paste0(\n    \"<p\",\n    attribs,\n    \">\",\n    paste(children, collapse = \"\"),\n    \"</p>\"\n  ))\n}\n```\n:::\n\n\n<details>\n\n<summary>More about `html_attributes()`</summary>\n\nFound among the textbook's [source code](https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml_attributes <- function(list) {\n  if (length(list) == 0) {\n    return(\"\")\n  }\n\n  attr <- map2_chr(names(list), list, html_attribute)\n  paste0(\" \", unlist(attr), collapse = \"\")\n}\nhtml_attribute <- function(name, value = NULL) {\n  if (length(value) == 0) {\n    return(name)\n  } # for attributes with no value\n  if (length(value) != 1) {\n    stop(\"`value` must be NULL or length 1\")\n  }\n\n  if (is.logical(value)) {\n    # Convert T and F to true and false\n    value <- tolower(value)\n  } else {\n    value <- escape_attr(value)\n  }\n  paste0(name, \"='\", value, \"'\")\n}\nescape_attr <- function(x) {\n  x <- escape.character(x)\n  x <- gsub(\"\\'\", '&#39;', x)\n  x <- gsub(\"\\\"\", '&quot;', x)\n  x <- gsub(\"\\r\", '&#13;', x)\n  x <- gsub(\"\\n\", '&#10;', x)\n  x\n}\n```\n:::\n\n\n</details>\n\n# Our `p()` function works\n\n\n::: {.cell}\n\n```{.r .cell-code}\np(\"Some text\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <p>Some text</p>\n```\n\n\n:::\n\n```{.r .cell-code}\np(\"Some text\", id = \"myid\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <p id='myid'>Some text</p>\n```\n\n\n:::\n\n```{.r .cell-code}\np(\"Some text\", class = \"important\", `data-value` = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <p class='important' data-value='10'>Some text</p>\n```\n\n\n:::\n:::\n\n\n## We can use a function factory for tags\n\n-   Instead of one function for each tag, we use a function factory:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntag <- function(tag) {\n  new_function(\n    exprs(... = ), # Capture the intended tag!\n    expr({\n      # Capture the code that contains the structure of tag functions\n      dots <- dots_partition(...)\n      attribs <- html_attributes(dots$named)\n      children <- map_chr(dots$unnamed, escape)\n\n      html(paste0(\n        !!paste0(\"<\", tag),\n        attribs,\n        \">\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"</\", tag, \">\")\n      ))\n    }),\n    caller_env() # Get the environment of the caller frame\n  )\n}\n```\n:::\n\n\n## Our function factory for tags works\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntag(\"b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (...) \n#> {\n#>     dots <- dots_partition(...)\n#>     attribs <- html_attributes(dots$named)\n#>     children <- map_chr(dots$unnamed, escape)\n#>     html(paste0(\"<b\", attribs, \">\", paste(children, collapse = \"\"), \n#>         \"</b>\"))\n#> }\n```\n\n\n:::\n:::\n\n\nRe-run earlier example...\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- tag(\"p\")\nb <- tag(\"b\")\ni <- tag(\"i\")\np(\"Some text. \", b(i(\"some bold italic text\")), class = \"mypara\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic\n#> text</i></b></p>\n```\n\n\n:::\n:::\n\n\n## We need to consider void tags\n\n-   Void tags have slightly different structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid_tag <- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots <- dots_partition(...)\n      if (length(dots$unnamed) > 0) {\n        # Throws an error because void tags can't have children\n        abort(!!paste0(\"<\", tag, \"> must not have unnamed arguments\"))\n      }\n      attribs <- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"<\", tag), attribs, \" />\"))\n    }),\n    caller_env()\n  )\n}\n```\n:::\n\n\n## Our variant for void tags works\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg <- void_tag(\"img\")\nimg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (...) \n#> {\n#>     dots <- dots_partition(...)\n#>     if (length(dots$unnamed) > 0) {\n#>         abort(\"<img> must not have unnamed arguments\")\n#>     }\n#>     attribs <- html_attributes(dots$named)\n#>     html(paste0(\"<img\", attribs, \" />\"))\n#> }\n```\n\n\n:::\n\n```{.r .cell-code}\nimg(src = \"myimage.png\", width = 100, height = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <img src='myimage.png' width='100' height='100' />\n```\n\n\n:::\n:::\n\n\n## Store tags in an HTML environment\n\n-   We need to store all of our tags:\n\n<details>\n\n<summary>All tags...</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntags <- c(\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"blockquote\",\n  \"body\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"eventsource\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"ins\",\n  \"kbd\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"mark\",\n  \"map\",\n  \"menu\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"ruby\",\n  \"rp\",\n  \"rt\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\"\n)\n\nvoid_tags <- c(\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n)\n```\n:::\n\n\n</details>\n\n-   But there are tags that will override R functions...\n\n<details>\n\n<summary>Venn Diagram</summary>\n\n![Venn Diagram of words in R or HTML](images/translating/tags_r_venn.png)\n\n</details>\n\n-   **Solution**: first a `list()`, then an \"environment\"\n\n## Creating a list makes translation work\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the list\nhtml_tags <- c(\n  tags %>% set_names() %>% map(tag),\n  void_tags %>% set_names() %>% map(void_tag)\n)\n\n# Check!\nhtml_tags$p(\n  \"Some text. \",\n  html_tags$b(html_tags$i(\"some bold italic text\")),\n  class = \"mypara\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic\n#> text</i></b></p>\n```\n\n\n:::\n:::\n\n\n## Creating an environment makes the UX better\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an \"environment\"\nwith_html <- function(code) {\n  code <- enquo(code)\n  eval_tidy(code, html_tags)\n}\n\n# Check!\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <HTML> <body><h1 id='first'>A heading</h1><p>Some text &amp;<b>some\n#> bold text.</b></p><img src='myimg.png' width='100' height='100'\n#> /></body>\n```\n\n\n:::\n:::\n\n\n# Fundamentals of R → LaTeX\n\n## We can generate LaTeX syntax from R\n\n-   We can do this:\n\n``` latex\n\\sin(\\pi) + \\mathrm{f}(a)\n```\n\n-   That look like this:$$\\sin(\\pi) + \\mathrm{f}(a)$$\n\n-   By doing this:\n\n``` r\nto_math(sin(pi) + f(a))\n```\n\n## We need to know some LaTeX structure for this exercise\n\n-   Simple mathematical equations are written like in R: `x * y, z ^ 5` = $x * y, z^5$\n-   Special characters start with a `\\`. For example, `\\pi` = $\\pi$\n-   Complicated functions look like `\\name{arg1}{arg2}`. For example, fractions are `\\frac{a}{b}` = $\\frac{a}{b}$\n-   Mathematics functions need to be written like `\\textrm{f}(a * b)` = $\\textrm{f}(a*b)$\n\n# How to R → LaTeX\n\n## Follow a macro-micro procedure to create LaTeX DSL\n\n-   Start with infrastructure (`to_math()`) and experiment until cover every use case.\n\n-   Four stages:\n\n    -   Convert known symbols: `pi` → `\\pi`\n\n    -   Leave other symbols unchanged: `x` → `x`, `y` → `y`\n\n    -   Convert known functions to their special forms: `sqrt(frac(a, b))` → `\\sqrt{\\frac{a}{b}}`\n\n    -   Wrap unknown functions with `\\textrm`: `f(a)` → `\\textrm{f}(a)`\n\n## Our LaTeX DSL will be different than our HTML DSL\n\n-   Evaluation environment no longer constant\n  - Has to vary depending on input\n  - Necessary to handle unknown symbols & functions\n-   Never evaluate in argument environment\n  - We translate every function to a LaTeX expression\n  - User must explicitly `!!` in order to evaluate normally\n\n## We need to create an execution environment: `to_math()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Execution environment\nto_math <- function(x) {\n  expr <- enexpr(x) # Capture expression (intended LaTeX)\n  out <- eval_bare(expr, latex_env(expr)) # Evaluate in a specific environment for this expression\n\n  latex(out)\n}\n\n# Class generator\nlatex <- function(x) structure(x, class = \"advr_latex\")\n\n# Dispatch\nprint.advr_latex <- function(x) {\n  cat(\"<LATEX> \", x, \"\\n\", sep = \"\")\n}\n```\n:::\n\n\n`latex_env()` is going to be created later. It depends on the expression.\n\n# R → LaTeX: translating known symbols\n\n## We can quickly create an environment with all the Greek letters\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreek <- c(\n  \"alpha\",\n  \"theta\",\n  \"tau\",\n  \"beta\",\n  \"vartheta\",\n  \"pi\",\n  \"upsilon\",\n  \"gamma\",\n  \"varpi\",\n  \"phi\",\n  \"delta\",\n  \"kappa\",\n  \"rho\",\n  \"varphi\",\n  \"epsilon\",\n  \"lambda\",\n  \"varrho\",\n  \"chi\",\n  \"varepsilon\",\n  \"mu\",\n  \"sigma\",\n  \"psi\",\n  \"zeta\",\n  \"nu\",\n  \"varsigma\",\n  \"omega\",\n  \"eta\",\n  \"xi\",\n  \"Gamma\",\n  \"Lambda\",\n  \"Sigma\",\n  \"Psi\",\n  \"Delta\",\n  \"Xi\",\n  \"Upsilon\",\n  \"Omega\",\n  \"Theta\",\n  \"Pi\",\n  \"Phi\"\n)\ngreek_list <- set_names(paste0(\"\\\\\", greek), greek)\ngreek_env <- as_environment(greek_list)\n```\n:::\n\n\n## Our environment for known symbols works\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the latex_env based on the greek_env\nlatex_env <- function(expr) {\n  greek_env\n}\n\nto_math(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\pi\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(beta)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\beta\n```\n\n\n:::\n:::\n\n\n# R → LaTeX: translating unknown symbols\n\n## We can capture the unknown symbols from the expression\n\nLeave non-Greek symbols as-is, but we don´t know what symbols are going to be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Walk the AST to find all the symbols:\nall_names_rec <- function(x) {\n  switch_expr(\n    x,\n    constant = character(),\n    symbol = as.character(x),\n    call = flat_map_chr(as.list(x[-1]), all_names)\n  )\n}\n\nall_names <- function(x) {\n  unique(all_names_rec(x))\n}\n\nall_names(expr(x + y + f(a, b, c, 10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x\" \"y\" \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n<details>\n\n<summary>Utility functions from section 18.5...</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr_type <- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\nflat_map_chr <- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\nswitch_expr <- function(x, ...) {\n  switch(\n    expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n```\n:::\n\n\n</details>\n\n## We can build the environment based on the list of the unknown symbols\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatex_env <- function(expr) {\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names))\n\n  symbol_env\n}\n\nto_math(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> x\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(longvariablename)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> longvariablename\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> pi\n```\n\n\n:::\n:::\n\n\n## We can integrate the known and unknown symbols environments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatex_env <- function(expr) {\n  # Unknown symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names))\n\n  # Known symbols\n  env_clone(greek_env, parent = symbol_env) # This gives preference to Greek over defaults.\n  # We want \"\\\\pi\", not \"pi\".\n}\n```\n:::\n\n\n## Our environment for all symbols works\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_math(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> x\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(longvariablename)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> longvariablename\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\pi\n```\n\n\n:::\n:::\n\n\n# R → LaTeX: translating known functions\n\n## We can base our translation on simple helpers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunary_op <- function(left, right) {\n  new_function(\n    exprs(e1 = ),\n    expr(\n      paste0(!!left, e1, !!right)\n    ),\n    caller_env()\n  )\n}\n\nbinary_op <- function(sep) {\n  new_function(\n    exprs(e1 = , e2 = ),\n    expr(\n      paste0(e1, !!sep, e2)\n    ),\n    caller_env()\n  )\n}\n\nunary_op(\"\\\\sqrt{\", \"}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (e1) \n#> paste0(\"\\\\sqrt{\", e1, \"}\")\n```\n\n\n:::\n\n```{.r .cell-code}\nbinary_op(\"+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (e1, e2) \n#> paste0(e1, \"+\", e2)\n```\n\n\n:::\n:::\n\n\n## We can build the environment for functions with some common examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Binary operators\nf_env <- child_env(\n  .parent = empty_env(),\n  `+` = binary_op(\" + \"),\n  `-` = binary_op(\" - \"),\n  `*` = binary_op(\" * \"),\n  `/` = binary_op(\" / \"),\n  `^` = binary_op(\"^\"),\n  `[` = binary_op(\"_\"),\n\n  # Grouping\n  `{` = unary_op(\"\\\\left{ \", \" \\\\right}\"),\n  `(` = unary_op(\"\\\\left( \", \" \\\\right)\"),\n  paste = paste,\n\n  # Other math functions\n  sqrt = unary_op(\"\\\\sqrt{\", \"}\"),\n  sin = unary_op(\"\\\\sin(\", \")\"),\n  log = unary_op(\"\\\\log(\", \")\"),\n  abs = unary_op(\"\\\\left| \", \"\\\\right| \"),\n  frac = function(a, b) {\n    paste0(\"\\\\frac{\", a, \"}{\", b, \"}\")\n  },\n\n  # Labelling\n  hat = unary_op(\"\\\\hat{\", \"}\"),\n  tilde = unary_op(\"\\\\tilde{\", \"}\")\n)\n```\n:::\n\n\n## We can integrate this new environment to the symbols environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatex_env <- function(expr) {\n  # Known functions\n  f_env\n\n  # Default symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env <- env_clone(greek_env, parent = symbol_env)\n\n  greek_env\n}\n```\n:::\n\n\n## Our integrated symbol and known functions environment works\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_math(sin(x + pi))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\sin(x + \\pi)\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(log(x[i]^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\log(x_i^2)\n```\n\n\n:::\n\n```{.r .cell-code}\nto_math(sin(sin))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\sin(sin)\n```\n\n\n:::\n:::\n\n\n# R → LaTeX: translating unknown functions\n\n## We create a list of unknown functions based on the expression\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_calls_rec <- function(x) {\n  switch_expr(x, constant = , symbol = character(), call = {\n    fname <- as.character(x[[1]])\n    children <- flat_map_chr(as.list(x[-1]), all_calls)\n    c(fname, children)\n  })\n}\nall_calls <- function(x) {\n  unique(all_calls_rec(x))\n}\n\nall_calls(expr(f(g + b, c, d(a))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"f\" \"+\" \"d\"\n```\n\n\n:::\n:::\n\n\n## We can use a function factory for creating unknown functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunknown_op <- function(op) {\n  new_function(\n    exprs(... = ),\n    expr({\n      contents <- paste(..., collapse = \", \")\n      paste0(!!paste0(\"\\\\mathrm{\", op, \"}(\"), contents, \")\")\n    })\n  )\n}\n\nunknown_op(\"foo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (...) \n#> {\n#>     contents <- paste(..., collapse = \", \")\n#>     paste0(\"\\\\mathrm{foo}(\", contents, \")\")\n#> }\n#> <environment: 0x0000025275b4bc10>\n```\n\n\n:::\n:::\n\n\n## We can integrate the unknown function environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatex_env <- function(expr) {\n  calls <- all_calls(expr)\n  call_list <- map(set_names(calls), unknown_op)\n  call_env <- as_environment(call_list)\n\n  # Known functions\n  f_env <- env_clone(f_env, call_env)\n\n  # Default symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env <- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\n```\n:::\n\n\n## Our final environment and the full translation works!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_math(sin(pi) + f(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <LATEX> \\sin(\\pi) + \\mathrm{f}(a)\n```\n\n\n:::\n:::\n\n\n# Synthesis\n\n## R can translate to HTML via a micro-macro procedure\n\n-   Creating an S3 for translation and automatic escaping\n\n-   Creating a tag function structure\n\n-   Creating a function factory for tags\n\n-   Creating an execution environment: `with_html()`\n\n## R can translate to LaTeX via a macro-micro procedure\n\n-   Build an interface that contains a dynamic environment\n\n-   Creating and environment of **known symbols** by declaring them\n\n-   Creating and environment of **unknown symbols** by walking the AST of the expression\n\n-   Creating and environment of **known functions** by declaring the most common ones\n\n-   Creating and environment of **unknown functions** by walking the AST and using a function factory\n\n-   Integrating all the environment in the dynamic environment contained in the `to_math()` interface\n\n# Final remarks\n\n## This chapter integrates core advanced R concepts\n\n-   Code as data\n-   S3 classes and method dispatch\n-   Environments and scoping\n-   Dynamic function generation\n\n## Takeaway: R enables languages inside the language\n\n-   Translation comes naturally from how R is designed\n-    Creating small domain-specific languages in R is normal and expected, not a trick\n-    *Advanced R* shows how to build them in a clear, safe, and maintainable way\n",
    "supporting": [
      "21_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.9/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/d3-3.3.8/d3.min.js\"></script>\n<script src=\"../site_libs/dagre-0.4.0/dagre-d3.min.js\"></script>\n<link href=\"../site_libs/mermaid-0.3.0/dist/mermaid.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/mermaid-0.3.0/dist/mermaid.slim.min.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/chromatography-0.1/chromatography.js\"></script>\n<script src=\"../site_libs/DiagrammeR-binding-1.0.11/DiagrammeR.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}