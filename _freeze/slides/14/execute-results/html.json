{
  "hash": "0d1174dd43ad681f19ddb2478b8bfc9f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: R6\n---\n\n## Learning objectives:\n\n- Create R6 classes\n- Recognize main R6 properties\n- Assign R6 methods and fields\n- Compare different R6 fields\n- Show R6 inheritance pattern\n- Implement R6 finalizers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n```\n:::\n\n\n# R6 classes\n\n## `R6Class` creates the R6 reference object\n\n-   *Empty* is an environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEmpty <- R6Class(\"Empty\")\nEmpty\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <Empty> object generator\n#>   Public:\n#>     clone: function (deep = FALSE) \n#>   Parent env: <environment: R_GlobalEnv>\n#>   Locked objects: TRUE\n#>   Locked class: FALSE\n#>   Portable: TRUE\n```\n\n\n:::\n:::\n\n\n## Every R6 object has an S3 class that reflects its hierarchy of R6 classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- Empty$new()\nclass(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Empty\" \"R6\"\n```\n\n\n:::\n:::\n\n\n# R6 properties \n\n## R6 objects have methods, not generics\n\n-   *add* is a method of the Accumulator object.\n-   Can't use *sum* and *add* outside this class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAccumulator <- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum <- self$sum + x\n    invisible(self)\n  }\n))\n```\n:::\n\n\n## R6 objects have reference semantics\n\n-   Use the `$clone()` method to copy the object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- Accumulator$new()\nx$add(4)\nx$sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- Accumulator$new()\ny$sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nz <- x$clone()\nz$sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n:::\n\n\n## R6 methods can be chained resembling `|>` syntax\n\n-   All side-effect R6 methods should return `self` invisibly.\n-   This allows for method chaining.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$add(10)$add(10)$sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 24\n```\n\n\n:::\n\n```{.r .cell-code}\nx$\n  add(10)$\n  add(10)$\n  sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 44\n```\n\n\n:::\n:::\n\n\n# R6 methods and fields\n\n## `$print()` modifies the default printing method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPrettyAccumulator <- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum <- self$sum + x\n    invisible(self)\n  },\n  print = function(...) {\n    cat(\"Pretty Accumulator Object\\n\")\n    cat(\"  Current sum: \", self$sum,\"\\n\")\n    invisible(self)\n  }\n))\np <- PrettyAccumulator$new()\np$\n  add(2)$\n  add(2)$\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Pretty Accumulator Object\n#>   Current sum:  4\n```\n\n\n:::\n:::\n\n\n## `$initialize()` overides the default behaviour of `$new()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPerson <- R6Class(\"Person\",list(\n  name = NULL,\n  initialize = function(name) {\n    stopifnot(is.character(name))\n    stopifnot(length(name)==1)\n    self$name <- name\n    invisible(self)\n  },\n  print = function(...) {\n    cat(\"Person\\n\")\n    cat(\"   name: \",self$name,\"\\n\")\n    invisible(self)\n  }\n))\nPerson$new(\"Nick\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Person\n#>    name:  Nick\n```\n\n\n:::\n\n```{.r .cell-code}\nPerson$new(42)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in initialize(...): is.character(name) is not TRUE\n```\n\n\n:::\n:::\n\n\n## `$set()` assigns methods after creating R6 objects\n\n::: {.callout-note}\nKeep in mind methods added with `$set()` are only available with new objects.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAccumulator <- R6Class(\"Accumulator\")\nAccumulator$set(\"public\", \"sum\", 0)\nAccumulator$set(\"public\", \"add\", function(x = 1) {\n  self$sum <- self$sum + x\n  invisible(self)\n})\n```\n:::\n\n\n# Private vs. public vs. active R6 fields\n\n## Accessing private R6 fields yield NULL\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTransaction <- R6Class(\"Transaction\", \n  public = list(\n    last_transaction = 0,\n    initialize = function(owner) {\n      private$owner <- owner\n      invisible(self)\n    },\n    deposit = function(amount) {\n      private$balance <- private$balance + amount\n      self$last_transaction <- amount\n      invisible(self)\n    },\n    withdraw = function(amount) {\n      private$balance <- private$balance - amount\n      self$last_transaction <- -amount\n      invisible(self)\n    },\n    print = function(...) {\n      cat(\"Transactions by \",private$owner,\"\\n\")\n      cat(\"  Last transaction: \",self$last_transaction,\"\\n\")\n      cat(\"  Balance: \",private$balance,\"\\n\")\n    }\n  ),\n  private = list(\n    owner = NULL,\n    balance = 0\n  )\n)\nt <- Transaction$new(\"Nick\")\nt$owner\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n:::\n\n\n## Public methods like `$print()` can reveal private fields\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt$balance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nt$deposit(20)$withdraw(13)$withdraw(2)\nt$last_transaction\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -2\n```\n\n\n:::\n\n```{.r .cell-code}\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Transactions by  Nick \n#>   Last transaction:  -2 \n#>   Balance:  5\n```\n\n\n:::\n:::\n\n\n## Active fields hide complex method calls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRando <- R6::R6Class(\"Rando\", active = list(\n  random = function(value) {\n    if (missing(value)) {\n      runif(1)  \n    } else {\n      stop(\"Can't set `$random`\", call. = FALSE)\n    }\n  }\n))\nx <- Rando$new()\nx$random\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7535612\n```\n\n\n:::\n\n```{.r .cell-code}\nx$random\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.04193666\n```\n\n\n:::\n\n```{.r .cell-code}\nx$random\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7111096\n```\n\n\n:::\n:::\n\n\n## Active fields hide complexity like validating user input\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPerson <- R6Class(\"Person\", \n  private = list(\n    .age = NA,\n    .name = NULL\n  ),\n  active = list(\n    age = function(value) {\n      if (missing(value)) {\n        private$.age\n      } else {\n        stop(\"`$age` is read only\", call. = FALSE)\n      }\n    },\n    name = function(value) {\n      if (missing(value)) {\n        private$.name\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.name <- value\n        self\n      }\n    }\n  ),\n  public = list(\n    initialize = function(name, age = NA) {\n      private$.name <- name\n      private$.age <- age\n    }\n  )\n)\n\nnick <- Person$new(\"Nick\", age = 33)\nnick$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Nick\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnick$name <- 10\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in (function (value) : is.character(value) is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nnick$age <- 20\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error: `$age` is read only\n```\n\n\n:::\n:::\n\n\n# R6 object inheritance\n\n## `inherit` allows providing behavior from existing R6 classes\n\n-   The *add* method was modified for a more verbose behavior\n-   `super$add()` is the `add` method call from the inherited object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAccumulatorChatty <- R6Class(\"AccumulatorChatty\", \n  inherit = Accumulator,\n  public = list(\n    add = function(x = 1) {\n      cat(\"Adding \", x, \"\\n\", sep = \"\")\n      super$add(x = x)\n    }\n  )\n)\n\nx2 <- AccumulatorChatty$new()\nx2$add(10)$add(1)$sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Adding 10\n#> Adding 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11\n```\n\n\n:::\n:::\n\n\n# R6 finalizers for clean up duty\n\n## `$finalize()` deletes/unlinks anything created by the R6 object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- R6Class(\"A\", private = list(\n  finalize = function() {\n    print(\"Finalizer has been called!\")\n  }\n))\n\nobj <- A$new()\n\nrm(obj); gc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Finalizer has been called!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           used (Mb) gc trigger (Mb) max used (Mb)\n#> Ncells  686302 36.7    1511162 80.8  1511162 80.8\n#> Vcells 1261105  9.7    8388608 64.0  2049170 15.7\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "14_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}