{
  "hash": "fa786e33ce0718656526e4997d4bda69",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Evaluation\n---\n\n## Learning objectives:\n\n- Learn evaluation basics\n- Learn about **quosures** and **data mask**\n- Understand tidy evaluation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(purrr)\n```\n:::\n\n\n## A bit of a recap\n\n- Metaprogramming: To separate our description of the action from the action itself \n    + Separate the code from its evaluation.\n- Quasiquotation: combine code written by the *function's author* with code (expressions) \n    written by the *function's user*.\n    + Unquotation: gives the *user* the ability to evaluate parts of a quoted argument.\n    + Evaluation: gives the *developer* the ability to evaluate quoted expression in custom environments.\n\n**Non-standard evaluation** ([NSE](https://developer.r-project.org/nonstandard-eval.pdf)): \ndealing with expressions as function inputs in base R.\n\n**Tidy evaluation**: quasiquotation, quosures and data masks.\n\n## Evaluation basics \n\nWe use `base::eval()` to evaluate, run, or execute expressions. It requires two arguments: \n\n- `expr`: the object to evaluate, either an expression or a symbol.\n- `envir`: the environment in which to evaluate the expression or where to look for the values. \nDefaults to current environment (techncially `parent.frame()` which is the environment that `eval()` was called from).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumexpr <- expr(x + y)\nx <- 10\ny <- 40\neval(sumexpr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 50\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval(sumexpr, envir = env(x = 1000, y = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1010\n```\n\n\n:::\n:::\n\n\n\n## Application: reimplementing source()\n\nWhat do we need?\n\n- Read the file being sourced. \n- Parse its expressions (think: do we need to quote them?)\n- Evaluate each expression saving the results \n- Return the results (result of the last expression)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource2 <- function(path, env = caller_env()) {\n  file <- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs <- parse_exprs(file)\n\n  res <- NULL\n  for (i in seq_along(exprs)) {\n    res <- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n```\n:::\n\n\nThe real source is much more complex.\n\n## Quosures (1)\n\n`eval()` needs both the code and the environment to run the code in.\n\n**quosures** are a data structure from `rlang` containing both the expression and the environment.\n\n*Quoting* + *closure* because it quotes the expression and encloses the environment.\n\nThree ways to create quosures, in the upcoming slides.\n\n## Quosures (2)\n\nUsed mostly for learning: `new_quosure()`, creates a quosure from its components.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq1 <- rlang::new_quosure(expr(x + y), \n                         env(x = 1, y = 10))\n```\n:::\n\n\n## Quosures (3)\n\nUsed in the real world: `enquo()` or `enquos()`, to capture user supplied expressions. They take the environment from where they are created. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(x) enquo(x)\nquo_foo <- foo(a + b)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_expr(quo_foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> a + b\n```\n\n\n:::\n\n```{.r .cell-code}\nget_env(quo_foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n## Quosures (4)\n\nAlmost never used: `quo()` and `quos()`,  to match to `expr()` and `exprs()`.\n\n## Evaluation: eval_tidy()\n\nThe purpose of the concept of quosure is to be able to pass a single object\nto  `rlang::eval_tidy()`, as opposed to the expression-environment pair,\nas required for `base::eval()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::eval_tidy(q1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11\n```\n\n\n:::\n:::\n\n\nGet the quosure components if you need them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::get_expr(q1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> x + y\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::get_env(q1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x0000027140d5c6c8>\n```\n\n\n:::\n:::\n\n\nOr set them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq1 <- set_env(q1, env(x = 3, y = 4))\neval_tidy(q1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 7\n```\n\n\n:::\n:::\n\n\n\n## Quosures and ...\n\nQuosures are just a convenience, but they are essential when it comes to\nworking with `...`, because you can have different arguments from `...` \nassociated with different environments. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- function(...) {\n  ## Creating our quosures from ...\n  enquos(...)\n}\n\ncreateQuos <- function(...) {\n  ## symbol from the function environment\n  x <- 1\n  g(..., f = x)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## symbol from the global environment\nx <- 0\nqs <- createQuos(global = x)\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <list_of<quosure>>\n#> \n#> $global\n#> <quosure>\n#> expr: ^x\n#> env:  global\n#> \n#> $f\n#> <quosure>\n#> expr: ^x\n#> env:  0x00000271438a6388\n```\n\n\n:::\n:::\n\n\n## Other facts about quosures\n\nFormulas were the predecessor and inspiration for quosures because they also capture an expression and an environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- ~runif(3)\nstr(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Class 'formula'  language ~runif(3)\n#>   ..- attr(*, \".Environment\")=<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n(This creates weird problems when functions \nreturn formulas, which in turn may drag the entire `GlobalEnv` with them. Have 10Gb worth of objects in there? Let's store them all!!!)\n\nThere was an early version of tidy evaluation with formulas, but there's no easy way to implement quasiquotation with them. \n\nThey are actually call objects \n\n\n::: {.cell}\n\n```{.r .cell-code}\nq4 <- new_quosure(expr(x + y + z))\nclass(q4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"quosure\" \"formula\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.call(q4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\nwith an attribute to store the environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(q4, \".Environment\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n## Nested quosures\n\nWith quosiquotation we can embed quosures in expressions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nq2 <- new_quosure(expr(x), env(x = 1))\nq3 <- new_quosure(expr(x), env(x = 100))\n\nnq <- expr(!!q2 + !!q3)\n```\n:::\n\n\nAnd evaluate them: \n\n\n::: {.cell}\n\n```{.r .cell-code}\neval_tidy(nq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 101\n```\n\n\n:::\n:::\n\n\nDisplay: it is better to use `expr_print(x)` (note the subtle color differences\nindicating that the different `x`s come from different environments).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr_print(nq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> (^x) + (^x)\n```\n\n\n:::\n\n```{.r .cell-code}\nnq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> (~x) + ~x\n```\n\n\n:::\n:::\n\n\n## Data mask (1)\n\nData mask is a special type of quosure where the target environment is a data frame.\nThus the evaluated code will look first for the columns in the specified data frame. \n\nUsed in packages like `dplyr` and `ggplot2`. \n\nSupply the data mask as a second argument to `eval_tidy()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq1 <- new_quosure(expr(x * y), env(x = 100))\ndf <- data.frame(y = 1:10)\n\neval_tidy(q1, df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\n```\n\n\n:::\n:::\n\n\n## Data mask (2)\n\nReimplementing `base::with()` for the purposes of working with a `data.frame`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(data, expr) {\n  expr <- enquo(expr)\n  eval_tidy(expr, data)\n}\n```\n:::\n\n\nBut we need to create the objects that are not part of our data mask\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 100\nwith(df, x * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\n```\n\n\n:::\n\n```{.r .cell-code}\nwith2(df, x * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\n```\n\n\n:::\n:::\n\n\n## Data mask (3)\n\nAlso doable with `base::eval()` instead of `rlang::eval_tidy()` \nbut a strict base implementation would need to use `base::substitute()`\ninstead of `enquo()` (like we did for `enexpr()`) ,\nand we need to specify the environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith3 <- function(data, expr) {\n  expr <- substitute(expr)\n  eval(expr, data, caller_env())\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith3(df, x*y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\n```\n\n\n:::\n:::\n\n\n## Reference ambiguity\n\nWhen you write\n\n```\nwith2(df, y = x)\n```\n\nDo you mean `x` as the column in `df`, or as an object in the environment?\n\n(`devtools::check()` finds these and complains about '_no visible global bindings_'.)\n\nAn object value can come from the env or from the data \n\n\n::: {.cell}\n\n```{.r .cell-code}\nq1 <- new_quosure(expr(x * y + x), env = env(x = 1))\ndf <- data.frame(y = 1:5, \n                 x = 10)\n\neval_tidy(q1, df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20 30 40 50 60\n```\n\n\n:::\n:::\n\n\n## rlang pronouns: .data$ and .env$\n\n`rlang` provides pronouns: \n\n- `.data$x`: take `x` from the data mask\n- `.env$x`: take `x` from the environment\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq1 <- new_quosure(expr(.data$x * y + .env$x), env = env(x = 1))\neval_tidy(q1, df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11 21 31 41 51\n```\n\n\n:::\n:::\n\n\n## Application: reimplementing base::subset()\n\n`base::subset()` works like `dplyr::filter()`: it selects rows of a data frame given an expression. \n\nWhat do we need?\n\n- Quote the expression to filter\n- Figure out which rows in the data frame pass the filter\n- Subset and return the data frame\n\n## subset2()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset2 <- function(data, rows) {\n  rows <- enquo(rows)\n  rows_val <- eval_tidy(rows, data)\n  stopifnot(\"rows argument does not evaluate to a subsetting condition\" = \n    is.logical(rows_val) && length(rows_val)==nrow(data))\n\n  data[rows_val, , drop = FALSE]\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 2, 4, 1))\n\n# Shorthand for sample_df[sample_df$b == sample_df$c, ]\nsubset2(sample_df, b == c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   a b c\n#> 1 1 5 5\n#> 5 5 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsubset2(sample_df, 42)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `subset2()`:\n#> ! rows argument does not evaluate to a subsetting condition\n```\n\n\n:::\n\n```{.r .cell-code}\nsubset2(sample_df, TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `subset2()`:\n#> ! rows argument does not evaluate to a subsetting condition\n```\n\n\n:::\n:::\n\n\n## select() columns (1)\n\nLet us implement one more feature of `base::subset(select=_some columns_)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)\nsubset(df, select = b:d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   b c d\n#> 1 2 3 4\n```\n\n\n:::\n:::\n\n\n## select2() columns (2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars <- as.list(set_names(seq_along(df), names(df)))\nstr(vars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 5\n#>  $ a: int 1\n#>  $ b: int 2\n#>  $ c: int 3\n#>  $ d: int 4\n#>  $ e: int 5\n```\n\n\n:::\n:::\n\n\n## select2() columns (3)\n\n(`base` trivia: why do you need `drop = FALSE`?)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect2 <- function(data, ...) {\n  dots <- enquos(...)\n\n  vars <- as.list(set_names(seq_along(data), names(data)))\n  cols <- unlist(map(dots, eval_tidy, vars))\n\n  data[, cols, drop = FALSE]\n}\nselect2(df, b:d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   b c d\n#> 1 2 3 4\n```\n\n\n:::\n:::\n\n\n`tidyselect` helpers: provide more functions that return logical expressions\nto be added to `cols`.\n\n## Using tidy evaluation\n\nMost of the time we might not do it in our code, but we often end up calling a function \nthat uses `eval_tidy()` (becoming developer AND user)\n\n**Use case**: resample and subset\n\nWe have a function that resamples a dataset: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nresample <- function(df, n) {\n  idx <- sample(nrow(df), n, replace = TRUE)\n  df[idx, , drop = FALSE]\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresample(sample_df, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     a b c\n#> 2   2 4 3\n#> 2.1 2 4 3\n#> 5   5 1 1\n#> 3   3 3 2\n#> 4   4 2 4\n#> 2.2 2 4 3\n#> 2.3 2 4 3\n#> 5.1 5 1 1\n#> 2.4 2 4 3\n#> 3.1 3 3 2\n```\n\n\n:::\n:::\n\n\nBut we also want to use subset and we want to create a function that allow us to resample and subset (with `subset2()`) in a single step. \n\n## Resample and subset (1)\n\nFirst attempt: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsample <- function(df, cond, n = nrow(df)) {\n  df <- subset2(df, cond)\n  resample(df, n)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsample(sample_df, b == c, 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error:\n#> ! object 'b' not found\n```\n\n\n:::\n:::\n\n\nWhat happened? \n\n## Resample and subset (2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsample <- function(df, cond, n = nrow(df)) {\n  df <- subset2(df, cond)\n  resample(df, n)\n}\n```\n:::\n\n\n`subsample()` doesn't quote any arguments and `cond` is evaluated normally.\nThe caller environment does not have `b` and `c` (or what is worse, if it does,\nthe intent of the condition goes out the window.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- 5\nc <- c(2,3,4)\nsubsample(sample_df, b == c, 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `subset2()`:\n#> ! rows argument does not evaluate to a subsetting condition\n```\n\n\n:::\n:::\n\n\n## Resample and subset (3)\n\nSo we have to quote `cond` and unquote it when we pass it to `subset2()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsample <- function(df, cond, n = nrow(df)) {\n  cond <- enquo(cond)\n  df <- subset2(df, !!cond)\n  resample(df, n)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsample(sample_df, b == c, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     a b c\n#> 5   5 1 1\n#> 1   1 5 5\n#> 1.1 1 5 5\n```\n\n\n:::\n:::\n\n\n## Ambiguity with \"known\" column names\n\n**Be careful!**, potential ambiguity:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_x <- function(df, val) {\n  subset2(df, x >= val)\n}\n```\n:::\n\n\nWhat would happen if `x` exists in the calling environment but doesn't exist in `df`? Or if `val` also exists in `df`?\n\n\nSo, as developers of `threshold_x()` and users of `subset2()`, we have to add \ndisambiguating pronouns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_x <- function(df, val) {\n  subset2(df, .data$x >= .env$val)\n}\n```\n:::\n\n\n## Tidy eval, summarized\n\nThresholding on steroids:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_expr <- function(df, expr, val) {\n  expr <- enquo(expr)\n  subset2(df, !!expr >= !!val)\n}\n```\n:::\n\n\nIt may not be possible to evaluate `expr` only in the data mask, \nbecause the data mask does not include any functions nor\noperations like `+` or `==`.\n\nJust remember:  \n\n> As a general rule of thumb, as a function author it’s your responsibility \n> to avoid ambiguity with any expressions that you create; \n> it’s the user’s responsibility to avoid ambiguity in expressions that they create.\n\n\n## Base evaluation: `substitute()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset_base <- function(data, rows) {\n  rows <- substitute(rows)      # instead of enquo()\n  rows_val <- eval(rows, data,  # instead of \n                caller_env())   #  eval_tidy()\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n```\n:::\n\n\nThe base world forces us to evaluate in the caller environment\nrather in the environment where it is defined (quosure);\nloss of flexibility.\n\n## Base evaluation: `match.call()`\n\n`match.call()` captures the entire call. \nA number of `base` functions (and `base`-only packages like `survey`) use it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm2 <- function(formula, data) {\n  lm(formula, data)\n}\nlm2(mpg ~ disp, mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = formula, data = data)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122\n```\n\n\n:::\n\n```{.r .cell-code}\nlm2(mpg ~ disp, mtcars)$call\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> lm(formula = formula, data = data)\n```\n\n\n:::\n:::\n\n\n## Fixing match.call()\n\n`lm()` itself cannot really do better as that was all it received,\nand it could not possibly figure out the components.\nTo overcome this problem, we need to capture the arguments as expressions,\ncreate the call to `lm()` using unquoting, then evaluate that call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm3 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  data <- enexpr(data)\n\n  lm_call <- expr(lm(!!formula, data = !!data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\nlm3(mpg ~ disp, mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> lm(mpg ~ disp, data = mtcars)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = mpg ~ disp, data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}