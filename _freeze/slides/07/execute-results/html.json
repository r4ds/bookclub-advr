{
  "hash": "3974c323ae8392371250f6b243d31aa2",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Environments\n---\n\n## Learning objectives\n\n- Create, modify, and inspect environments \n\n- Recognize special environments \n\n- Understand how environments power lexical scoping and namespaces\n\n# 7.2 Environment Basics\n\n## Environments are similar to lists\n\nGenerally, an environment is similar to a named list, with four important exceptions:\n\n- Every name must be unique.\n\n- The names in an environment are not ordered.\n\n- An environment has a parent.\n\n- Environments are not copied when modified.\n\n::: {.notes}\n\n- Lists can have duplicate names, e.g. x <- base::list(a = 1, a = 1)\n\n- Lists have an inherent order, e.g. x[[1]] returns the first element of the list above\n\n- Environments copy by reference, not by replacement, e.g.: \n\n  Modifying a list produces a different memory address\n  base::identical(lobstr::obj_addr(x), lobstr::obj_addr({x[[1]] <- 2; x}))\n\n  y <- rlang::env()\n  y$'a' <- 1\n\n  base::identical(\n    lobstr::obj_addr(y),\n    lobstr::obj_addr({y[['a']] <- 2; y})\n  )\n\n:::\n\n## Create a new environment with `{rlang}`\n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1 <- rlang::env(\n  rlang::global_env(),\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n```\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne2 <- rlang::new_environment(\n  data = list(\n    a = FALSE,\n    b = \"a\",\n    c = 2.3,\n    d = 1:3\n  ),\n  parent = rlang::global_env()\n)\n```\n:::\n\n\n:::\n\n::::\n\n::: {.notes}\n\nrlang::env() creates a child of the current environment by default and takes a variable number of named objects to populate it.\n\nrlang::new_environment() creates a child of the empty environment by default and takes a named list of objects to populate it.\n\n:::\n\n\n## An environment associates, or **binds** a set of names to a set of values\n\n:::: {.columns}\n\n::: {.column}\n\n- A bag of names with no implied order\n\n- Bindings live within the environment\n\n![](images/07-bindings.png)\n\n:::\n\n::: {.column}\n\n- Environments have reference semantics and thus can contain themselves\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1$d <- e1\n```\n:::\n\n\n![](images/07_loop.png)\n\n:::\n\n::::\n\n::: {.notes}\n\nno implied order (unlike a list, so no index subsetting)\n\nthe grey box represents an environment \n\nthe blue dot represents the parent environment \n\nletters represent variable names bound within the environment\n\n--- \n\nreference semantics store a reference to the object's memory address, not the actual value (as is done in value semantics)\n\n:::\n \n## Inspect environments with `{rlang}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_print(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000242caa09348>\n#> Parent: <environment: global>\n#> Bindings:\n#> • a: <lgl>\n#> • b: <chr>\n#> • c: <dbl>\n#> • d: <int>\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_names(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_has(e1, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    a \n#> TRUE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_get(e1, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_parent(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nbase::print() displays the memory address and is not as helpful as rlang::env_print()\n\n:::\n\n## By default, the current environment is your global environment\n\n- The current environment is where code is currently executing\n\n- The global environment *is* your current environment when working interactively\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::current_env()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::global_env()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::identical(\n  rlang::current_env(),\n  rlang::global_env()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nIf you open a new R session, you are in the global environment by default (unless otherwise modified by say the .rprofile file)\n\nThe current environment isn't *always* your global environment. Your current environment changes as you move into and out of functions, for example.\n\n:::\n\n## Every environment has a parent environment \n\n- Allows for lexical scoping\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne2a <- rlang::env(d = 4, e = 5)\n\ne2b <- rlang::env(e2a, a = 1, b = 2, c = 3)\n\nrlang::env_parent(e2b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000242cc7ab7e0>\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::env_parents(e2b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]   <env: 0x00000242cc7ab7e0>\n#> [[2]] $ <env: global>\n```\n\n\n:::\n:::\n\n\n![](images/07_parents.png)\n\n::: {.notes}\n\nLexical scoping means if a name is not found in an environment, then R will look in its parent (and so on)\n\nLexical scoping is in contrast to dynamic scoping, where the variable is retrieved as it is defined at run time \n\n:::\n\n## Only the **empty** environment does not have a parent\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne2c <- rlang::env(rlang::empty_env(), d = 4, e = 5)\n\ne2d <- rlang::env(e2c, a = 1, b = 2, c = 3)\n```\n:::\n\n\n![](images/07_parents-empty.png){width=50% height=50%}\n\n::: {.notes}\n\nTHe lack of a parent is shown by the hollow blue dot\n\n:::\n\n## All environments eventually terminate with the empty environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_parents(e2b, last = rlang::empty_env())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [[1]]   <env: 0x00000242cc7ab7e0>\n#>  [[2]] $ <env: global>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>\n#> [[11]] $ <env: empty>\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nThe empty enviornment typically isn't shown but can be displayed by setting the `last` parameter of `rlang::env_parents()`\n\n:::\n\n## Be wary of using `<<-`\n\n- Regular assignment (`<-`) always creates a variable in the current environment\n\n- Super assignment (`<<-`) does a few things:\n\n  1. modifies the variable if it exists in a parent environment\n\n  2. creates the variable in the global environment if it does not exist \n\n::: {.notes}\n\n`<<-` searches through environments via the search path, using the first found instance of the variable \n\n`<<--` does not search through package environments as they are above the global environment on the search path\n\ne1 <- rlang::env()\ne2 <- rlang::env(e1)\n\nrlang::env_poke(e1, \"a\", 1)\n\nwithr::with_environment(\n  e2,\n  a <<- 2\n)\n:::\n\n\n## Retrieve environment variables with `$`, `[[`, or `{rlang}` functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3 <- rlang::env(x = 1, y = 2)\n\ne3$x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3[[\"x\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_get(e3, \"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3[[1]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in e3[[1]]: wrong arguments for subsetting an environment\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3[\"x\"]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in e3[\"x\"]: object of type 'environment' is not subsettable\n```\n\n\n:::\n:::\n\n\n## Add bindings to an environment with ``$`, `[[`, or `{rlang}` functions`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne3$z <- 3\n\ne3[[\"z\"]] <- 3\n\nrlang::env_poke(e3, \"z\", 3)\n\nrlang::env_bind(e3, z = 3, b = 20)\n\nrlang::env_unbind(e3, \"z\")\n```\n:::\n\n\n::: {.notes}\n\nrlang::env_has() is used to check if a variable exists within the environment\n\nrlang::env_unbind() is used to unbind a variable from an environment\n\n:::\n\n## Special cases for binding environment variables\n\n- `rlang::env_bind_lazy()` creates delayed bindings\n\n  - evaluated the first time they are accessed\n\n- `rlang::env_bind_active()` creates active bindings\n\n  - re-computed every time they’re accessed\n\n# 7.3 Recursing over environments\n\n## Explore environments recursively \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n```\n:::\n\n\n::: {.notes}\n\nWhy is recursing over environments important? \n\nRecursion is not the same thing as iteration\n\n:::\n\n# 7.4 Special Environments\n\n## Attaching packages changes the search path \n\n- The **search path** is the order in which R will look through environments for objects\n\n- Attached packages become a parent of the global environment\n\n- The immediate parent of the global environment is that last package attached\n\n![](images/07_search-path.png)\n\n\n::: {.notes}\n\nAutoloads and base are always the last two environments on the search path\n\nAutoloads uses lazy loading to make large package objects (like datasets) available without taking up memory\n\nFunctions within base are used to load all other packages\n\n:::\n\n## Attaching packages changes the search path \n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::search_envs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]] $ <env: global>\n#> [[2]] $ <env: package:stats>\n#> [[3]] $ <env: package:graphics>\n#> [[4]] $ <env: package:grDevices>\n#> [[5]] $ <env: package:utils>\n#> [[6]] $ <env: package:datasets>\n#> [[7]] $ <env: package:methods>\n#> [[8]] $ <env: Autoloads>\n#> [[9]] $ <env: package:base>\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\n\nrlang::search_envs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [[1]] $ <env: global>\n#>  [[2]] $ <env: package:rlang>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n::: {.notes}\n\nAttaching `{rlang}` modifies the search path\n\n:::\n\n## Functions enclose their current environment\n\n- Functions enclose current environment when it is created\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 1\n\nf <- function(x) x + y\n\nrlang::fn_env(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n![](images/07_binding.png)\n\n::: {.notes}\n\nThe function environment is represented by the black dot\n\nThe function `f()` knows where to look for y thanks to the function environment\n\n:::\n\n## Functions enclose their current environment\n\n- `g()` is *being bound by* the environment `e` but *binds* the global environment \n\n- The function environment is the global environment but the binding environment is `e` \n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- env()\n\ne$g <- function() 1\n\nrlang::fn_env(e$g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n## Functions enclose their current environment\n\n![](images/07_binding-2.png)\n\n## Namespaces ensure package environment independence\n\n- Every package has an underlying namespace\n\n- Every function is associated with a package environment and namespace environment\n\n- Package environments contain exported objects\n\n- Namespace environments contain exported and internal objects\n\n::: {.notes}\n\nContrast `dplyr::across` and `dplyr:::across_glue_mask()` \n\n`sd()` is bound to the `{stats}` namespace environment\n\n:::\n\n## Namespaces ensure package environment independence\n\n![](images/07_namespace-bind.png)\n\n## Namespaces ensure package environment independence\n\n![](images/07_namespace.png)\n\n::: {.notes}\n\n`var()` is found in the stats namespace first, so that is the definition of var that is used by `sd()`\n\nIf an object called by `sd()` wasn't found in the stats namespace, it would be searched for according to the search path \n\n:::\n\n## Functions use ephemeral execution environments\n\n- Functions create a new environment to use whenever executed\n\n- The execution environment is a child of the function environment\n\n- Execution environments are garbage collected on function exit  \n\n## Functions use ephemeral execution environments\n\n![](images/07_execution.png)\n\n# 7.5 Call stacks\n\n## The caller environment informs the call stack\n\n- The caller environment is the environment from which the function was called\n\n- Accessed with `rlang::caller_env()` \n\n- The call stack is created within the caller environment\n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  lobstr::cst()\n}\n```\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf(x = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     ▆\n#>  1. └─global f(x = 1)\n#>  2.   └─global g(x = 2)\n#>  3.     └─global h(x = 3)\n#>  4.       └─lobstr::cst()\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n::: {.notes}\n\n`traceback()` is the base R approach\n\n`lobstr::cst()` prints the call stack in order of call, opposite of `traceback()`\n\nDoes `lobstr::cst()` now prints the caller environment?\n\n:::\n\n## The caller environment informs the call stack\n\n- Call stack is more complicated with lazy evaluation\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- function(x) b(x)\nb <- function(x) d(x)\nd <- function(x) x\n\na(f())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     ▆\n#>  1. ├─global a(f())\n#>  2. │ └─global b(x)\n#>  3. │   └─global d(x)\n#>  4. └─global f()\n#>  5.   └─global g(x = 2)\n#>  6.     └─global h(x = 3)\n#>  7.       └─lobstr::cst()\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nDo different branches represent different caller environments?\n\nNote that `c()` was replaced with `d()` as it could not be rendered with `c()`\n\n:::\n\n## The caller environment informs the call stack\n\n![](images/07_calling.png) \n\n::: {.notes}\n\n- Each frame contains: \n\n  1. An expression\n\n  2. An environment\n\n  3. A parent\n\n:::\n\n## R uses lexical scoping, not dynamic scoping\n\n> R uses lexical scoping: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective that means relating to words or a vocabulary. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure. - [Chapter 6 - functions](https://adv-r.hadley.nz/functions.html)\n\n- Dynamic scoping means functions use variables as they are defined in the calling environment\n\n# 7.6 Data structures\n\n## Environments are useful data structures\n\n- Usecase include:\n\n  1. Avoiding copies of large data\n\n  2. Managing state within a package\n\n  3. As a hashmap\n\n::: {.notes} \n\nFinding a function in a package uses constant time\n\n:::\n\n\n\n",
    "supporting": [
      "07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}