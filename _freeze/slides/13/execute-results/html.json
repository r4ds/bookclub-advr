{
  "hash": "0135cfc06c3306a7fdaff8726aa797b1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: S3\n---\n\n# The S3 class is R's first and simplest functional OOP system\n\n## Learning Objectives\n\n1.  Recognize S3 objects and classes.\n2.  Assign S3 classes to objects.\n3.  Create S3 generics and methods.\n4.  Implement advanced features of S3.\n\n# What is an S3 object?\n\n## S3 objects have a `class` attribute\n\nAn S3 object has an attribute called \"class\" with at least one value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- factor(c(\"a\", \"b\", \"c\"))\nattributes(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $levels\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> $class\n#> [1] \"factor\"\n```\n\n\n:::\n:::\n\n\n## S3 generics provide an interface to a particular behavior\n\n-   Generic function (or \"generic\"): Function that can be customized for different object classes.\n-   `print()` is an S3 generic for displaying objects depending on their class attribute.\n\n## `print()` is an S3 generic\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::ftype(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"S3\"      \"generic\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbody(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> UseMethod(\"print\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_dispatch(print(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => print.factor\n#>  * print.default\n```\n\n\n:::\n:::\n\n\n## `print()` behaves differently depending on the object's class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] a b c\n#> Levels: a b c\n```\n\n\n:::\n\n```{.r .cell-code}\nf_uc <- unclass(f)\nclass(f_uc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(f_uc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 3\n#> attr(,\"levels\")\n#> [1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n## `print.factor()` is a `print()` method for factors\n\nMethod: A function customized for a particular class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.factor # or sloop::s3_get_method(\"print.factor\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, quote = FALSE, max.levels = NULL, width = getOption(\"width\"), \n#>     ...) \n#> {\n#>     ord <- is.ordered(x)\n#>     if (length(x) == 0L) \n#>         cat(if (ord) \n#>             \"ordered\"\n#>         else \"factor\", \"()\\n\", sep = \"\")\n#>     else {\n#>         xx <- character(length(x))\n#>         xx[] <- as.character(x)\n#>         keepAttrs <- setdiff(names(attributes(x)), c(\"levels\", \n#>             \"class\"))\n#>         attributes(xx)[keepAttrs] <- attributes(x)[keepAttrs]\n#>         print(xx, quote = quote, ...)\n#>     }\n#>     maxl <- max.levels %||% TRUE\n#>     if (maxl) {\n#>         n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, \n#>             \"\\\"\", \"\")))\n#>         colsep <- if (ord) \n#>             \" < \"\n#>         else \" \"\n#>         T0 <- \"Levels: \"\n#>         if (is.logical(maxl)) \n#>             maxl <- {\n#>                 width <- width - (nchar(T0, \"w\") + 3L + 1L + \n#>                   3L)\n#>                 lenl <- cumsum(nchar(lev, \"w\") + nchar(colsep, \n#>                   \"w\"))\n#>                 if (n <= 1L || lenl[n] <= width) \n#>                   n\n#>                 else max(1L, which.max(lenl > width) - 1L)\n#>             }\n#>         drop <- n > maxl\n#>         cat(if (drop) \n#>             paste(format(n), \"\"), T0, paste(if (drop) \n#>             c(lev[1L:max(1, maxl - 1)], \"...\", if (maxl > 1) lev[n])\n#>         else lev, collapse = colsep), \"\\n\", sep = \"\")\n#>     }\n#>     if (!isTRUE(val <- .valid.factor(x))) \n#>         warning(val)\n#>     invisible(x)\n#> }\n#> <bytecode: 0x0000025824b39540>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n# How does one create an S3 class?\n\n## Assign an S3 class to a new object with `structure()` or `class()<-`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- structure(list(), class = \"my_class\")\n\nx <- list()\nclass(x) <- \"my_class\"\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $class\n#> [1] \"my_class\"\n```\n\n\n:::\n:::\n\n\nBut currently, this is pretty useless...\n\n## Create new S3 classes with 3 functions\n\n1.  A **low-level constructor**, `new_myclass()`, that efficiently creates new objects with the correct structure.\n\n2.  A **validator**, `validate_myclass()`, that performs more computationally expensive checks to ensure that the object has correct values.\n\n3.  A **user-friendly helper**, `myclass()`, that provides a convenient way for others to create objects of your class.\n\n## 1. `new_factor()` creates the new S3 object\n\nThe developer-facing function applies the correct structure for the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_factor <- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nnew_factor(1:3, c(\"a\",\"b\",\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] a b c\n#> Levels: a b c\n```\n\n\n:::\n:::\n\n\n## 2. `validate_factor()` provides assurances on correctness\n\nThough computationally expensive, the checks ensure correct values before creating the S3 object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalidate_factor <- function(x) {\n  values <- unclass(x)\n  levels <- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values > 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) < max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nvalidate_factor(new_factor(1:5, \"a\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error: There must be at least as many `levels` as possible values in `x`\n```\n\n\n:::\n\n```{.r .cell-code}\nvalidate_factor(new_factor(0:1, \"a\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error: All `x` values must be non-missing and greater than zero\n```\n\n\n:::\n:::\n\n\n## 3. `factor()` provides a safe approach for users to create objects\n\nThe user-facing validates the values before creating the S3 object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- function(x = character(), levels = unique(x)) {\n  ind <- match(x, levels)\n  new_factor(ind, levels) |> \n    validate_factor()\n}\n\nfactor(c(\"a\", \"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] a a b\n#> Levels: a b\n```\n\n\n:::\n:::\n\n\n## Example S3 classes \"in the wild\" use the recommended interface\n\n-   `tibble::new_tibble()`, `tibble::validate_tibble()`, `tibble::tibble()`\n\n-   `dplyr::new_grouped_df()`, `dplyr::validate_grouped_df()`, `dplyr::grouped_df()`\n\n# How do generics perform dispatching?\n\n## `summary()`  is an S3 generic that behaves based on an object's class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::is_s3_generic(\"summary\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (object, ...) \n#> UseMethod(\"summary\")\n#> <bytecode: 0x0000025822139b98>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_methods_generic(\n  \"summary\"\n) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|generic |class                      |visible |source              |\n|:-------|:--------------------------|:-------|:-------------------|\n|summary |aov                        |TRUE    |stats               |\n|summary |aovlist                    |FALSE   |registered S3method |\n|summary |aspell                     |FALSE   |registered S3method |\n|summary |check_packages_in_dir      |FALSE   |registered S3method |\n|summary |connection                 |TRUE    |base                |\n|summary |data.frame                 |TRUE    |base                |\n|summary |Date                       |TRUE    |base                |\n|summary |default                    |TRUE    |base                |\n|summary |difftime                   |TRUE    |base                |\n|summary |ecdf                       |FALSE   |registered S3method |\n|summary |factor                     |TRUE    |base                |\n|summary |glm                        |TRUE    |stats               |\n|summary |infl                       |FALSE   |registered S3method |\n|summary |lm                         |TRUE    |stats               |\n|summary |loess                      |FALSE   |registered S3method |\n|summary |manova                     |TRUE    |stats               |\n|summary |matrix                     |TRUE    |base                |\n|summary |mlm                        |FALSE   |registered S3method |\n|summary |nls                        |FALSE   |registered S3method |\n|summary |packageStatus              |FALSE   |registered S3method |\n|summary |POSIXct                    |TRUE    |base                |\n|summary |POSIXlt                    |TRUE    |base                |\n|summary |ppr                        |FALSE   |registered S3method |\n|summary |prcomp                     |FALSE   |registered S3method |\n|summary |princomp                   |FALSE   |registered S3method |\n|summary |proc_time                  |TRUE    |base                |\n|summary |rlang:::list_of_conditions |FALSE   |registered S3method |\n|summary |rlang_error                |FALSE   |registered S3method |\n|summary |rlang_message              |FALSE   |registered S3method |\n|summary |rlang_trace                |FALSE   |registered S3method |\n|summary |rlang_warning              |FALSE   |registered S3method |\n|summary |srcfile                    |TRUE    |base                |\n|summary |srcref                     |TRUE    |base                |\n|summary |stepfun                    |TRUE    |stats               |\n|summary |stl                        |FALSE   |registered S3method |\n|summary |table                      |TRUE    |base                |\n|summary |tukeysmooth                |FALSE   |registered S3method |\n|summary |vctrs_sclr                 |FALSE   |registered S3method |\n|summary |vctrs_vctr                 |FALSE   |registered S3method |\n|summary |warnings                   |TRUE    |base                |\n\n\n:::\n:::\n\n\n::: notes\nThis slide throws a warning because the generated table actually includes 3 colons. It isn't a \"problemwith a fenced div\" like the warning thinks. \n:::\n\n## `summary()` is an interface to different methods\n\n-   Polymorphism: a single interface to different behaviors.\n\n-   However, `summary()` does not have a consistent output class.\n\n::: panel-tabset\n### iris\\$Sepal.Length\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- iris$Sepal.Length\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(a_summary <- summary(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>   4.300   5.100   5.800   5.843   6.400   7.900\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_class(a_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"summaryDefault\" \"table\"\n```\n\n\n:::\n:::\n\n\n### iris\\$Species\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- iris$Species\nclass(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(b_summary <- summary(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     setosa versicolor  virginica \n#>         50         50         50\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_class(b_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\" \"numeric\"\n```\n\n\n:::\n:::\n\n:::\n\n## The custom `summarizer()` S3 generic outputs a consistent object\n\n-   The goal is to summarize characters, factors, and numeric objects\n-   The output should always be a length one character object\n\n### Create a new S3 generic following two rules\n\n1.  Only write a method if you own the generic. Otherwise, it is considdered bad manners.\n2.  The method must have the same arguments as its generic--with one important exception: `...`\n\n## `summarizer()` includes `UseMethod` for dispatching\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer <- function(x, probs = c(0.25, 0.5, 0.75)) {\n  UseMethod(\"summarizer\")\n}\n```\n:::\n\n\n::: callout-caution\nYou donâ€™t pass any of the arguments of the generic to UseMethod(); it uses deep magic to pass to the method automatically. The precise process is complicated and frequently surprising, so you should avoid doing any computation in a generic. See `?UseMethod` for details.\n:::\n\n## `summarizer()` outputs consistent summary strings\n\nEncapsulation: Bundle data and methods into a single object or \"unit\".\n\n::: panel-tabset\n### Characters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer.character <- function(x, probs = c(0.25, 0.5, 0.75)) {\n  tab <- sort(table(x), decreasing = TRUE)\n  # Format as \"value (n)\"\n  pairs <- paste0(names(tab), \" (\", tab, \")\")\n  paste(pairs, collapse = \", \")\n}\n```\n:::\n\n\n### Numerics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer.numeric <- function(x, probs = c(0.25, 0.5, 0.75)) {\n  # Remove NAs to avoid warnings\n  x_no_na <- x[!is.na(x)]\n  \n  qs <- quantile(x_no_na, probs = probs, names = FALSE)\n  names(qs) <- paste0(\"Q\", seq_along(qs))\n\n  stats <- c(\n    Min = min(x_no_na),\n    qs,\n    Max = max(x_no_na)\n  )\n  \n  paste0(\n    paste(names(stats), format(stats), sep = \": \", collapse = \", \")\n  )\n}\n```\n:::\n\n\n### Factors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer.factor <- function(x, probs = c(0.25, 0.5, 0.75)) {\n  # Just delegate to character method on the labels\n  summarizer(as.character(x), probs = probs)\n}\n```\n:::\n\n\n### Default\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer.default <- function(x, probs = c(0.25, 0.5, 0.75)) {\n  cls <- paste(class(x), collapse = \", \")\n  paste0(\"No summarizer method for class: \", cls)\n}\n```\n:::\n\n\n### Vector Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer(c(\"apple\", \"apple\", \"pear\", \"pear\", \"pear\", \"orange\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"pear (3), apple (2), orange (1)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummarizer(factor(c(\"a\",\"b\",\"b\",\"a\",\"c\",\"c\",\"c\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"c (3), a (2), b (2)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummarizer(c(1,2,3,4,5,6,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Min:  1.0, Q1:  2.5, Q2:  4.0, Q3:  5.5, Max: 10.0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummarizer(c(1,50,100,250), probs = c(.1, .9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Min:   1.0, Q1:  15.7, Q2: 205.0, Max: 250.0\"\n```\n\n\n:::\n:::\n\n\n### Dataframe Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> \n  vapply(\n    summarizer,\n    character(1)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                                         Sepal.Length \n#>      \"Min: 4.3, Q1: 5.1, Q2: 5.8, Q3: 6.4, Max: 7.9\" \n#>                                          Sepal.Width \n#>      \"Min: 2.0, Q1: 2.8, Q2: 3.0, Q3: 3.3, Max: 4.4\" \n#>                                         Petal.Length \n#> \"Min: 1.00, Q1: 1.60, Q2: 4.35, Q3: 5.10, Max: 6.90\" \n#>                                          Petal.Width \n#>      \"Min: 0.1, Q1: 0.3, Q2: 1.3, Q3: 1.8, Max: 2.5\" \n#>                                              Species \n#>       \"setosa (50), versicolor (50), virginica (50)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsurvival::lung |> \n  vapply(\n    summarizer,\n    character(1)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                                                                inst \n#>                          \"Min:  1, Q1:  3, Q2: 11, Q3: 16, Max: 33\" \n#>                                                                time \n#> \"Min:    5.00, Q1:  166.75, Q2:  255.50, Q3:  396.50, Max: 1022.00\" \n#>                                                              status \n#>                               \"Min: 1, Q1: 1, Q2: 2, Q3: 2, Max: 2\" \n#>                                                                 age \n#>                          \"Min: 39, Q1: 56, Q2: 63, Q3: 69, Max: 82\" \n#>                                                                 sex \n#>                               \"Min: 1, Q1: 1, Q2: 1, Q3: 2, Max: 2\" \n#>                                                             ph.ecog \n#>                               \"Min: 0, Q1: 0, Q2: 1, Q3: 1, Max: 3\" \n#>                                                            ph.karno \n#>                     \"Min:  50, Q1:  75, Q2:  80, Q3:  90, Max: 100\" \n#>                                                           pat.karno \n#>                     \"Min:  30, Q1:  70, Q2:  80, Q3:  90, Max: 100\" \n#>                                                            meal.cal \n#>                \"Min:   96, Q1:  635, Q2:  975, Q3: 1150, Max: 2600\" \n#>                                                             wt.loss \n#>      \"Min: -24.00, Q1:   0.00, Q2:   7.00, Q3:  15.75, Max:  68.00\"\n```\n\n\n:::\n:::\n\n:::\n\n## The next method is used for missing `summarizer()` generics\n\nInheritance: method dispatching through the \"class\" attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- iris$Species\nsummarizer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"setosa (50), versicolor (50), virginica (50)\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(class(a) <- c(\"my_class\",class(a)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"my_class\" \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummarizer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"setosa (50), versicolor (50), virginica (50)\"\n```\n\n\n:::\n:::\n\n\n# What are advanced implementations of S3 classes?\n\n## S3 classes can *conceal* data elements from `length()` for concise representation\n\n-   Record style objects use a list of equal-length vectors to represent individual components of the object.\n-   The best example of this is POSIXlt, which underneath the hood is a list of 11 date-time components like year, month, and day.\n-   Record style classes override length() and subsetting methods to conceal this implementation detail.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-01-01 00:00:01 CST\" \"2020-01-01 00:00:02 CST\"\n#> [3] \"2020-01-01 00:00:03 CST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(unclass(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[1]] # the first date time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-01-01 00:00:01 CST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunclass(x)[[1]] # the first component, the number of seconds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 3\n```\n\n\n:::\n:::\n\n\n## `NextMethod()`delegates dispatch behavior for classes without explicit generics\n\n## `secret()` masks each character of the input with `x` in the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_secret <- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret <- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\ny <- new_secret(c(15, 1, 456))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"xx\"  \"x\"   \"xxx\"\n```\n\n\n:::\n:::\n\n\n## There is unexpected behavior without a `[` generic for the secret class\n\n-   The `[` method is problematic in that it does not preserve the `secret` class.\n-   `y[1]` returns `15` as the first element instead of `xx`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_dispatch(y[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    [.secret\n#>    [.default\n#> => [ (internal)\n```\n\n\n:::\n\n```{.r .cell-code}\ny[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 15\n```\n\n\n:::\n:::\n\n\nFix this with a `[.secret` method:\n\n## `NextMethod()` is an efficient way to subset a secret class\n\n::: {.panel-tabset}\n\n### `NextMethod()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`[.secret` <- function(x, i) {\n  # first, dispatch to `[`\n  # then, coerce subset value to `secret` class\n  new_secret(NextMethod())\n}\n```\n:::\n\n\n-   `[.secret` is selected, but delegates to internal `[`.\n-   Makes secret object for that element alone\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_dispatch(y[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => [.secret\n#>    [.default\n#> -> [ (internal)\n```\n\n\n:::\n\n```{.r .cell-code}\ny[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"xx\"\n```\n\n\n:::\n:::\n\n\n### Inefficient approach \n\n-   Includes copying and infinite loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not run\n`[.secret` <- function(x, i) {\n  x <- unclass(x)\n  new_secret(x[i])\n}\n```\n:::\n\n\n:::\n\n## S3 classes can inherit generics from the superclass\n\n::: panel-tabset\n\n### Include superclass\n\n-   Note: You should 'own' the superclass constructor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_secret <- function(x, ..., class = character()) {\n  stopifnot(is.double(x))\n\n  structure(\n    x,\n    ...,\n    class = c(class, \"secret\")\n  )\n}\n```\n:::\n\n\n### Create subclass generic\n\n-   Simply invoke the superclass constructor inside of the subclass constructor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_supersecret <- function(x) {\n  new_secret(x, class = \"supersecret\")\n}\n\nprint.supersecret <- function(x, ...) {\n  print(rep(\"xxxxx\", length(x)))\n  invisible(x)\n}\n\nx2 <- new_supersecret(c(15, 1, 456))\nx2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n```\n\n\n:::\n:::\n\n\n### Use `vctrs::vec_restore`\n\n-   No way in base R to properly delegate methods in inheritance chain\n-   `vctrs::vec_restore` provides proper method chaining\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_restore.secret <- function(x, to, ...) new_secret(x)\nvec_restore.supersecret <- function(x, to, ...) new_supersecret(x)\n`[.secret` <- function(x, ...) {\n  vctrs::vec_restore(NextMethod(), x)\n}\nx2[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n```\n\n\n:::\n:::\n\n:::\n",
    "supporting": [
      "13_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}