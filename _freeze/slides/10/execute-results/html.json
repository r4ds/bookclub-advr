{
  "hash": "b44c07c13424958c1e0a255c08bfc89f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Function factories\n---\n\n\n::: {.cell}\n\n:::\n\n\n## Learning objectives:\n\nBy the end of today's session, you will be able to: \n\n- Identify function factories\n- Understand how function factories work\n- Learn about non-obvious combination of function features\n- Generate a family of functions from data\n\n## What is a function factory?\n\n:::: {.columns}\n\n::: {.column}\n\n- A **function factory** is a function that makes (returns) functions\n\n- Factory made function are **manufactured functions**\n\n::: \n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a function factory\npower1 <- function(exp) {\n  function(x) {\n    x^exp\n  }\n}\n\n# create manufactured functions\nsquare <- power1(2)\n\ncube <- power1(3)\n\n# execute manufactured functions\nsquare(2)\n#> 4\n\ncube(2)\n#> 8\n```\n:::\n\n\n:::\n\n::::\n\n::: {.notes}\n\n- A function that, in its body, returns a function is by definition a function factory\n\n- Of the three main functional programming tools (functionals, function factories, and function operators), function factories are the least used\n:::\n\n## Why function factories work\n\nFunction factories are powered by three features of the R language:\n\n1. R has first-class functions\n\n2. R functions capture the environment in which they are created\n\n3. R functions create a new execution environment\n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_print(square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x000001df5ee07af0>\n#> Parent: <environment: global>\n#> Bindings:\n#> • exp: <dbl>\n```\n\n\n:::\n:::\n\n\n::: \n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_print(cube)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x000001df5efbc190>\n#> Parent: <environment: global>\n#> Bindings:\n#> • exp: <dbl>\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n::: {.notes}\n\n- A language with first-class functions means the functions are objects that can be copied, bound, etc. \n\n- When they are created, manufactured functions capture the environment of the function factory\n\n- Manufactured functions have separate environments \n\n::: \n\n## Diagramming function factories\n\n![](images/10_power-full.png){fig-align=center}\n\n## Diagramming function factories\n\n![](images/10_power-exec.png){fig-align=center}\n\n\n## Forcing evaluation\n\n- Beware of changing bindings between creation and execution of manufactured functions\n\n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nsquare <- power1(x)\nx <- 3\nsquare(2)\n#> [1] 8\n```\n:::\n\n\n::: \n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower2 <- function(exp) {\n  force(exp)\n  function(x) {\n    x^exp\n  }\n}\n\nx <- 2\nsquare <- power2(x)\nx <- 3\nsquare(2)\n#> [1] 4\n```\n:::\n\n\n::: \n\n:::: \n\n::: {.notes}\n\n- As per lazy evaluation, `x` is evaluated for the first time when `square(2)` is called and at the time of evaluation, `x`, the exponent, is equal to 3\n\n- Use `force()` to force eager evaluation and avoid this type of bug introduced by lazy evaluation\n\n- Alternatively, use any other function to force the evaluation of the variable `x` during the creation of the manufactured function\n\n- This issue of lazy evaluation only applies for variables (e.g. running `power2(2)` is eagerly evaluated)\n\n:::\n\n\n## Stateful functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_counter <- function() {\n  i <- 0\n  function() {\n    i <<- i + 1\n    i\n  }\n}\n\ncounter_one <- new_counter()\ncounter_two <- new_counter()\n\ncounter_one()\n#> [1] 1\ncounter_one()\n#> [1] 2\ncounter_two()\n#> [1] 1\n```\n:::\n\n\n::: {.notes}\n\n- The manufactured functions create distinct enclosures of the function factory environment\n\n- As soon as your function starts managing the state of multiple variables, it’s better to switch to an object-oriented system like R6\n\n:::\n\n## Garbage collection\n\n- Manufactured functions hold on to variables in the enclosed function factory's environment\n\n:::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  function() m\n}\n\ng1 <- f1(1e6)\nlobstr::obj_size(g1)\n#> 8.00 MB\n```\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 <- f2(1e6)\nlobstr::obj_size(g2)\n#> 504 B\n```\n:::\n\n\n::: \n\n::::\n\n## Function factories + functionals\n\n:::: {.columns}\n\n::: {.column}\n\n- Combine functionals and function factories to turn data into many functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- list(\n  square = 2,\n  cube = 3,\n  root = 1 / 2,\n  cuberoot = 1 / 3,\n  reciprocal = -1\n)\nfuns <- purrr::map(names, power1)\n\nfuns$root(64)\n#> [1] 8\nfuns$root\n#> function (x)\n#> {\n#>     x^exp\n#> }\n#> <bytecode: 0x55ce583c7828>\n#> <environment: 0x55ce5a61cd60>\n```\n:::\n\n\n::: \n\n::: {.column}\n\nAvoid the `funs$` prefix with\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(funs, root(100))\n#> [1] 10\n```\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(funs)\n#> The following objects are\n#> masked _by_ .GlobalEnv:\n#>\n#>     cube, square\nroot(100)\n#> [1] 10\n```\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::env_bind(\n  globalenv(),\n  !!!funs\n)\n\nroot(100)\n#> [1] 10\n```\n:::\n\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}