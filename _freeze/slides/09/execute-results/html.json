{
  "hash": "96b7320c04a32ba42be7c250901cee69",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Functionals\n---\n\n## Learning objectives\n\n- Describe the \"functional style\" of programming in R.\n- Replace `for` loops with functionals.\n- Use the `purrr::map()` family of functions to apply a function to each element of a list or vector.\n- Combine multiple functionals to solve complex problems.\n- Use `purrr::reduce()` to combine elements of a vector into a single result.\n- Use predicate functionals to work with logical conditions.\n- Recognize and use base R functionals that lack `purrr` equivalents.\n\n## R is a functional language at heart\n\n- R lends itself to a style of problem solving centered on functions.\n- This \"functional style\" is a good fit for data analysis problems.\n- Functional techniques can produce efficient and elegant solutions.\n\n## Functional programming languages have first-class functions\n\nA key feature of functional languages is their use of **first-class functions**.\n\nIn R, this means you can:\n\n- Assign functions to variables.\n- Store them in lists.\n- Pass them as arguments to other functions.\n- Create them inside functions.\n- Return them as the result of a function.\n\n## Pure functions depend only on their inputs\n\nMany functional languages require functions to be **pure**.\n\n- A pure function's output only depends on its inputs.\n    - `runif()`, `read.csv()`, and `Sys.time()` are **not** pure.\n- A pure function has no side-effects (e.g., changing global variables, writing to disk).\n    - `print()`, `write.csv()`, and `<-` are **not** pure.\n\nR is not a *strictly* functional language because it doesn't require pure functions.\n\n## The \"functional style\" decomposes a big problem into smaller pieces\n\n- Solve each piece with a function or combination of functions.\n- Strive to create isolated functions that operate independently.\n- Complexity is handled by composing functions in various ways.\n\n## Key functional techniques\n\n- **Chapter 9: Functionals**: Functions that take a function as an argument.\n- **Chapter 10: Function factories**: Functions that create functions.\n- **Chapter 11: Function operators**: Functions that take functions as input and produce functions as output.\n\n## A functional takes a function as input and returns a vector as output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.5036247\n```\n\n\n:::\n\n```{.r .cell-code}\nrandomise(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 496.8224\n```\n\n\n:::\n:::\n\n\nCommon examples:\n\n- `lapply()`, `apply()`, and `tapply()` in base R\n- `purrr::map()`\n- Mathematical functionals like `integrate()` or `optim()`\n\n## Functionals are better than for loops\n\n> To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.\n>\n> --- Bjarne Stroustrup\n\n- `for` loops are too flexible. You're iterating, but why?\n- Each **functional** is tailored for a **specific task**. Conveys **intent**.\n\n## `purrr::map()` applies a function to each element of a vector\n\n`map(1:3, f) == list(f(1), f(2), f(3))`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\ntriple <- function(x) x * 3\nmap(1:3, triple)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 6\n#> \n#> [[3]]\n#> [1] 9\n```\n\n\n:::\n:::\n\n\n## Use `map_<type>()` to return an atomic vector\n\n- `map()` returns a list.\n- `map_lgl()` returns a logical vector.\n- `map_int()` returns an integer vector.\n- `map_dbl()` returns a double vector.\n- `map_chr()` returns a character vector.\n\n## Use `map_<type>()` to return an atomic vector (cont.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#> \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#>       am     gear     carb \n#> \"double\" \"double\" \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>        mpg        cyl       disp         hp       drat         wt       qsec \n#>  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n#>         vs         am       gear       carb \n#>   0.437500   0.406250   3.687500   2.812500\n```\n\n\n:::\n:::\n\n\n## Use anonymous functions for concise operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(mtcars, function(x) length(unique(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n```\n\n\n:::\n:::\n\n\n`purrr` provides `~` shortcut:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(mtcars, ~ length(unique(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n```\n\n\n:::\n:::\n\n\nR 4.1.0 provides `\\()` shortcut (`\\ == function`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(mtcars, \\(x) length(unique(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n```\n\n\n:::\n:::\n\n\n## Pass additional arguments to `map()` with `...` or via anonymous function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(x, \\(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\n## `purrr` style: pipe simple steps together\n\n- Pipe (`|>` / `%>%`) + `purrr` ➡️ readable code \n- Each line is a single, understandable step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  split(mtcars$cyl) |>\n  map(~ lm(mpg ~ wt, data = .x)) |>\n  map(coef) |>\n  map_dbl(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>         4         6         8 \n#> -5.647025 -2.780106 -2.192438\n```\n\n\n:::\n:::\n\n\n## `purrr::modify()` returns the same type as the input\n\n`map()` always returns a list:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = 6:4)\nmap(df, ~ .x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $x\n#> [1] 2 4 6\n#> \n#> $y\n#> [1] 12 10  8\n```\n\n\n:::\n:::\n\n\n`modify()` returns the same type as the input:\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify(df, ~ .x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x  y\n#> 1 2 12\n#> 2 4 10\n#> 3 6  8\n```\n\n\n:::\n:::\n\n\n## `purrr::map2()` iterates over two vectors in parallel\n\nFind a weighted mean from 2 lists: observations (`xs`) & weights (`ws`).\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- map(1:3, ~ runif(5))\nws <- map(1:3, ~ rpois(5, 5) + 1)\n```\n:::\n\n\n`map()` passes the whole `ws` list to each call:\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(xs, weighted.mean, w = ws)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `map_dbl()`:\n#> ℹ In index: 1.\n#> Caused by error in `weighted.mean.default()`:\n#> ! 'x' and 'w' must have the same length\n```\n\n\n:::\n:::\n\n\n`map2()` iterates over `xs` and `ws` in parallel:\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(xs, ws, weighted.mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.4882633 0.5066472 0.4086515\n```\n\n\n:::\n:::\n\n\n## `purrr::walk()` is for functions called for their side effects\n\n- E.g., `cat()`, `write.csv()`, `ggsave()`.\n- `walk()` returns its input invisibly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(tempdir(), paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ndir(tempdir(), pattern = \"cyl-\")\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n```\n:::\n\n\n## `purrr::imap()` iterates over values and indices\n\nNamed input == `map2(.x, names(.x), .f)`\n\n::: {.cell}\n\n```{.r .cell-code}\nimap_chr(iris[, 1:2], ~ paste0(\"The first value of '\", .y, \"' is \", .x[[1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                               Sepal.Length \n#> \"The first value of 'Sepal.Length' is 5.1\" \n#>                                Sepal.Width \n#>  \"The first value of 'Sepal.Width' is 3.5\"\n```\n\n\n:::\n:::\n\n\nUnnamed input == `map2(.x, seq_along(.x), .f)`\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- map(1:2, ~ sample(100, 5))\nimap_chr(x, ~ paste0(\"The max of element \", .y, \" is \", max(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"The max of element 1 is 67\" \"The max of element 2 is 90\"\n```\n\n\n:::\n:::\n\n\n## `purrr::pmap()` iterates over multiple arguments in a list\n\n`pmap()` applies function to list of arguments\n\n- `map2(x, y, f)` is equivalent to `pmap(list(x, y), f)`.\n- A data frame is a list, works great with `pmap()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- tibble::tribble(\n  ~n, ~min, ~max,\n  1L, 0, 1,\n  2L, 10, 100,\n)\n\npmap(params, runif)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 0.8455765\n#> \n#> [[2]]\n#> [1] 51.44240 52.67129\n```\n\n\n:::\n:::\n\n\n## `purrr::reduce()` combines vector elements with a binary function\n\n- \"Reduces\" a vector to 1 value by repeatedly applying 2-arg function\n- `reduce(1:4, f)` is equivalent to `f(f(f(1, 2), 3), 4)`.\n\nExample: Find the numbers that appear in *every* vector in a list.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nlst <- map(1:4, ~ sample(1:10, 15, replace = TRUE))\nreduce(lst, intersect)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10  5  9\n```\n\n\n:::\n:::\n\n\n## `purrr::accumulate()` shows intermediate results\n\n- Like `reduce()`, but returns all the intermediate results.\n- Great way to understand how `reduce()` works.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate(lst, intersect)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#>  [1]  3  3 10  2  6  5  4  6  9 10  5  3  9  9  9\n#> \n#> [[2]]\n#> [1]  3 10  5  4  9\n#> \n#> [[3]]\n#> [1] 10  5  9\n#> \n#> [[4]]\n#> [1] 10  5  9\n```\n\n\n:::\n:::\n\n\n## `purrr::accumulate()` is useful for cumulative calculations\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate(c(4, 3, 10), `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  4  7 17\n```\n\n\n:::\n:::\n\n\n## Predicate functionals apply a predicate to each element\n\n**Predicate:** function that returns single `TRUE` or `FALSE`.\n\n- `some()` / `every()` / `none()`: True for *any* / *all* / *no* elements?\n- `detect()` / `detect_index()`: Find *value* / *location* of 1st match.\n- `keep()` / `discard()`: *Keep* / *drop* all matching elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\nstr(keep(df, is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 'data.frame':\t3 obs. of  1 variable:\n#>  $ x: int  1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(discard(df, is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 'data.frame':\t3 obs. of  1 variable:\n#>  $ y: chr  \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n## `map_if()` and `modify_if()` transform elements where a predicate is true\n\nE.g, calculate mean of only numeric columns in a data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\")\n)\n\nstr(map_if(df, is.numeric, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 3\n#>  $ num1: num 10\n#>  $ num2: num 6\n#>  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(modify_if(df, is.numeric, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 'data.frame':\t3 obs. of  3 variables:\n#>  $ num1: num  10 10 10\n#>  $ num2: num  6 6 6\n#>  $ chr1: chr  \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n## `base::apply()` summarizes matrices and arrays\n\n- Collapses 1 or more matrix/array dimensions by applying a summary function.\n\n`apply(X, MARGIN, FUN)`: `MARGIN`? `1` for rows, `2` for columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na2d <- matrix(1:20, nrow = 5)\n# Row means\napply(a2d, 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  8.5  9.5 10.5 11.5 12.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Column means\napply(a2d, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  3  8 13 18\n```\n\n\n:::\n:::\n\n\n**Warning**: `apply()` will coerce df to a matrix!\n\n## Base R has mathematical functionals\n\nBase R includes several mathematical functionals, which are often implemented with iterative algorithms.\n\n- `integrate()`: Find the area under a curve.\n- `uniroot()`: Find where a function equals zero.\n- `optimise()`: Find the minimum or maximum value of a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintegrate(sin, 0, pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 2 with absolute error < 2.2e-14\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}