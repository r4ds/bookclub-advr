{
  "hash": "835fafc56cf1b53c63dd5fb583b7e103",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Expressions\n---\n\n# To compute on the language, we first need to understand its structure.\n\n## Learning objectives:\n\n- Capture code expressions\n- Inspect expressions\n- Define expressions\n- Modify expressions\n- Generate/Automate expressions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(lobstr)\n```\n:::\n\n\n## `expr` captures code without executing\n\n-   Distinguishes the _operation_ from the _result_\n\n::: panel-tabset\n\n### Operation\n\n-   Capture code as an __expression__\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- rlang::expr(x - 10)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> x - 10\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::is_expression(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"call\"\n```\n\n\n:::\n:::\n\n\n### Result\n\n-   Evaluate the code expression __immediately__\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x - 10\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error:\n#> ! object 'x' not found\n```\n\n\n:::\n:::\n\n\n:::\n\n## `eval` evaluates the code expression\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- rlang::expr(x - 10)\nx <- 10\neval(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n:::\n\n\n::: callout-note\nThis chapter focuses on capturing and inspecting the _operation_. `eval` will be discussed more in chapters 19 and 20.\n:::\n\n## `ast` parses and identifies the parts of an expression\n\n-   Expressions are also called abstract syntax trees (ASTs) because of the hierarchical structure and natural tree representation. \n\n::: panel-tabset\n\n### Using infix notation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(y <- x - 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─`<-` \n#> ├─y \n#> └─█─`-` \n#>   ├─x \n#>   └─10\n```\n\n\n:::\n:::\n\n\n### Using prefix notation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(`<-`(y,`*`(x,10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─`<-` \n#> ├─y \n#> └─█─`*` \n#>   ├─x \n#>   └─10\n```\n\n\n:::\n:::\n\n\n:::\n\n## The leaves, branches, and colors from `ast` identify expression data structures\n\n![](images/prefix.png)\n\n::: panel-tabset\n\n### Constants\n\n-   Also called scalars\n-   Found in `ast` leaves\n-   Leaves have black borders and sharp corners\n-   Identify with `rlang::is_syntactic_literal`\n\n### Symbols\n\n-   Found in `ast` leaves\n-   Leaves have purple borders and rounded corners\n-   Identify with `is.name` or `is.symbol`\n-   Convert strings to symbols with `rlang::sym` or `rlang::syms`\n-   Convert a symbol to a string with `rlang::as_string`  or `as.character`\n\n### Calls\n\n-   Found in `ast` branches.\n-   Branches are orange rectangles\n-   First child is the function call name\n-   Subsequent children are arguments to the function call\n-   Calls behave as lists\n-   `typeof` and `str` return \"language\" for call objects\n\n:::\n\n## Expressions and lists have similar memory mapping \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rlang::expr(y <- x * 10)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nis.list(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1d950654c40\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1d94815bff0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1d948b7b9e0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1d950654ce8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlst_x <- as.list(x)\n# Will not work: lobstr::obj_addrs(x)\nlobstr::obj_addrs(lst_x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1d94815bff0\" \"0x1d948b7b9e0\" \"0x1d950654ce8\"\n```\n\n\n:::\n:::\n\n\n## Expressions can be modified using list subsetting\n\n::: panel-tabset\n\n### Inspect\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rlang::expr(10*2)\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  language 10 * 2\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::is_expression(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\npurrr::map(as.list(x),~{.x})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> `*`\n#> \n#> [[2]]\n#> [1] 10\n#> \n#> [[3]]\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n### Modify\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"<000001D95238AD28>\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 10 * 2\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[2]] <- 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> tracemem[0x000001d95238ad28 -> 0x000001d9545baf90]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers with_options <Anonymous> process_file <Anonymous> <Anonymous> execute .main\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 4 * 2\n```\n\n\n:::\n\n```{.r .cell-code}\nuntracemem(x)\n```\n:::\n\n\n:::\n\n## Simple expressions can be generated using `call2`, `parse_expr`, or `expr_text`\n\n::: panel-tabset\n\n### `call2`\n\n-   Clunky when creating more complex expressions, see chapter 19 for more details\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::call2(\"mean\", x = rlang::expr(x), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> mean(x = x, na.rm = TRUE)\n```\n\n\n:::\n:::\n\n\n### `parse_expr`\n\n-   __parsing__: String to expression\n-   More details and safer usage in chapter 19\n-   `base::parse` (_text_ argument) is equivalent to `rlang::parse_expr`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"5 - 5\" |> \n  rlang::parse_expr()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 5 - 5\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(\"5 - \",1:10) |> \n  rlang::parse_exprs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> 5 - 1\n#> \n#> [[2]]\n#> 5 - 2\n#> \n#> [[3]]\n#> 5 - 3\n#> \n#> [[4]]\n#> 5 - 4\n#> \n#> [[5]]\n#> 5 - 5\n#> \n#> [[6]]\n#> 5 - 6\n#> \n#> [[7]]\n#> 5 - 7\n#> \n#> [[8]]\n#> 5 - 8\n#> \n#> [[9]]\n#> 5 - 9\n#> \n#> [[10]]\n#> 5 - 10\n```\n\n\n:::\n:::\n\n\n### `expr_text`\n\n-   __deparsing__: Expression to string\n-   `base::deparse` outputs a vector when spanning lines\n-   The 'questioning' lifecycle in the Help page is telling...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(y ~ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"formula\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::is_expression(y ~ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::expr_text(y ~ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"y ~ x\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrlang::expr(x - 8) |> \n  rlang::expr_text()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x - 8\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Complex expressions can be automated using `expr` and `purrr::reduce`\n\n::: panel-tabset\n\n### Generate & filters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nand_filters <- \n  purrr::map(\n    letters[6:8], #f, g, h\n    ~{\n      rlang::expr(.data[[\"x\"]] < !!.x)\n     }\n  ) |> \n    purrr::reduce(\n      .f = function(left, right) {\n        rlang::expr(!!left & !!right)\n      }\n    )\ntibble::tibble(\n  x = letters\n) |> \n  dplyr::filter(!!!and_filters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 5 × 1\n#>   x    \n#>   <chr>\n#> 1 a    \n#> 2 b    \n#> 3 c    \n#> 4 d    \n#> 5 e\n```\n\n\n:::\n:::\n\n\n### Generate | filters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nor_filters <- \n  purrr::map(\n    letters[6:8], #f, g, h\n    ~{\n      rlang::expr(.data[[\"x\"]] < !!.x)\n     }\n  ) |> \n    purrr::reduce(\n      .f = function(left, right) {\n        rlang::expr(!!left | !!right)\n      }\n    )\ntibble::tibble(\n  x = letters\n) |> \n  dplyr::filter(!!!or_filters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 7 × 1\n#>   x    \n#>   <chr>\n#> 1 a    \n#> 2 b    \n#> 3 c    \n#> 4 d    \n#> 5 e    \n#> 6 f    \n#> 7 g\n```\n\n\n:::\n:::\n\n\n:::\n\n## There are specialised data structures to be aware of but have been mostly replaced\n\n::: panel-tabset\n\n### Pairlists\n\n-   Only seen when working with calls to the function\n-   But can treat it as a regular list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- rlang::expr(function(x, y = 10) x + y)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function(x, y = 10) x + y\n```\n\n\n:::\n\n```{.r .cell-code}\nf[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> `function`\n```\n\n\n:::\n\n```{.r .cell-code}\nf[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $x\n#> \n#> \n#> $y\n#> [1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(f[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"symbol\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(f[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"pairlist\"\n```\n\n\n:::\n:::\n\n\n### Missing _arguments_\n\n-   You only need to care about the missing symbol if you’re programmatically creating functions with missing arguments\n-   Use `rlang::missing_arg()`\n-   The `...` argument is associated with an empty symbol\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- rlang::expr(function(x, y = 10) x + y)\nrlang::is_missing(\n  f[[2]][[1]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n### Expression vectors\n\n-   Only generated by `base::expression` and `base::parse`\n-   Their \"advantage\" is `base::eval` works across te elements, but this is confusing compared to evaluating across a list of expressions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex <- expression(x <- 4, x)\nclass(ex) #just one expression???\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"expression\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(ex) #so an expression can be 1 ting and more than 1 thing?? Just give me a list of expressions and define an expression as 1 thing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n:::",
    "supporting": [
      "18_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}