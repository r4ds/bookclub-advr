{
  "hash": "9cde23c6c81abc117454209426810fd5",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Rewriting R code in C++ (and Rust)\n---\n\n# _Interfaces to other software are part of R_  \n\n--- Chambers JM (2016). Extending R.\n\n## Learning objectives:\n\n-   Why rewrite R code in C++/Rust\n-   Compare C++/Rust function and package development\n-   Run C++/Rust in R\n-   Create and call C++/Rust functions in R\n-   Evaluate function performance for R/C/C++/Rust\n-   Compare compiler error messages between C++ and Rust\n-   Identify advanced tooling for C++/Rust\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\n#library(rextendr) # rust performance shown below on MacOS 16.7.3 Intel i7\n```\n:::\n\n\n## Even after optimizing R code, it still might not be optimized enough\n\n::: panel-tabset\n\n### C++\n\n-   R's for loops are much slower compared to C++\n\n    - Can't vectorize in R when loops depend on subsequent iterations\n\n-   R function calls are much slower compared to C++\n\n    - Recursive functions involving millions of function calls\n\n-   R does not include many data structures compared to C++\n\n    - C++ Standard Template Library (STL) for efficiency, correctness, and maintainability\n\n### Rust\n\n-   R cannot exploit parallelism as effectively as Rust\n\n    - Rust memory is safer (ownership model with borrow checking) and so lacks GIL or run time locks\n\n-   R object memory is borrowed via C/C++ unlike Rust\n\n    - Rust owns objects and code compiles directly to machine code\n\n-   R or C code debugging is more challenging than Rust\n\n    - Rust has no GC so lacks memory bugs and has great error messages comparable with the `{tidyverse}`\n\n:::\n\n## C++ and Rust code are used via packages and offer similar implementation approaches\n\n::: panel-tabset\n\n### C++\n\n::: panel-tabset\n\n#### `Rcpp::evalCpp`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRcpp::evalCpp('NA_INTEGER + 1')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -2147483647\n```\n\n\n:::\n:::\n\n\n#### `Rcpp::cppFunction`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRcpp::cppFunction('int add(int x, int y, int z) {\n  int sum = x + y + z;\n  return sum;\n}')\nadd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, y, z) \n#> .Call(<pointer: 0x00007fff8e1d1434>, x, y, z)\n```\n\n\n:::\n\n```{.r .cell-code}\nadd(1,2,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n:::\n\n\n#### `Rcpp::sourceCpp`\n\n```c\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble meanC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n\n  for(int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total / n;\n}\n```\n\n#### `usethis::use_rcpp`\n\n-   Creates infrastructure for using C++ within R packages\n\n:::\n\n### Rust\n\n::: panel-tabset\n\n#### `rextendr::rust_function`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function(\"fn add(a:f64, b:f64) -> f64 { a + b }\")\nadd(2.5, 4.7)\n# 7.2\n```\n:::\n\n\n#### `rextendr::rust_source`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- '\n#[extendr]\nfn main() {\n  println!(\"Hello, world!\");\n}\n'\n\nrextendr::rust_source(\n  code = code\n)\n\nmain()\n# Hello, world!\n```\n:::\n\n\n#### `rextendr::use_extendr`\n\n```r\n# create a new R package\nusethis::create_package(\"helloextendr\")\n\n# Use extendr\nrextendr::use_extendr()\n\n# Document and build the package\nrextendr::document()\n\n# run hello_world()\nhello_world()\n#> [1] \"Hello, world!\"\n```\n\n-   Newer Rust toolchain and R version is required\n-   Using VSCode/Positron is strongly recommended with `rust-analyzer` extension\n\n:::\n\n:::\n\n## Reading C++ and Rust code is similar to reading R code\n\n:::panel-tabset\n\n### Scalar functions\n\n::: panel-tabset\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignR <- function(x) {\n  if (x > 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\n```\n:::\n\n\n#### C++\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRcpp::cppFunction('int signC(double x) {\n  if (x > 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}') |> system.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    user  system elapsed \n#>    0.02    0.00    2.81\n```\n\n\n:::\n:::\n\n\n#### Rust\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function(\"\nfn signRust(x: f64) -> i32 {\n    if x > 0.0 {\n        1\n    } else if x == 0.0 {\n        0\n    } else {\n        -1\n    }\n}\n\")\n```\n:::\n\n\n:::\n\n### Vector functions\n\n::: panel-tabset\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsign\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x)  .Primitive(\"sign\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsignR <- function(x) {\n  as.integer(vapply(x,sign,double(1)))\n}\n```\n:::\n\n\n#### C++\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRcpp::cppFunction(\"\nNumericVector signC(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  for (int i = 0; i < n; i++) {\n    if (x[i] > 0.0) {\n      out[i] = 1;\n    } else if (x[i] == 0.0) {\n      out[i] = 0;\n    } else {\n      out[i] = -1;\n    }\n  }\n\n  return out;\n}\") |> system.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    user  system elapsed \n#>    0.02    0.00    2.80\n```\n\n\n:::\n\n```{.r .cell-code}\nRcpp::cppFunction(\"\nNumericVector signCfaster(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    double v = x[i];\n    out[i] = (v > 0) ? 1.0 : (v == 0 ? 0.0 : -1.0);\n  }\n\n  return out;\n\n}\") |> system.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    user  system elapsed \n#>    0.03    0.02    2.90\n```\n\n\n:::\n:::\n\n\n#### Rust\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function(\"\nfn signRust(x: Vec<f64>) -> Vec<Rint> {\n    x.into_iter()\n        .map(|v| {\n            if v > 0.0 {\n                Rint::from(1)\n            } else if v == 0.0 {\n                Rint::from(0)\n            } else {\n                Rint::from(-1)\n            }\n        })\n        .collect()\n}\n\")\n\ncode <- '\n\nuse rayon::prelude::*;\n\n#[extendr]\nfn signRustPar(x: Vec<f64>) -> Vec<Rint> {\n    x.into_par_iter()\n        .map(|v| {\n            if v > 0.0 {\n                Rint::from(1)\n            } else if v == 0.0 {\n                Rint::from(0)\n            } else {\n                Rint::from(-1)\n            }\n        })\n        .collect()\n}\n'\n\nrextendr::rust_source(\n  code = code,\n  dependencies = list(rayon = \"1\")\n)\n```\n:::\n\n\n:::\n\n:::\n\n## The C optimized `sign` is most performant, then C++ re-implementation is faster but Rust uses less memory\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- rnorm(1e7,sd = 50)\nbench::mark(\n  signR(vec),\n  sign(vec),\n  signCfaster(vec),\n  signC(vec),\n  signRustPar(vec),\n  signRust(vec),\n  relative = TRUE\n)\n## A tibble: 6 Ã— 13\n# expression         min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n# <bch:expr>       <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>      \n#1 signR(vec)       98.3   83.6       1         3.00      Inf     1    34      3.84s\n#2 sign(vec)         1      1        58.0       2.00      Inf     8     3    529.3ms\n#3 signCfaster(vec)  1.70   1.86     44.7       2.00      Inf     6     1   514.77ms\n#4 signC(vec)        3.48   2.97     26.5       2.00      Inf     4     1   578.39ms\n#5 signRustPar(vec) 10.1    8.62      9.70      1         NaN     2     0   791.64ms\n#6 signRust(vec)    12.7   13.3       6.29      1         NaN     2     0      1.22s\n```\n:::\n\n\n## Rust has more readable error messages than C++\n\n::: panel-tabset\n\n### C++\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRcpp::cppFunction(\"\nNumericVector signCfaster(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = (v > 0) ? 1.0 : (v == 0 ? 0.0 : -1.0);\n  }\n\n  return out;\n\n}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> using C++ compiler: 'G__~1.EXE (GCC) 14.2.0'\n#> \u001b[01m\u001b[Kfile64341b421e3a.cpp:\u001b[m\u001b[K In function '\u001b[01m\u001b[KRcpp::NumericVector\u001b[01;32m\u001b[K signCfaster\u001b[m\u001b[K(Rcpp::NumericVector)\u001b[m\u001b[K':\n#> \u001b[01m\u001b[Kfile64341b421e3a.cpp:12:15:\u001b[m\u001b[K \u001b[01;31m\u001b[Kerror: \u001b[m\u001b[K'\u001b[01m\u001b[Kv\u001b[m\u001b[K' was not declared in this scope\n#>    12 |     out[i] = (\u001b[01;31m\u001b[Kv\u001b[m\u001b[K > 0) ? 1.0 : (v == 0 ? 0.0 : -1.0);\n#>       |               \u001b[01;31m\u001b[K^\u001b[m\u001b[K\n#> make: *** [C:/PROGRA~1/R/R-45~1.2/etc/x64/Makeconf:296: file64341b421e3a.o] Error 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `sourceCpp()`:\n#> ! Error 1 occurred building shared library.\n```\n\n\n:::\n:::\n\n\n### Rust\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function('\nfn signRustSlice(x: Robj) -> Robj {\n    // Borrow numeric slice from R (no copy)\n    let slice = x.as_real_slice().expect(\"Expected numeric vector\");\n\n    let n = slice.len();\n    let mut out = Doubles::new(n);\n\n    // Unsafe block gives direct mutable slice (no bounds checks)\n    let out_slice = unsafe { out.as_mut_slice() };\n\n    for i in 0..n {\n        let v = slice[i];\n        out_slice[i] = if v.is_nan() {\n            f64::NAN\n        } else if v > 0.0 {\n            1.0\n        } else if v == 0.0 {\n            0.0\n        } else {\n            -1.0\n        };\n    }\n\n    out.into()\n}\n')\n```\n:::\n\n\n![](images/25_rust_error_message.png)\n\n:::\n\n## C++ and Rust have optimized and robust standard libraries\n\n::: panel-tabset\n\n### C++\n\n-   [Standard Template Library](https://learn.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=msvc-170) for complex algorithms and [data structures](https://en.cppreference.com/w/cpp/container.html)\n-   Use different headers, like `<algorithm>`, in C++ files to invoke the desired extension\n-   If functionality is not in the STL, check the [boost](https://www.boost.org/libraries/latest/grid/) library.\n\n### Rust\n\n-   [Rust Standard Library](https://doc.rust-lang.org/std/) for algorithms and data structures\n-   Primitives, modules, macros and keywords included in Rust\n-   For example, [multithreading](https://doc.rust-lang.org/std/thread/index.html) using native OS threads with their own memory:\n\n```rust\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\n:::\n## References\n\n-   Rust\n    -   [crates.io: Rust package manager](https://crates.io)\n    -   [`{cargo}` book](https://doc.rust-lang.org/cargo/)\n    -   [`{rextendr} on CRAN`](https://cran.r-project.org/web/packages/rextendr/index.html)\n    -   [extendr_api crate documentation](https://docs.rs/extendr-api/latest/extendr_api/)\n-   C++\n    -   [vcpkg C++ package manager](https://vcpkg.io/en/)\n    -   [`{Rcpp}` on CRAN](https://cran.r-project.org/web/packages/Rcpp/index.html)\n    -   [Rcpp for everyone](https://doc.rust-lang.org/cargo/)\n-   [Rust and C++ comparison gitbook](https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/)",
    "supporting": [
      "25_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}