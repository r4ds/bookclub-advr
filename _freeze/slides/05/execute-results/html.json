{
  "hash": "4832252d8573ca7203301b8e1bf043cf",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Control flow\n---\n\n## Learning objectives:\n\n- Learn the **tools** for controlling flow of execution.\n\n- Learn some technical pitfalls and (perhaps lesser known) useful features.\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![](images/whatif2.png){fig-align='left' width=518}\n:::\n:::\n\n\n::: {.cell layout-align=\"right\"}\n::: {.cell-output-display}\n![](images/forloop.png){fig-align='right' width=520}\n:::\n:::\n\n\n---\n\n## Introduction\n\nThere are two main groups of flow control tools: **choices** and **loops**: \n\n- Choices (`if`, `switch`, `ifelse`, `dplyr::if_else`, `dplyr::case_when`) allow you to run different code depending on the input. \n    \n- Loops (`for`, `while`, `repeat`) allow you to repeatedly run code \n\n\n---\n\n\n## Choices\n\n\n\n`if()` and `else`\n\nUse `if` to specify a block of code to be executed, if a specified condition is true. Use `else` to specify a block of code to be executed, if the same condition is false. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) true_action\nif (condition) true_action else false_action\n```\n:::\n\n\n(Note braces are only *needed* for compound expressions)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (test_expression) {   \n  true_action\n} else {\n  false_action\n}\n```\n:::\n\n\n\nCan be expanded to more alternatives:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (test_expression) {   \n  true_action\n} else if (other_test_expression) {\n  other_action\n} else {\n  false_action\n}\n```\n:::\n\n\n\n## Exercise {-}\nWhy does this work?\n```\nx <- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\"\n```\n\n`if` returns a value which can be assigned\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- if (TRUE) 1 else 2\nx2 <- if (FALSE) 1 else 2\n\nc(x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2\n```\n\n\n:::\n:::\n\n\nThe book recommends assigning the results of an if statement only when the entire expression fits on one line; otherwise it tends to be hard to read.\n\n\n## Single if without else {-}\n\nWhen you use the single argument form without an else statement, if invisibly (Section 6.7.2) returns NULL if the condition is FALSE. Since functions like c() and paste() drop NULL inputs, this allows for a compact expression of certain idioms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#> [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#> [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_lane_text <- function(number){\n\n  paste0(\n    number,\n    \" lane\",\n    if (number > 1) \"s\",\n    \" of sequencing\"\n  )\n}\n\nformat_lane_text(1)\n#> [1] \"1 lane of sequencing\"\nformat_lane_text(4)\n#> [1] \"4 lanes of sequencing\"\n```\n:::\n\n\n\n\n\n## Invalid inputs {-}\n\n- *Condition* must evaluate to a *single* `TRUE` or `FALSE`\n\nA single number gets coerced to a logical type. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (56) 1\n#> [1] 1\nif (0.3) 1\n#> [1] 1\nif (0) 1\n```\n:::\n\n\nIf the condition cannot evaluate to a *single* `TRUE` or `FALSE`, an error is (usually) produced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (\"text\") 1\n#> Error in if (\"text\") 1: argument is not interpretable as logical\nif (\"true\") 1 \n#> 1\nif (numeric()) 1\n#> Error in if (numeric()) 1: argument is of length zero\nif (NULL) 1\n#> Error in if (NULL) 1 : argument is of length zero\nif (NA) 1\n#> Error in if (NA) 1: missing value where TRUE/FALSE needed\n```\n:::\n\n\n\nException is a logical vector of length greater than 1, which only generates a warning, unless you have `_R_CHECK_LENGTH_1_CONDITION_` set to `TRUE`.   \nThis seems to have been the default since R-4.2.0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (c(TRUE, FALSE)) 1\n#>Error in if (c(TRUE, FALSE)) 1 : the condition has length > 1\n```\n:::\n\n\n## Vectorized choices {-}\n\n- `ifelse()` is a vectorized version of `if`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#>  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#>  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n:::\n\n\n-  `dplyr::if_else()`\n\n- Book recommends only using `ifelse()`  \"only when the yes and no vectors are the same type as it is otherwise hard to predict the output type.\" \n\n- `dplyr::if_else()` enforces this recommendation.\n\n**For example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(c(TRUE,TRUE,FALSE),\"a\",3)\n#> [1] \"a\" \"a\" \"3\"\ndplyr::if_else(c(TRUE,TRUE,FALSE),\"a\",3)\n#> Error in `dplyr::if_else()`:\n#> ! `false` must be a character vector, not a double vector.\n```\n:::\n\n \n## Switch {-}\n\nRather then string together multiple if - else if chains, you can often use `switch`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentre <- function(x, type) {\n  switch(type,\n    mean = mean(x),\n    median = median(x),\n    trimmed = mean(x, trim = .1),\n    stop(\"Invalid `type` value\")\n  )\n}\n```\n:::\n\n\nLast component should always throw an error, as unmatched inputs would otherwise invisibly return NULL.\nBook recommends to only use character inputs for `switch()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:20,50:55)\ncentre(vec, \"mean\")\n#> [1] 20.19231\ncentre(vec, \"median\")\n#> [1] 13.5\ncentre(vec, \"trimmed\")\n#> [1] 18.77273\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- rlnorm(100)\n\ncenters <- data.frame(type = c('mean', 'median', 'trimmed'))\ncenters$value = sapply(centers$type, \\(t){centre(x,t)})\n\nrequire(ggplot2)\nggplot(data = data.frame(x), aes(x))+\n  geom_density()+\n  geom_vline(data = centers, \n             mapping = aes(color = type, xintercept = value), \n             linewidth=0.5,linetype=\"dashed\") +\n  xlim(-1,10)+\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](05_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nExample from book of \"falling through\" to next value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlegs <- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4\nlegs(\"dog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 4\n```\n:::\n\n\n\n\n\n## Using `dplyr::case_when` {-}\n\n- `case_when` is a more general `if_else` and can be used often in place of multiple chained `if_else` or sapply'ing `switch`.\n\n- It uses a special syntax to allow any number of condition-vector pairs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- rlnorm(100)\n\ncenters <- data.frame(type = c('mean', 'median', 'trimmed'))\n\ncenters$value = dplyr::case_when(\n  centers$type == 'mean' ~ mean(x),\n  centers$type == 'median' ~ median(x),\n  centers$type == 'trimmed' ~ mean(x, trim = 0.1),\n  .default = 1000\n  )\n\ncenters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      type    value\n#> 1    mean 1.652545\n#> 2  median 1.063744\n#> 3 trimmed 1.300568\n```\n\n\n:::\n:::\n\n\n \n\n## Loops\n\n- Iteration over a elements of a vector\n\n`for (item in vector) perform_action`\n\n**First example**\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:5) {\n  print(1:i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n#> [1] 1 2\n#> [1] 1 2 3\n#> [1] 1 2 3 4\n#> [1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- numeric(length=5L)\ndf <- data.frame(x=1:5)\n\nfor(i in 1:5) {\n  df$y[[i]] <- i+1\n}\n```\n:::\n\n\n\n**Second example**: terminate a *for loop* earlier\n\n- `next` skips rest of current iteration\n- `break` exits the loop entirely\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i < 3) \n    next\n\n  print(i)\n  \n  if (i >= 5)\n    break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n## Exercise {-}\n\nWhen the following code is evaluated, what can you say about the vector being iterated?\n```\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n#> [1] 1 2 3 2 4 6\n```\n\n## Pitfalls {-}\n\n- Preallocate output containers to avoid *slow* code. \n\n- Beware that `1:length(v)` when `v` has length 0 results in a iterating backwards over `1:0`, probably not what is intended.  Use `seq_along(v)` instead.\n\n- When iterating over S3 vectors, use  `[[]]` yourself to avoid stripping attributes. \n\n```\nxs <- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#> [1] 18262\n#> [1] 14610\n```\nvs. \n```\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#> [1] \"2020-01-01\"\n#> [1] \"2010-01-01\"\n```\n\n## Related tools {-}\n\n- `while(condition) action`: performs action while condition is TRUE.\n- `repeat(action)`: repeats action forever (i.e. until it encounters break).\n\n- Note that `for` can be rewritten as `while` and while can be rewritten as `repeat` (this goes in one direction only!);  *however*:\n\n>Good practice is to use the least-flexible solution to a problem, so you should use `for` wherever possible.\nBUT you shouldn't even use for loops for data analysis tasks as `map()` and `apply()` already provide *less flexible* solutions to most problems. (More in Chapter 9.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\"#,\n    #stop(\"Invalid `x` value\")\n  )\n}\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\n\nwhile(i <=5 ) {\n  print(i)\n  i <- i+1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\n\nrepeat {\n  print(i)\n  i <- i+1\n  if (i > 5) break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n---\n\n\n\n\n## Meeting Videos\n\n### Cohort 1\n\n<iframe src=\"https://www.youtube.com/embed/96eY6YS_3hU\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n### Cohort 2\n\n<iframe src=\"https://www.youtube.com/embed/x5I_uHnMxIk\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n### Cohort 3\n\n<iframe src=\"https://www.youtube.com/embed/u6UMGWDuxDE\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n### Cohort 4\n\n<iframe src=\"https://www.youtube.com/embed/G4YOvwsSw2Q\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n### Cohort 5\n\n<iframe src=\"https://www.youtube.com/embed/AZwJjsl8xiI\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n### Cohort 6\n\n<iframe src=\"https://www.youtube.com/embed/wg2QZ3rMIqM\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n<details>\n<summary> Meeting chat log </summary>\n\n```\n00:16:34\tFederica Gazzelloni:\thttps://github.com/r4ds/bookclub-Advanced_R\n00:22:28\tFederica Gazzelloni:\thttps://stackoverflow.com/questions/50646133/dplyr-if-else-vs-base-r-ifelse\n00:26:20\tTrevin:\tcase_when() is great, makes it easy to read\n00:54:01\tTrevin:\tout[I, ]\n00:54:14\tTrevin:\tout[i, ]\n00:55:03\tTrevin:\tI think you have to specify number of rows and columns before..\n00:55:30\tTrevin:\titerations = 10\n variables = 2\n\n output <- matrix(ncol=variables, nrow=iterations)\n00:55:43\tTrevin:\thttps://stackoverflow.com/questions/13442461/populating-a-data-frame-in-r-in-a-loop\n```\n</details>\n\n### Cohort 7\n\n<iframe src=\"https://www.youtube.com/embed/W9CoQ15NlOc\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n<details>\n\n<summary>Meeting chat log</summary>\n```\n00:40:18\tRyan Honomichl:\tWhat type of vector does each of the following calls to ifelse() return?\n\n* \"ifelse returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is TRUE or FALSE.\"\n00:42:11\tRyan Honomichl:\t\"I recommend assigning the results of an if statement only when the entire expression fits on one line; otherwise it tends to be hard to read\"\n00:42:46\tRyan Honomichl:\t* When you use the single argument form without an `else` statement, `if` invisibly returns NULL if the condition is FALSE. \n\n-   Since functions like c() and paste() drop NULL inputs, this allows for a compact expression of certain idioms\n00:54:15\tcollinberke:\thttps://docs.google.com/spreadsheets/d/1ScrbEw_-vB9DruaJhjtVY8HLQmuNPqyWeOOjmG6OY1M/edit?usp=sharing\n00:58:46\tcollinberke:\thttps://www.youtube.com/@safe4democracy/videos\n```\n</details>\n",
    "supporting": [
      "05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}