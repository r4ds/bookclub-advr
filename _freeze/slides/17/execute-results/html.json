{
  "hash": "52606d6ad63a24e83d0169d2533eb85b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Metaprogramming intro and big picture\n---\n\n## Learning objectives:\n\n- Capture code as data using expressions\n- Inspect code as abstract syntax trees\n- Generate and execute code programmatically\n- Use data frames as execution environments\n- Recognize why quosures are useful\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(lobstr)\n```\n:::\n\n\n# Some general ideas about metaprogramming\n\n## Metaprogramming uses code as data\n\n- **Metaprogramming:** code is data that can be inspected and modified programmatically\n- Metaprogramming allow us to write `library(purrr)` instead of `library(\"purrr\")`\n\n## NSE allows us to write functions that behave differently than base R\n\n**Non-standard evaluation (NSE)** ➜ *not telling R where an object comes from?*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calling a vector\nmtcars$cyl                 # Standard\nwith(mtcars, cyl)          # Non-standard (base)\nmtcars |> dplyr::pull(cyl) # Non-standard (tidyverse)\n\n# Filtering df\nmtcars[mtcars$cyl == 6,]          # Standard\nsubset(mtcars, cyl == 6)          # Non-standard (base)\nmtcars |> dplyr::filter(cyl == 6) # Non-standard (tidyverse)\n```\n:::\n\n\n`mtcars$cyl` v/s `cyl`\n\n## NSE is a confusing term\n\n**Non-standard evaluation** is commonly used to describe the behaviour of R functions, but...\n\n- NSE is a property of the arguments, not the function\n- It’s confusing to define something by what it’s not\n\n## \"Tidy evaluation\" is the rlang version of NSE\n\n> \"Specifically, this book focuses on tidy evaluation. Tidy evaluation is implemented in the `rlang` package, and I’ll use `rlang` extensively in these chapters. This will allow you to focus on the big ideas, without being distracted by the quirks of implementation that arise from R’s history\"\n\n## Metaprogramming in R involves 7 big ideas\n\n- Code is data\n- Code is a tree\n- Code can generate code\n- Evaluation runs code\n- Can customize evaluation with functions\n- Can customize evaluation with data\n- Quosures are your new friend\n\n# Code is data\n\n## Code is captured as data in expressions\n\n- **expression:** captured code (*call*, *symbol*, *constant*, or *pairlist*)\n- Separating our description of the action from the action itself (*recipe and dish analogy?*)\n\nUse `rlang::expr()` to capture code directly\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr(mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> mean(x, na.rm = TRUE)\n```\n\n\n:::\n:::\n\n\nUse `rlang::enexpr()` to capture code indirectly\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncapture_it <- function(x) { # 'automatically quotes first argument'\n  enexpr(x)\n}\ncapture_it(a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> a + b + c\n```\n\n\n:::\n:::\n\n\n## Captured code is like a list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- expr(f(x = 1, y = 2))\nnames(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"\"  \"x\" \"y\"\n```\n\n\n:::\n\n```{.r .cell-code}\nf[[1]]  # Function name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f\n```\n\n\n:::\n\n```{.r .cell-code}\nf[[2]]  # First argument; equivalent to f$x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nf[[3]]  # Second argument; equivalent to f$y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n## Expressions can be modified like lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- expr(f(x = 1, y = 2))\n\nff <- fff <- f   # Create two copies\n\nff$z <- 3        # Add an argument to one\nfff[[2]] <- NULL # Remove an argument from another\n```\n:::\n\n\nAnd let's take a look...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f(x = 1, y = 2)\n```\n\n\n:::\n\n```{.r .cell-code}\nff\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f(x = 1, y = 2, z = 3)\n```\n\n\n:::\n\n```{.r .cell-code}\nfff\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f(y = 2)\n```\n\n\n:::\n:::\n\n\n# Code is a tree\n\n## Code is represented as a tree\n\n- **Abstract syntax tree** (AST) ➜ almost every language represents code as a tree\n- Use `lobstr::ast()` to inspect these code trees\n\n\n::: {.cell}\n\n```{.r .cell-code}\nast(f1(f2(a, b), f3(1))) # Regular (prefix) functions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─f1 \n#> ├─█─f2 \n#> │ ├─a \n#> │ └─b \n#> └─█─f3 \n#>   └─1\n```\n\n\n:::\n\n```{.r .cell-code}\nast(1 + 2 * 3) # Infix functions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─`+` \n#> ├─1 \n#> └─█─`*` \n#>   ├─2 \n#>   └─3\n```\n\n\n:::\n:::\n\n\n## ASTs can have different shapes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvct <- 1:100 # Dummy vector\n\nast(mean(x = vct)) # One argument\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─mean \n#> └─x = vct\n```\n\n\n:::\n\n```{.r .cell-code}\nast(mean(x = vct, trim = 0.1, na.rm = TRUE)) # Multiple arguments\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─mean \n#> ├─x = vct \n#> ├─trim = 0.1 \n#> └─na.rm = TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nast(round(x = mean(x = vct, trim = 0.1, na.rm = TRUE), digits = 0)) # Nested function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █─round \n#> ├─x = █─mean \n#> │     ├─x = vct \n#> │     ├─trim = 0.1 \n#> │     └─na.rm = TRUE \n#> └─digits = 0\n```\n\n\n:::\n:::\n\n\n# Code can generate code\n\n## rlang introduces ~~2~~ 3 main tools for generating code\n\n- `rlang::call2()`\n- `!!` (\"bang-bang\") - **unquote operator**\n- `{{` `}}` (\"curly-curly\") - **embrace operator** (introduced after this book was published, equivalent to `!!enquo()`)\n\n## `call2()` constructs function calls\n\n- `rlang::call2()` constructs a function call from its components ➜ the function to call, and the arguments to call it with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncall2(\"f\", 1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f(1, 2, 3)\n```\n\n\n:::\n:::\n\n\n- Going backwards from the tree, can use functions to create calls\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncall2(\"f1\", call2(\"f2\", \"a\", \"b\"), call2(\"f3\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> f1(f2(\"a\", \"b\"), f3(1))\n```\n\n\n:::\n\n```{.r .cell-code}\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 1 + 2 * 3\n```\n\n\n:::\n:::\n\n\n## `call2()` can build complex calls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvct <- 1:100 # Dummy vector\n\ncall2(\"mean\", x = vct, trim = 0.1, na.rm = TRUE) # Single function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> mean(x = 1:100, trim = 0.1, na.rm = TRUE)\n```\n\n\n:::\n\n```{.r .cell-code}\ncall2(\"round\", \n  x = call2(\"mean\", x = vct, trim = 0.1, na.rm = TRUE), \n  digits = 0\n) # Nested function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> round(x = mean(x = 1:100, trim = 0.1, na.rm = TRUE), digits = 0)\n```\n\n\n:::\n:::\n\n\n## `!!` injects expressions\n\n`!!` (\"bang-bang\") - **unquote operator**\n\n- inserts previously defined expressions into the current one\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- expr(x + x)\nyy <- expr(y + y)\nexpr(xx / yy)     # Nope!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> xx/yy\n```\n\n\n:::\n\n```{.r .cell-code}\nexpr(!!xx / !!yy) # Yup!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> (x + x)/(y + y)\n```\n\n\n:::\n:::\n\n\n## We can capture user input and generate code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv <- function(var) {\n  var <- enexpr(var)            # Get user's expression\n  expr(sd(!!var) / mean(!!var)) # Insert user's expression\n}\n\ncv(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> sd(x)/mean(x)\n```\n\n\n:::\n\n```{.r .cell-code}\ncv(x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> sd(x + y)/mean(x + y)\n```\n\n\n:::\n:::\n\n\n## Without `!!` user input is not inserted\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv2 <- function(var) {\n  var <- enexpr(var)        # Get user's expression\n  expr(sd(var) / mean(var)) # Insert user's expression\n}\n\ncv2(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> sd(var)/mean(var)\n```\n\n\n:::\n:::\n\n\nIt doesn't work.\n\n## Don't rely on pasting together code strings\n\nAvoid `paste()` for building code ➜ problems with non-syntactic names and precedence among expressions\n\n> \"You might think this is an esoteric concern, but not worrying about it when generating SQL code in web applications led to SQL injection attacks that have collectively cost billions of dollars.\"\n\n# Evaluation runs code\n\n## Evaluation runs code in an environment\n\n- **evaluate**: run/execute an expression\n- need both expression and environment\n- `eval()` uses current environment if not set\n- manual evaluation means you can tweak the environment!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy <- expr(x + y)\n\neval(xy, env(x = 1, y = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\neval(xy, env(x = 2, y = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 102\n```\n\n\n:::\n:::\n\n\n## Can customize evaluation with functions\n\n- Can also bind names to functions in supplied environment\n- Allows overriding function behaviour\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_math <- function(x) {\n  e <- env(\n    caller_env(),\n    `+` = function(x, y) paste(x, y),\n    `*` = function(x, y) strrep(x, y)\n  )\n  eval(enexpr(x), e)\n}\n\ncohort <- 10\nstring_math(\"Hello\" + \"cohort\" + cohort)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Hello cohort 10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstring_math((\"dslc\" + \"is\" + \"awesome---\") * cohort)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---\"\n```\n\n\n:::\n:::\n\n\n## Can customize evaluation with data\n\n- Look for variables inside data frame\n- [Data mask](https://rlang.r-lib.org/reference/topic-data-mask.html) - typically a data frame\n- use `rlang::eval_tidy()` rather than `eval()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 7 6 6 9\n```\n\n\n:::\n:::\n\n\n## Can customize evaluation with data in functions\n\nWe also can catch user input with `enexpr()`...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 7 6 6 9\n```\n\n\n:::\n:::\n\n\n**But there's a bug!**\n\n## Data masks can be tricky\n\n**Bug** ➜ \n\n- evaluates in environment inside `with2()`, but \n- the expression likely refers to objects in the Global environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000 # 'a' is created inside the with2() environment\n  eval_tidy(enexpr(expr), df)\n}\n\ndf <- data.frame(x = 1:3)\na <- 10 # 'a' created in the global environment\nwith2(df, x + a) # R is taking the 'a' from the function environment! \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1001 1002 1003\n```\n\n\n:::\n:::\n\n\n# Quosures bundle expression with an environment\n\n## `enquo()` creates a quosure\n\n- Bundle the environment where the expression is created\n- Use `enquo()` instead of `enexpr()` (with `eval_tidy()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enquo(expr), df)\n}\n\ndf <- data.frame(x = 1:3)\na <- 10\nwith2(df, x + a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11 12 13\n```\n\n\n:::\n:::\n\n\n## Always use `enquo()` with data masks\n\n> \"Whenever you use a data mask, you must always use `enquo()` instead of `enexpr()`\".\n\n- Quosures bundle the environment where the expression is created (i.e. the parent of where `enquo()` is called)\n\n## `enquo()` captures the calling environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eq <- enquo(expr)\n  message(\"with2() Parent/Calling environment: \")\n  print(rlang::caller_env())\n  message(\"with2() environment: \")\n  print(rlang::current_env())\n  message(\"Quosure details: \")\n  print(eq)  # Print the details of the quosure\n  eval_tidy(eq, df)\n}\n\na <- 10000\ndf <- data.frame(x = 1:3)\nwith2(df, x + a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000208278b93f0>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <quosure>\n#> expr: ^x + a\n#> env:  global\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10001 10002 10003\n```\n\n\n:::\n:::\n\n\n## Without `enquo()`, the wrong environment is captured\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun1 <- function(df) {\n  a <- 10\n  message(\"fun1() Parent/Calling environment: \")\n  print(rlang::caller_env())\n  message(\"fun1() environment: \")\n  print(rlang::current_env())\n  with2(df, x + a)\n}\n\na <- 10000\ndf <- data.frame(x = 1:3)\nfun1(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000208287b37a8>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000208287b37a8>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x00000208287a4970>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <quosure>\n#> expr: ^x + a\n#> env:  0x00000208287b37a8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11 12 13\n```\n\n\n:::\n:::\n\n\n# Summary\n\n## Big ideas of metaprogramming in R\n\n- Capture code as expressions with `rlang::expr()` and `rlang::enexpr()`.\n- Represent code as a tree with `lobstr::ast()`.\n- Create calls from function components with `rlang::call2()`.\n- Inject previously defined expressions into an expression with `!!`.\n- Evaluate expressions with `eval()` or `eval_tidy()`.\n\n## Use expressions to customize evaluation\n\n- Override common functions with evaluation environments.\n- Data masks are data frames used as evaluation environments.\n- Use **quosures** to capture both the expression and the environment in which it was created.\n- `rlang::enquo()` captures user input in a quosure.\n",
    "supporting": [
      "17_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}