{
  "hash": "41e6d59b2389ad64a630408e15f2f4e7",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Improving performance\n---\n\n## Learning Objectives\n\n0.  Determine when to optimize code\n1.  Organize code for optimization\n2.  Check for existing solutions\n3.  Create simple solutions\n4.  Vectorise code\n5.  Avoid code copying\n6.  Evaluate optimization for `t.test`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bench)\n```\n:::\n\n\n# Determine when to optimize code\n\n## Code that works, generates expected outputs, and is reproducible should be the first priority\n\n::: incremental\n-   Correct code generates a *good product* i.e. expected outputs\n-   Incorrect code generates a *bad product* i.e. incorrect outputs\n-   A good product is *more valuable* than a bad product\n-   People will use and wait for valuable products\n-   People will not use incorrect products\n-   Do not optimize code that doesn't yet generate a good product\n:::\n\n## Optimizing *correct* code should be the second priority\n\n-   Time and space constraints should set optimization goals and priorities\n-   We all strive to be efficient, whether doing something in less time or with less space\n-   But we must first prioritize to meet our various constraints\n\n# Organize code for introducing optimizations\n\n## Create functions to evaluate approaches and quantify optimization\n\n-   Goal: Modular, repeatable units of code\n-   Keep old functions that you've tried, even the failures\n-   Create examples with `{roxygen}` and tests with `{testthat}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean1 <- function(x) mean(x)\nmean2 <- function(x) sum(x) / length(x)\nx <- runif(1e5)\nbench::mark( #verifies outputs to be the same\n  mean1(x),\n  mean2(x)\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 4\n#>   expression      min   median mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm> <bch:byt>\n#> 1 mean1(x)    143.7µs  181.8µs    23.3KB\n#> 2 mean2(x)     68.9µs   86.8µs        0B\n```\n\n\n:::\n:::\n\n\n## Utilize `{usethis}` and `{devtools}` for developing and testing functions\n\n::: {layout-ncol=2}\n\n![](images/usethis_hex_logo.png){width=\"160px\" height=\"190px\" fig-align=\"center\"}\n![](images/devtools_hex_logo.png){width=\"160px\" height=\"190px\" fig-align=\"center\"}\n\n:::\n\n1. Create a project/package directory manually or with `usetihs::create_package()`\n2. Revise functions within R scripts in an R folder\n3. Use `devtools::load_all()` to load and use functions\n4. Repeat #2-4\n\n## Online resources and communities can provide existing solutions or new coding approaches\n\n-   After exhausting options at hand, online resources can provide new approaches not thought of.\n\n-   Alternatively, reframe the problem to find solutions e.g. new paradigm\n\n-   Talking to peers helps brainstorm solutions and reframe the problem\n\n-   Learning broadly improves your ability to dissect problems and develop solutions\n\n# Strategies for code optimization\n\n## Functions, arguments, and data types should factor into code optimization for the problem at hand.\n\n::: panel-tabset\n\n### Use vectorisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- matrix(1:1e6,nrow=100)\nbench::mark(\n  colMeans(X),\n  apply(X,2,function(x)sum(x) / length(x))\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 4\n#>   expression                                     min   median mem_alloc\n#>   <bch:expr>                                <bch:tm> <bch:tm> <bch:byt>\n#> 1 colMeans(X)                                559.6µs  711.7µs    99.3KB\n#> 2 apply(X, 2, function(x) sum(x)/length(x))   15.1ms   17.3ms    12.6MB\n```\n\n\n:::\n:::\n\n\n### Prespecify outputs\n\n-   Note: same speed but `vapply` allocates less memory\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- rep(list(1:1e4),1e4)\nbench::mark(\n  vapply(X,mean,numeric(1)),\n  sapply(X,mean)\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 4\n#>   expression                       min   median mem_alloc\n#>   <bch:expr>                  <bch:tm> <bch:tm> <bch:byt>\n#> 1 vapply(X, mean, numeric(1))    498ms    500ms    78.2KB\n#> 2 sapply(X, mean)                510ms    510ms   362.6KB\n```\n\n\n:::\n:::\n\n\n### Test equally versus set inclusion\n\n-   Note: `any` is faster and allocates less memory than  `%in%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- 1:1e8\nbench::mark(\n  any(X == 1450), # .Internal\n  1450 %in% X\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 4\n#>   expression          min   median mem_alloc\n#>   <bch:expr>     <bch:tm> <bch:tm> <bch:byt>\n#> 1 any(X == 1450)    262ms    291ms  762.94MB\n#> 2 1450 %in% X       446ms    459ms    1.12GB\n```\n\n\n:::\n:::\n\n\n### Avoid method dispatch\n\nNote: marginal optimization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(1e4)\n\nbench::mark(\n  mean(x),\n  mean.default(x)\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 4\n#>   expression           min   median mem_alloc\n#>   <bch:expr>      <bch:tm> <bch:tm> <bch:byt>\n#> 1 mean(x)           17.4µs   21.7µs        0B\n#> 2 mean.default(x)   14.8µs   18.8µs        0B\n```\n\n\n:::\n:::\n\n:::\n\n## Using vectorised code often leads to optimized code\n\n-   Vectorisation:\n    - Act on entire vector, not element-by-element\n    - Use an R function implemented in C\n-   Matrix algebra functions are a great example of vectorisation\n-   The help documentation can lead you to a vectorised solution\n-   Performing operations at the scale of your problem shows actual versus expected optimizations\n\n## Preallocating vectors avoids copying and improves performance\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_string <- function() {\n  paste(sample(letters, 50, replace = TRUE), collapse = \"\")\n}\nstrings10 <- replicate(10, random_string())\nstrings100 <- replicate(100, random_string())\ncollapse <- function(xs) {\n  out <- \"\"\n  for (x in xs) { out <- paste0(out, x) }\n  out\n}\nbench::mark(\n  loop10  = collapse(strings10),\n  loop100 = collapse(strings100),\n  vec10   = paste(strings10, collapse = \"\"),\n  vec100  = paste(strings100, collapse = \"\"),\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\", \"n_gc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 4 × 4\n#>   expression      min   median mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm> <bch:byt>\n#> 1 loop10       15.8µs   20.7µs    15.5KB\n#> 2 loop100     438.1µs  530.1µs   251.5KB\n#> 3 vec10           3µs    3.6µs        0B\n#> 4 vec100       16.4µs     20µs      848B\n```\n\n\n:::\n:::\n\n\n# Evaluating optimizations to `t.test`\n\n## Most data analysis projects ask to compare the means between two groups\n\n::: panel-tabset\n\n### Problem Statement\n\n-   Though better statistics exist, Student's t test is often asked for\n-   Many tests need to be performed, often in the thousands or more\n-   Speed can take precedent over safety given the dozens of projects with this problem\n-   Correctness is a key requirement\n\n### Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- 100\nn <- 1000\nX <- matrix(rnorm(m * n, mean = 10, sd = 3), nrow = m)\ngrp <- rep(1:2, each = m / 2)\n```\n:::\n\n\n:::\n\n## We can leverage our strategies to compute many t-tests\n\n::: panel-tabset\n\n### Base Case\n\n\n::: {.cell}\n\n```{.r .cell-code}\nttest_base <- function(x,groups) {\n  vec <- double()\n  for(i in 1:ncol(x)) {\n    veci <- t.test(x[groups == 1, i], x[groups == 2, i])[['statistic']]\n    vec <- c(vec,veci)\n  }\n  unname(vec)\n}\n```\n:::\n\n\n### No copying\n\n\n::: {.cell}\n\n```{.r .cell-code}\nttest_nocopy <- function(x,groups) {\n  purrr::map_dbl(\n    1:ncol(x),\n    function(i) {\n      t.test(x[groups == 1, i], x[groups == 2, i])[['statistic']]\n    }\n  )\n}\n```\n:::\n\n\n### No dispatching\n\n\n::: {.cell}\n\n```{.r .cell-code}\nttest_nodispatch <- function(x,groups) {\n  purrr::map_dbl(\n    1:ncol(x),\n    function(i) {\n      stats:::t.test.default(x[groups == 1, i], x[groups == 2, i])[['statistic']]\n    }\n  )\n}\n```\n:::\n\n\n### Matrix algebra\n\n\n::: {.cell}\n\n```{.r .cell-code}\nttest_malgebra <- function(x, groups) {\n  t_stat <- function(x) {\n    m <- mean(x); n <- length(x)\n    var <- sum((x - m) ^ 2) / (n - 1)\n    list(m = m, n = n, var = var)\n  }\n  purrr::map_dbl(\n    1:ncol(x),\n    function(i) {\n      g1 <- t_stat(x[groups == 1,i]); g2 <- t_stat(x[groups == 2,i])\n      se_total <- sqrt(g1$var / g1$n + g2$var / g2$n)\n      (g1$m - g2$m) / se_total\n    }\n  )\n}\n```\n:::\n\n\n### Vectorise\n\n\n::: {.cell}\n\n```{.r .cell-code}\nttest_vectorise <- function(x, groups) {\n  x1 <- x[groups == 1, , drop = FALSE]\n  x2 <- x[groups == 2, , drop = FALSE]\n  n1 <- nrow(x1)\n  n2 <- nrow(x2)\n  m1 <- Matrix::colMeans(x1)\n  m2 <- Matrix::colMeans(x2)\n  v1 <- Matrix::colSums(\n    (x1 - matrix(m1, n1, ncol(x), byrow = TRUE)\n  )^2) / (nrow(x1) - 1)\n  v2 <- Matrix::colSums(\n    (x2 - matrix(m2, n2, ncol(x), byrow = TRUE)\n  )^2) / (nrow(x2) - 1)\n  se_total <- sqrt(v1 / n1 + v2 / n2)\n  (m1 - m2) / se_total\n}\n```\n:::\n\n\n:::\n\n## We can identify optimal code by evaluating different t-test strategies\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  ttest_base(X,grp),\n  ttest_nocopy(X,grp),\n  ttest_nodispatch(X,grp),\n  ttest_malgebra(X,grp),\n  ttest_vectorise(X,grp)\n)[c(\"expression\", \"min\", \"median\", \"mem_alloc\", \"n_gc\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 5 × 4\n#>   expression                    min   median mem_alloc\n#>   <bch:expr>               <bch:tm> <bch:tm> <bch:byt>\n#> 1 ttest_base(X, grp)         89.9ms     93ms    13.7MB\n#> 2 ttest_nocopy(X, grp)         84ms   85.3ms    6.48MB\n#> 3 ttest_nodispatch(X, grp)   76.4ms   76.7ms    5.82MB\n#> 4 ttest_malgebra(X, grp)     10.8ms   13.6ms    4.02MB\n#> 5 ttest_vectorise(X, grp)   490.8µs    785µs   99.38MB\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "24_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}