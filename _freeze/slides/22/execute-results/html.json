{
  "hash": "b41be15ca9c067edf5bb4bbe51eff509",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Debugging\n---\n\n## Learning objectives:\n\n- Overall: Find and fix errors.\n- Locate exactly where an error occurred with the `traceback()` function.\n- Pause the execution of a function and launch an environment to interactively explore what's happening.\n- Debug non-interactively executed code.\n- Recognize other (non-error) problems that occasionally also need debugging\n\n# Strategies for finding and fixing errors\n\n| Finding your bug is a process of confirming the many things that you *believe* are true — until you find one which is *not* true.\n\n::: {style=\"text-align: right;\"}\n**—Norm Matloff** (emphasis added)\n:::\n\n| Debugging is like being the detective in a crime movie where you're also the murderer. \n\n::: {style=\"text-align: right;\"}\n**-Filipe Fortes**\n:::\n\n## Google first!\n\n- Google new error messages to help translate\n- Packages that help:\n  - [{errorist}](https://r-pkg.thecoatlessprofessor.com/errorist/)\n  - [{searcher}](https://r-pkg.thecoatlessprofessor.com/searcher/)\n  - Probably AI agents now \n\n## Repeatable bugs are more debuggable\n\n- May need to execute many times\n- Up-front investment to make a minimal [{reprex}](https://reprex.tidyverse.org/) pays off\n\n## Use the scientific method to find bugs\n\n- Generate a hypothesis.\n- Design experiments to test that hypothesis/\n- Record your results.\n\nBeing systematic often saves time in the end.\n\n## Automated tests help\n\n- Add tests for nearby working code to avoid new bugs.\n- Add tests for specific broken cases.\n- Add tests for hypotheses.\n\n# Use `traceback()` to locate the error\n\n## Example: Chained functions\n\n![](images/locating-errors.png)\n\n![](images/fa.png)\n\n## `traceback()` shows the call stack that lead to the error \n\nClick **\"Show traceback\":**:\n![](images/options.png)\n\nRead bottom to top.\n\n::: notes\n- `f()` calls `g()` calls `h()` calls `i()`\n- `rlang::global_handle()` for better traceback.\n:::\n\n##  `traceback()` is confusing with lazy evaluation\n\n![](images/lazy-evaluation.png)\n\n![](images/traceback.png)\n\n::: notes\n- `j()` isn't evaluated until it gets to `i()`.\n- I honestly don't find this example all that confusing.\n:::\n\n## `rlang::global_handle()` in `.Rprofile` makes traceback better\n\n![](images/global_handle.png)\n\n::: notes\n- `rlang::with_abort()` from book no longer exists\n- I'm now experimenting with turning this off, because it breaks \"rerun with debug\"!\n:::\n\n# Interactive debugger\n\n## RStudio has tools for debugging\n\n- Click \"Rerun with Debug\" in error message\n- Enable `Debug > On Error > Break in Code` to always jump to error\n\n## Use `browser()` to set a break point in code\n\n![](images/browser.png)\n\n## `browser()` can be conditional\n\n![](images/browser2.png)\n\n## `browser()` provides special commands\n\n![](images/debug-toolbar.png)\n\n- Next (`n`): Execute the next step\n- Step into (`s`): Dive into function (or `n`)\n- Finish (`f`): Finish execution of the current loop/function\n- Continue (`c`): Continue regular execution of the function (leave interactive) \n- Stop (`Q`): Stop debugging, terminate the function, and return to the global workspace \n\n## Set breakpoints in RStudio for virtual `browser()`\n\nActivate:\n\n- Click to left of line number, or\n- Press **Shift + F9**\n\nDownsides:\n\n- Fail in [unusual situations](https://support.posit.co/hc/en-us/articles/200534337-Breakpoint-Troubleshooting)\n- Can't be conditional\n\n## Use `options(error = recover)` for interactive debugging prompt\n\n![](images/recover.png)\n\nTurn off with `options(error = NULL)`\n\n## `debug(fn_name)` to insert `browser()` in first line of `fn_name()`\n\n- `undebug(fn_name)` to remove it\n- `debugonce(fn_name)` to do it once (similar to rerun with debug) \n- `utils::setBreakpoint(\"file_name\", line_number)`\n\n::: notes\n- Pronounce `debugonce()` [like \"Beyonce\"](https://www.youtube.com/watch?v=JThd3YYQXGg)\n:::\n\n## Call stacks printed by `traceback()`, `browser()` & `where`, and `recover()` are not consistent\n\n![](images/print-debug.png)\n\n- RStudio displays calls in the same order as `traceback()`\n- {rlang} functions use the same ordering & numbering as `recover()`\n  - Also indent to reinforce hierarchy\n\n# Non-interactive debugging\n\n## Use `callr::r()` or fresh start to look for differences\n\n`callr::r(f, list(1, 2))` calls `f(1, 2)` in a fresh session\n\n- Global env \n- Packages\n- Object\n- Working directory\n- `PATH` environment variable\n- `R_LIBS` environment variable\n\n## `dump.frames()` is the equivalent to `recover()` for non-interactive code.\n\n![](images/non-interractive-debugging.png)\n\n## Print debugging can help if nothing else works\n\n![](images/print-debugging.png)\n\n\n## Debugging Rmarkdown/Quarto has challenges\n\n- Call `rmarkdown::render(\"path/to/file.Rmd\")` instead of IDE knitting\n- Use `sink()` for tricksy error handling \n\n![](images/print-recover.png){height=\"110\"}\n\n## Functions can fail without errors\n\n- Unexpected warning: `options(warn = 2)` turns warnings into errors.\n- Unexpected message: Proposed solution in book no longer available.\n- Function might never return. Terminate & `traceback()`.\n- Crashed R = bug in compiled (C, C++, etc) code. \n\n## Some useful resources on debugging\n\n- [\"Object of type closure is not subsettable\"](https://github.com/jennybc/debugging#readme) (Jenny Bryan, `rstudio::conf(2020)`)\n- [\"What They Forgot to Teach You About R\" Chapter 12](https://rstats.wtf/debugging-r) (by Jenny Bryan and Jim Hester)\n- [Minimal reprex for a shiny app](https://www.youtube.com/watch?v=9w8ANOAlWy4) (video by Hadley)\n",
    "supporting": [
      "22_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}