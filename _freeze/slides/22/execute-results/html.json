{
  "hash": "5bd2eba9ff6d57a2e70316d04176a28e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Debugging\n---\n\n## Learning objectives:\n\n- Overall: Find and fix errors.\n- Locate exactly where an error occurred with the `traceback()` function.\n- Pause the execution of a function and launch an environment to interactively explore what's happening.\n- Debug non-interactively executed code.\n- Recognize other (non-error) problems that occasionally also need debugging.\n\n## Types of errors\n\n- Parsing errors: you are missing a closing `)`, `}` or `\"` \n  so the code AST cannot even be formed\n     * Usually captured by IDEs such as RStudio and Positron with red flashing pointers\n- Syntax errors: \n     * Parentheses are matched but one of them closes at wrong time\n     * The name of a function input is misspelled\n     * Passing more inputs to a function than it expects\n- Runtime errors: the code is syntactically correct, but it does a weird thing\n  in your actual environment with your actual data\n\n## We want to subset our closures!!!\n\nAnd then of course there's this classic:\n\n![](images/22-closure-not-subsettable.png)\n\nExplanation: `df` is a closure, in this case, the function `stats::df()`, the density of F-distribution.\n(It is not a data frame, as you thought it was, ha!)\nIt does not have elements that you could subset. \n\n# Strategies for finding and fixing errors\n\n| Finding your bug is a process of confirming the many things that you *believe* are true — until you find one which is *not* true.\n\n::: {style=\"text-align: right;\"}\n**—Norm Matloff** (emphasis added)\n:::\n\n| Debugging is like being the detective in a crime movie where you're also the murderer. \n\n::: {style=\"text-align: right;\"}\n**-Filipe Fortes**\n:::\n\n## Google first!\n\n- Google new error messages to help translate\n- Packages that help:\n  - [{errorist}](https://r-pkg.thecoatlessprofessor.com/errorist/)\n  - [{searcher}](https://r-pkg.thecoatlessprofessor.com/searcher/)\n  - Probably AI agents after 2026\n\n## Repeatable bugs are more debuggable\n\n- May need to execute many times\n- Up-front investment to make a minimal [{reprex}](https://reprex.tidyverse.org/) pays off\n\n## Use the scientific method to find bugs\n\n- Generate a hypothesis.\n- Design experiments to test that hypothesis.\n- Record your results.\n\nBeing systematic often saves time in the end.\n\n## Automated tests help\n\n- Add tests for nearby working code to avoid new bugs.\n- Add tests for specific broken cases.\n- Add tests for hypotheses.\n\nConcepts of unit tests are generally associated with R package development,\nsee [chapters on testing in \"Writing R Packages\"](https://r-pkgs.org/testing-basics.html).\n\n::: {style=\"font-size: 75%;\"}\nAutomated testing sometimes brings a dilemma: you add something to a working function, \nand the stuff that you added does work according to the new tests, but an old test gets broken. \nThis is may not be an error per se, but it shows a gap in your knowledge of \nand assumptions about the code (see Norm Matloff's quote above) \nand you have to deal with that one way or another.\n:::\n\n## Common syntax errors\n\n[Longer list here](https://computing.stat.berkeley.edu/tutorial-R-debugging/#4-some-common-causes-of-bugs)\n\n- Parenthesis mismatches\n\n- `[[...]]` vs. `[...]`\n\n- `==` vs. `=`\n\n- Comparing real numbers exactly using `==` after calculations that result in non-integers\n\n- You expect a single value but your code gives you a vector \n    * You may need `identical()` or `all()`, or form the condition more thoroughly\n\n![](images/22-cond-gt1.png)\n\n- Type coercion and dropping dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninherits(mtcars[,1], \"data.frame\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ninherits(mtcars[,1, drop=FALSE], \"data.frame\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n\n# Use `traceback()` to locate the error\n\n## Example: Chained functions\n\n![](images/locating-errors.png)\n\n![](images/fa.png)\n\n## `traceback()` shows the call stack that lead to the error \n\nClick **\"Show traceback\":**:\n![](images/options.png)\n\nRead bottom to top.\n\n::: notes\n- `f()` calls `g()` calls `h()` calls `i()`\n- `rlang::global_handle()` for better traceback.\n:::\n\n##  `traceback()` is confusing with lazy evaluation\n\n![](images/lazy-evaluation.png)\n\n![](images/traceback.png)\n\n::: notes\n- `j()` isn't evaluated until it gets to `i()`.\n- I honestly don't find this example all that confusing.\n:::\n\n## `traceback()` limits\n\nIn real world, traceback may look like [25 layers](https://stbl.wrangle.zone/dev/reference/expect_pkg_error_classes.html)\n\n- Your code is the first 2-3 layers.\n- The last 5 layers are very clearly formatting the error and making a safe return of appropriate objects.\n- The middle 15 layers are classes and methods of `dplyr`, `rlang`, `purrr` and `base` \n  and maybe packages you have never heard of,\n  passing very opaque things to one another, \n  your informatively named objects are abstracted somewhere\n  in `...`, `.x` and `envir`...\n- ... and you are still left wondering what's going on.\n\n## `rlang::global_handle()` in `.Rprofile` makes traceback better\n\n![](images/global_handle.png)\n\n::: notes\n- `rlang::with_abort()` from book no longer exists\n- I'm now experimenting with turning this off, because it breaks \"rerun with debug\"!\n:::\n\n# Interactive debugger\n\n## RStudio has tools for debugging\n\n- Click \"Rerun with Debug\" in error message\n- Enable `Debug > On Error > Break in Code` to always jump to error\n\n## Use `browser()` to set a break point in code\n\n![](images/browser.png)\n\n## `browser()` can be conditional\n\n![](images/browser2.png)\n\nA better practice would be to define your own debugging flags \nthat would be turned off or disappear in production code\n\n```\nif (exists(\"my_debugging_flag\")) browser()\n```\n\n## `browser()` provides special commands\n\nThese commands work in the Console; RStudio also makes the toolbar buttons available.\n\n![](images/debug-toolbar.png)\n\n- Next (`n`): Execute the next step\n- Step into (`s`): Dive into function (or `n`)\n- Finish (`f`): Finish execution of the current loop/function\n- Continue (`c`): Continue regular execution of the function (leave interactive) \n- Stop (`Q`): Stop debugging, terminate the function, and return to the global workspace \n\n## `browser()` practical tips\n\n- RStudio runs its best attempt to show the code that is being executed in the \"Source\" pane\n    * parsed AST for external functions (no comments, no indents);\n    * actual source files within your packages when you are in the package project.\n- That means you can select the code and `Ctrl+Enter` to execute it\n    * if in doubt about the source of the error, do that rather than hitting `n` \"Next\"\n    * especially if the computations leading to this point in your code are costly in terms of time\n    \n\n## Set breakpoints in RStudio for virtual `browser()`\n\nActivate:\n\n- Click to left of line number, or\n- Press **Shift + F9**\n\nDownsides:\n\n- Fail in [unusual situations](https://support.posit.co/hc/en-us/articles/200534337-Breakpoint-Troubleshooting)\n- Can't be conditional\n\n## Use `options(error = recover)` for interactive debugging prompt\n\n![](images/recover.png)\n\nTurn off with `options(error = NULL)`\n\n## `debug(fn_name)` to insert `browser()` in first line of `fn_name()`\n\n- `undebug(fn_name)` to remove it\n- `debugonce(fn_name)` to do it once (similar to rerun with debug) \n- `utils::setBreakpoint(\"file_name\", line_number)`\n\n::: notes\n- Pronounce `debugonce()` [like \"Beyonce\"](https://www.youtube.com/watch?v=JThd3YYQXGg)\n:::\n\n## Call stacks printed by `traceback()`, `browser()` & `where`, and `recover()` are not consistent\n\n![](images/print-debug.png)\n\n- RStudio displays calls in the same order as `traceback()`\n- {rlang} functions use the same ordering & numbering as `recover()`\n  - Also indent to reinforce hierarchy\n\n# Non-interactive debugging\n\n## Use `callr::r()` or fresh start to look for differences\n\n`callr::r(f, list(1, 2))` calls `f(1, 2)` in a fresh session\n\n- Global env \n- Packages\n- Object\n- Working directory\n- `PATH` environment variable\n- `R_LIBS` environment variable\n\n## `dump.frames()` is the equivalent to `recover()` for non-interactive code.\n\n![](images/non-interractive-debugging.png)\n\n## Print debugging can help if nothing else works\n\n![](images/print-debugging.png)\n\n## Debugging withing packages\n\nRecall [Chapter 8](08.html) on classed conditions:\n\n- you can create richer structured objects with \n\n```\nrlang::abort(\n  message = \"cli-formatted-message\",\n  class   = \"your-special-class-to-distinguish-from-other-errors\",\n  ...\n)\n```\n\n- you can pass your situation report in `...` so that error handlers\n  and/or reporters can more effectively peek into your environment that errored\n- you can capture the class with `testthat::expect_s3_class()`\n\n## Debugging Rmarkdown/Quarto has challenges\n\n- Call `rmarkdown::render(\"path/to/file.Rmd\")` instead of IDE knitting.\n    * downside: the content of your current environment propagates into the markdown code\n- Use `sink()` for tricksy error handling \n\n![](images/print-recover.png){height=\"110\"}\n\nSee also [\"Markdown test drive\"](https://happygitwithr.com/rmd-test-drive.html?q=knit_exit#rmd-troubleshooting)\nin Jenny Bryan's _Happy Git With R_ book.\n\n## Functions can fail without errors\n\n- Unexpected warning: `options(warn = 2)` turns warnings into errors.\n- Unexpected message: Proposed solution in book no longer available.\n- Function might never return. Terminate & `traceback()`.\n- Crashed R = bug in compiled (C, C++, etc) code. \n\n## Some useful resources on debugging\n\n- [\"Object of type closure is not subsettable\"](https://github.com/jennybc/debugging#readme) (Jenny Bryan, `rstudio::conf(2020)`)\n- [\"What They Forgot to Teach You About R\" Chapter 12](https://rstats.wtf/debugging-r) (by Jenny Bryan and Jim Hester)\n- [Minimal reprex for a shiny app](https://www.youtube.com/watch?v=9w8ANOAlWy4) (video by Hadley)\n- [Debugging in RStudio, by Posit](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE)\n\n\n- If you have access to \"Code Complete\", it provides \n  [generic debugging principles](https://www.oreilly.com/library/view/code-complete-2nd/0735619670/ch08.html)\n  that are meant to be applicable across programming languages\n",
    "supporting": [
      "22_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}