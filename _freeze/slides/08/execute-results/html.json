{
  "hash": "db3b3b31b373c5957ea404efa4d36a33",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Conditions\n---\n\n## Learning objectives\n\n- What conditions are\n- How to generate (\"signal\") them\n- How to consume (\"handle\") them\n\n## R's condition system allows us to handle things going wrong\n\nAn error might occur due to events outside of your program---a missing file, a\nfull disk, a crashed server, etc.\n\n\"Errors aren't caused by bugs, but neglecting to handle an error is almost\ncertainly a bug.\" ---Seibel (2003)\n\nConditions help us maintain the illusion of \"black box\" functions.\n\n## There are three types of conditions\n\n1. ‚ùå Errors\n2. ‚ö†Ô∏è Warnings\n3. üí¨ Messages\n\nFunction authors _signal_ conditions\n\nFunction users _handle_ conditions\n\n# Signaling conditions\n\n## Errors indicate that a problem occurred and the function cannot continue\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() {\n  cat(\"starting f()\\n\")\n  g()\n  cat(\"finishing f()\\n\")\n}\n\ng <- function() {\n  cat(\"starting g()\\n\")\n  stop(\"This is an error!\")\n  cat(\"finishing g()\\n\")\n}\n\nf()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> starting f()\n#> starting g()\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in g(): This is an error!\n```\n\n\n:::\n:::\n\n\n::: {.notes}\nErrors halt execution immediately\n\nBy default the function that raised the error is prepended to the message\n:::\n\n## Pass objects to `stop()` to print error messages\n\n- `stop(...)` can accept zero or more objects\n  - If the first object is not a condition object[^objs], its arguments are\n    converted to `character` and pasted together with no separator\n\n- Pass `call. = FALSE` to prevent the function that raised the error from being\n  added to the message\n\n- `rlang::abort()` signals errors with a different interface\n\n[^objs]: _Condition objects_ will be described later\n\n## Tracebacks display the call stack at the time of the last error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf()\ntraceback()\n```\n:::\n\n\n    #> 4: stop(\"This is an error!\") at #2\n    #> 2: g() at #3\n    #> 1: f()\n\nThis is one reason to prefer `stop(..., call. = FALSE)`\n\n## `rlang::last_trace()` has prettier printing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf()\nrlang::last_trace()\n```\n:::\n\n\n    #> <error/rlang_error>\n    #> Error in `g()`:\n    #> ! This is an error!\n    #> ---\n    #> Backtrace:\n    #>     ‚ñÜ\n    #>  1. ‚îî‚îÄglobal f()\n    #>  2.   ‚îî‚îÄglobal g()\n    #> Run rlang::last_trace(drop = FALSE) to see 1 hidden frame.\n\n## Warnings indicate that a problem occurred but the function can continue\n\n<!---\nI'm using eval = false and embedding the output myself because Quarto displays\nwarnings immediately unlike the R console (with `options(warn = 0)`)\n-->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() {\n  warning(\"F1\")\n  g()\n  warning(\"F2\")\n  cat(\"finishing f()\\n\")\n}\n\ng <- function() {\n  warning(\"G1\")\n  cat(\"finishing g()\\n\")\n}\n\nf()\n```\n:::\n\n\n    #> finishing g()\n    #> finishing f()\n    #> Warning messages:\n    #> 1: In f() : F1\n    #> 2: In g() : G1\n    #> 3: In f() : F2\n\n::: {.notes}\nBy default warnings are cached and printed when control returns to the top\nlevel, as shown here (use `options(warn = 0)` to get this behavior)\n\nWarnings can appear immediately with `options(warn = 1)`\n\nWarnings can turn into errors with `options(warn = 2)`, which is ideal for\ndebugging\n:::\n\n## Use warnings sparingly\n\n- Ideal for deprecating functions\n- Good when \"you are reasonably certain\" that a problem is recoverable\n- \"Base R tends to overuse warnings, and many warnings in base R would be\n  better off as errors\"\n\n::: aside\n`warning()` has similar arguments to `stop()`\n\n`call. = TRUE` is generally more useful with `warning()` than `stop()`\n\n`rlang::warn()` is an alternative (cf. `rlang::abort()`)\n:::\n\n## Messages indicate that something noteworthy has happened\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() {\n  message(\"F1\")\n  g()\n  message(\"F2\")\n  cat(\"finishing f()\\n\")\n}\n\ng <- function() {\n  message(\"G1\")\n  cat(\"finishing g()\\n\")\n}\n\nf()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> F1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> G1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> finishing g()\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> F2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> finishing f()\n```\n\n\n:::\n:::\n\n\n## Recommended uses for messages\n\n- Explaining default arguments\n- Status updates of functions used primarily for side-effects\n  - Interaction with web API, file downloaded, etc.\n- Progress of long-running process\n  - But see `utils::txtProgressBar()` and others\n- Package loading message (e.g., attaching package, objects masked)\n\n::: aside\nSee `rlang::inform()` for an alternative interface\n:::\n\n# Handling conditions\n\n## Ignore errors with `try()`\n\n::: {.notes}\n- Displays error\n- But continues execution after error\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_log <- function(x) {\n  try(log(x))\n  10\n}\n\nbad_log(\"bad\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in log(x) : non-numeric argument to mathematical function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10\n```\n\n\n:::\n:::\n\n\n## `try()` with assignment can support default values in case of failure\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_contents <- NULL\ntry(file_contents <- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\nis.null(file_contents)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n## Warnings and messages can be independently suppressed\n\n<!---\nI'm turning off evaluation and manually pasting the results again because I\nwant to make the formatting match\n-->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchatty_function <- function() {\n  warning(\"warning 1\")\n  message(\"message 1\")\n  warning(\"warning 2\")\n  message(\"message 2\")\n  42\n}\n\nsuppressWarnings(chatty_function())\n```\n:::\n\n\n    #> message 1\n    #> message 2\n    #> [1] 42\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(chatty_function())\n```\n:::\n\n\n    #> [1] 42\n    #> Warning messages:\n    #> 1: In chatty_function() : warning 1\n    #> 2: In chatty_function() : warning 2\n\n## Every condition has a default behavior\n\n- ‚ùå Errors halt execution\n- ‚ö†Ô∏è Warnings are collected during execution and\n  displayed in bulk after execution\n- üí¨ Messages are displayed immediately\n\nThese can be changed through _exiting_ and _calling_ handlers\n\n## `tryCatch()` specifies or modifies exiting handlers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp_log <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    {\n      y <- log(x)\n      cat(\"Reconstituting 'x'\\n\")\n      exp(y)\n    }\n  )\n}\n\nexp_log(23)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Reconstituting 'x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 23\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp_log(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA\n```\n\n\n:::\n:::\n\n\n::: {.notes}\nNotice that, unlike with `try()`, the function still stops  \n(the next slide has more detail)\n:::\n\n## Exiting handlers never return control to the original code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  message = function(cnd) {\n    cat(\"Caught a message condition:\", conditionMessage(cnd))\n    \"The return value of the message handler\"\n  },\n  {\n    message(\"This is a message\")\n    cat(\"This code won't be run inside 'tryCatch()' if messages are caught\\n\")\n    \"The return value of the original expression\"\n  },\n  finally = {\n    cat(\"The code in 'finally' is always run\\n\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Caught a message condition: This is a message\n#> The code in 'finally' is always run\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"The return value of the message handler\"\n```\n\n\n:::\n:::\n\n\n::: {.notes}\nThis snippet illustrates a few things about `tryCatch()`:\n- exiting handlers can be established for exceptions other than errors\n- The use of `finally`\n- And, like it says in the title, the original code exits and doesn't resume\n:::\n\n## `withCallingHandlers()` specifies or modifies calling handlers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Caught a message condition:\", conditionMessage(cnd))\n    \"The return value of the message handler is ignored\"\n  },\n  {\n    message(\"This is a message\")\n    cat(\"This code should run\\n\")\n    message(\"This is another message\")\n    \"The return value of the original expression\"\n  }\n  # No finally option\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Caught a message condition: This is a message\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> This code should run\n#> Caught a message condition: This is another message\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"The return value of the original expression\"\n```\n\n\n:::\n:::\n\n\n## Conditions \"bubble up\" to other calling handlers by default\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    {\n      message(\"Hello\")\n      cat(\"Finishing code block\\n\")\n    }\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Level 1\n#> Level 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Finishing code block\n```\n\n\n:::\n:::\n\n\n## Conditions also bubble up to `tryCatch()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    {\n      message(\"Hello\")\n      cat(\"This exiting handler prevents this from running\\n\")\n    }\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Level 1\n#> Level 2\n```\n\n\n:::\n:::\n\n\n## `rlang::cnd_muffle()` will stop the propagation to calling handlers \"higher up\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      rlang::cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Level 1\n```\n\n\n:::\n:::\n\n\n## Calling handlers are called in the context of the call that signaled the condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() g()\ng <- function() message(\"hello\")\n\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  rlang::cnd_muffle(cnd)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      ‚ñÜ\n#>   1. ‚îú‚îÄbase::withCallingHandlers(...)\n#>   2. ‚îú‚îÄglobal f()\n#>   3. ‚îÇ ‚îî‚îÄglobal g()\n#>   4. ‚îÇ   ‚îî‚îÄbase::message(\"hello\")\n#>   5. ‚îÇ     ‚îú‚îÄbase::withRestarts(...)\n#>   6. ‚îÇ     ‚îÇ ‚îî‚îÄbase (local) withOneRestart(expr, restarts[[1L]])\n#>   7. ‚îÇ     ‚îÇ   ‚îî‚îÄbase (local) doWithOneRestart(return(expr), restart)\n#>   8. ‚îÇ     ‚îî‚îÄbase::signalCondition(cond)\n#>   9. ‚îî‚îÄglobal `<fn>`(`<smplMssg>`)\n#>  10.   ‚îî‚îÄlobstr::cst()\n```\n\n\n:::\n:::\n\n\n## Exiting handlers are called in the context of the call to `tryCatch()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(f(), message = function(cnd) lobstr::cst())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     ‚ñÜ\n#>  1. ‚îî‚îÄbase::tryCatch(f(), message = function(cnd) lobstr::cst())\n#>  2.   ‚îî‚îÄbase (local) tryCatchList(expr, classes, parentenv, handlers)\n#>  3.     ‚îî‚îÄbase (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#>  4.       ‚îî‚îÄvalue[[3L]](cond)\n#>  5.         ‚îî‚îÄlobstr::cst()\n```\n\n\n:::\n:::\n\n\n# Condition objects\n\n## Built-in conditions are lists with two elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncnd <- rlang::catch_cnd(stop(\"An error!\"))\nstr(cnd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 2\n#>  $ message: chr \"An error!\"\n#>  $ call   : language force(expr)\n#>  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n\n\n:::\n:::\n\n\n- `message` can be accessed with `conditionMessage(cnd)`\n- `call` is not generally useful\n- The `class` attribute will be explained alongside S3\n\n## Custom conditions can introduce additional attributes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncnd <- rlang::catch_cnd(rlang::abort(\"An error!\"))\nstr(cnd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 5\n#>  $ message: chr \"An error!\"\n#>  $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame':\t8 obs. of  6 variables:\n#>   ..$ call       :List of 8\n#>   .. ..$ : language rlang::catch_cnd(rlang::abort(\"An error!\"))\n#>   .. ..$ : language eval_bare(rlang::expr(tryCatch(!!!handlers, {     force(expr) ...\n#>   .. ..$ : language tryCatch(condition = `<fn>`, {     force(expr) ...\n#>   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)\n#>   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#>   .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)\n#>   .. ..$ : language force(expr)\n#>   .. ..$ : language rlang::abort(\"An error!\")\n#>   ..$ parent     : int [1:8] 0 1 1 3 4 5 1 0\n#>   ..$ visible    : logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#>   ..$ namespace  : chr [1:8] \"rlang\" \"rlang\" \"base\" \"base\" ...\n#>   ..$ scope      : chr [1:8] \"::\" \"::\" \"::\" \"local\" ...\n#>   ..$ error_frame: logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#>   ..- attr(*, \"version\")= int 2\n#>  $ parent : NULL\n#>  $ rlang  :List of 1\n#>   ..$ inherit: logi TRUE\n#>  $ call   : NULL\n#>  - attr(*, \"class\")= chr [1:3] \"rlang_error\" \"error\" \"condition\"\n```\n\n\n:::\n:::\n\n\n## `rlang::abort()` can compose and throw custom conditions\n\nWe create a function that will signal an error condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabort_missing_file <- function(file_path) {\n  rlang::abort(\n    \"error_not_found\",\n    message = glue::glue(\"Path `{file_path}` not found\"),\n    path = file_path\n  )\n}\nabort_missing_file(\"blah.csv\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in `abort_missing_file()`:\n#> ! Path `blah.csv` not found\n```\n\n\n:::\n:::\n\n\nThis makes it easy to format messages\n\n::: aside\n`rlang::abort()` doesn't format messages like `stop()` does\n:::\n\n## Deal with custom conditions by creating specific handlers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_csv_reader <- function(file) {\n  if (!file.exists(file)) abort_missing_file(file)\n  read.csv(file)\n}\n\ndat <- tryCatch(\n  error_not_found = function(cnd) data.frame(),\n  error = function(cnd) NULL,\n  my_csv_reader(\"blah.csv\")\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> data frame with 0 columns and 0 rows\n```\n\n\n:::\n:::\n\n\n::: aside\nThe first matching handler is chosen, not the \"most specific\"\n:::\n\n::: {.notes}\nIf we were writing all of the code ourselves, we'd probably put this behavior\nin `my_csv_reader()` ourselves.\n\nCustom conditions' strength relates to the principle of \"separation of\nconcerns\": the decision about what constitutes an error belongs to the function\nauthor, and the decision of how to handle an error belongs to the function\nuser. This is especially useful for authors and users of packages.\n:::\n\n## Applications\n\nSee [the sub-section in the\nbook](https://adv-r.hadley.nz/conditions.html#condition-applications) for\nmore excellent examples.\n\n## Resources\n\n- Conditions articles in rlang vignettes: \n  - [Including function calls in error\n    messages](https://rlang.r-lib.org/reference/topic-error-call.html)\n  - [Including contextual information with error\n    chains](https://rlang.r-lib.org/reference/topic-error-chaining.html)\n  - [Formatting messages with\n    cli](https://rlang.r-lib.org/reference/topic-condition-formatting.html)\n- [Other\n  resources](https://github.com/rstudio-conf-2022/pkg-dev-masterclass/blob/main/materials/5-error-resources.md)\nfrom error message segment of rstudio::conf(2022) workshop \"Package Development\nMasterclass\"\n  - [Error messages](https://style.tidyverse.org/errors.html) from the\n    Tidyverse style guide\n",
    "supporting": [
      "08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}