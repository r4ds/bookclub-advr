[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "This is a companion for Advanced R by Hadley Wickham (Chapman & Hall, copyright 2019, 9780815384571).\nEach chapter title to the left is a link to a slide deck.\n\nThese slides are being developed by this club.\nEach deck will open in its own tab.\nYou may want to type ‚Äús‚Äù at the start of each deck to open the speaker notes.\nJoin the Data Science Learning Community to participate in the discussion!\n\nWe follow the Data Science Learning Community Code of Conduct.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "24.html",
    "href": "24.html",
    "title": "24. Improving performance",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Techniques",
      "24. Improving performance"
    ]
  },
  {
    "objectID": "24.html#meeting-videos",
    "href": "24.html#meeting-videos",
    "title": "24. Improving performance",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Techniques",
      "24. Improving performance"
    ]
  },
  {
    "objectID": "22.html",
    "href": "22.html",
    "title": "22. Debugging",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Techniques",
      "22. Debugging"
    ]
  },
  {
    "objectID": "22.html#meeting-videos",
    "href": "22.html#meeting-videos",
    "title": "22. Debugging",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Techniques",
      "22. Debugging"
    ]
  },
  {
    "objectID": "20.html",
    "href": "20.html",
    "title": "20. Evaluation",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Metaprogramming",
      "20. Evaluation"
    ]
  },
  {
    "objectID": "20.html#meeting-videos",
    "href": "20.html#meeting-videos",
    "title": "20. Evaluation",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Metaprogramming",
      "20. Evaluation"
    ]
  },
  {
    "objectID": "18.html",
    "href": "18.html",
    "title": "18. Expressions",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Metaprogramming",
      "18. Expressions"
    ]
  },
  {
    "objectID": "18.html#meeting-videos",
    "href": "18.html#meeting-videos",
    "title": "18. Expressions",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Metaprogramming",
      "18. Expressions"
    ]
  },
  {
    "objectID": "16.html",
    "href": "16.html",
    "title": "16. OOP Trade-offs",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Object-oriented programming",
      "16. OOP Trade-offs"
    ]
  },
  {
    "objectID": "16.html#meeting-videos",
    "href": "16.html#meeting-videos",
    "title": "16. OOP Trade-offs",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Object-oriented programming",
      "16. OOP Trade-offs"
    ]
  },
  {
    "objectID": "14.html",
    "href": "14.html",
    "title": "14. R6",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Object-oriented programming",
      "14. R6"
    ]
  },
  {
    "objectID": "14.html#meeting-videos",
    "href": "14.html#meeting-videos",
    "title": "14. R6",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Object-oriented programming",
      "14. R6"
    ]
  },
  {
    "objectID": "12.html",
    "href": "12.html",
    "title": "12. OOP Introduction & Base types",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Object-oriented programming",
      "12. OOP Introduction & Base types"
    ]
  },
  {
    "objectID": "12.html#meeting-videos",
    "href": "12.html#meeting-videos",
    "title": "12. OOP Introduction & Base types",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Object-oriented programming",
      "12. OOP Introduction & Base types"
    ]
  },
  {
    "objectID": "10.html",
    "href": "10.html",
    "title": "10. Function factories",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Functional programming",
      "10. Function factories"
    ]
  },
  {
    "objectID": "10.html#meeting-videos",
    "href": "10.html#meeting-videos",
    "title": "10. Function factories",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Functional programming",
      "10. Function factories"
    ]
  },
  {
    "objectID": "08.html",
    "href": "08.html",
    "title": "8. Conditions",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "8. Conditions"
    ]
  },
  {
    "objectID": "08.html#meeting-videos",
    "href": "08.html#meeting-videos",
    "title": "8. Conditions",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "8. Conditions"
    ]
  },
  {
    "objectID": "06.html",
    "href": "06.html",
    "title": "6. Functions",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "6. Functions"
    ]
  },
  {
    "objectID": "06.html#meeting-videos",
    "href": "06.html#meeting-videos",
    "title": "6. Functions",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "6. Functions"
    ]
  },
  {
    "objectID": "04.html",
    "href": "04.html",
    "title": "4. Subsetting",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "4. Subsetting"
    ]
  },
  {
    "objectID": "04.html#meeting-videos",
    "href": "04.html#meeting-videos",
    "title": "4. Subsetting",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "4. Subsetting"
    ]
  },
  {
    "objectID": "02.html",
    "href": "02.html",
    "title": "2. Names and values",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "2. Names and values"
    ]
  },
  {
    "objectID": "02.html#meeting-videos",
    "href": "02.html#meeting-videos",
    "title": "2. Names and values",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "2. Names and values"
    ]
  },
  {
    "objectID": "videos/25/06.html",
    "href": "videos/25/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:10:13    Arthur Shaw:    Did things freeze for anyone else?\n00:55:40    Federica Gazzelloni:    https://en.cppreference.com/w/cpp/container\n00:57:44    Federica Gazzelloni:    https://dirk.eddelbuettel.com/blog/2011/07/14/\n01:07:33    Trevin: I don‚Äôt have experience\n01:07:54    Oluwafemi Oyedele:  Same here!!!\n01:11:57    Arthur Shaw:    Does anyone know any packages that use C++? The one that comes to mind for me is haven, which uses a C++ library\n01:12:30    Trevin: When I was looking, one that stood out to me was rstan\n01:13:02    Arthur Shaw:    Reacted to \"When I was looking, ...\" with üëç"
  },
  {
    "objectID": "videos/24/07.html",
    "href": "videos/24/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:23:48    Ron Legere: https://www.mathworks.com/help/matlab/matlab_prog/vectorization.html"
  },
  {
    "objectID": "videos/23/01.html",
    "href": "videos/23/01.html",
    "title": "Cohort 1",
    "section": "",
    "text": "(no video)"
  },
  {
    "objectID": "videos/21/06.html",
    "href": "videos/21/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:30:16    Arthur Shaw:    https://www.w3schools.com/html/html_entities.asp\n00:32:29    Arthur Shaw:    Beta symbol in HTML: &Beta;\n00:56:55    Arthur Shaw:    https://dbplyr.tidyverse.org/articles/translation-function.html\n00:57:48    Arthur Shaw:    https://dtplyr.tidyverse.org/index.html\n00:58:43    Arthur Shaw:    https://dtplyr.tidyverse.org/articles/translation.html"
  },
  {
    "objectID": "videos/20/06.html",
    "href": "videos/20/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n01:00:42    Trevin: They just want to help you present that‚Äôs all"
  },
  {
    "objectID": "videos/19/07.html",
    "href": "videos/19/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:50:48    Stone:  https://www.r-bloggers.com/2018/10/quasiquotation-in-r-via-bquote/\n00:58:26    iPhone: See ya next week!\n\n\n\nMeeting chat log\n\n00:55:22    collinberke:    https://rlang.r-lib.org/reference/embrace-operator.html?q=enquo#under-the-hood"
  },
  {
    "objectID": "videos/17/07.html",
    "href": "videos/17/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:11:09    Ryan Honomichl: https://medium.com/analytics-vidhya/become-a-better-r-programmer-with-the-awesome-lobstr-package-af97fcd22602\n00:33:03    Ryan Honomichl: https://rlang.r-lib.org/reference/enquo.html\n00:37:30    Ryan Honomichl: https://rlang.r-lib.org/reference/topic-multiple-columns.html\n00:41:00    Ryan Honomichl: brb\n00:44:37    Ron Legere: https://www.rdocumentation.org/packages/srvyr/versions/1.2.0\n00:44:58    Ron Legere: http://gdfe.co/srvyr/\n00:51:51    Stone:  https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html"
  },
  {
    "objectID": "videos/16/06.html",
    "href": "videos/16/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:11:36    Oluwafemi Oyedele:  I have not built anything with them!!!\n00:16:31    Arthur Shaw:    https://cran.r-project.org/web/packages/sp/index.html\n00:19:05    Arthur Shaw:    Apparently Hadley asked the same question we're asking several years ago: https://stackoverflow.com/questions/5437238/which-packages-make-good-use-of-s4-objects\n00:19:16    Trevin: HA\n00:23:54    Trevin: Your audio is breaking up Federica\n01:06:58    Federica Gazzelloni:    https://mastering-shiny.org/reactive-motivation.html?q=R6#event-driven\n01:07:37    Federica Gazzelloni:    https://engineering-shiny.org/common-app-caveats.html?q=R6#using-r6-as-data-storage\n01:10:52    Oluwafemi Oyedele:  Thank you !!!"
  },
  {
    "objectID": "videos/15/07.html",
    "href": "videos/15/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n01:09:37    Ron Legere: https://en.wikipedia.org/wiki/Composition_over_inheritance"
  },
  {
    "objectID": "videos/14/06.html",
    "href": "videos/14/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:11:34    Trevin: https://engineering-shiny.org/common-app-caveats.html?q=R6#using-r6-as-data-storage\n00:39:36    Federica Gazzelloni:    new R7: https://rconsortium.github.io/OOP-WG/\n00:40:04    Federica Gazzelloni:    R7 designed to be a successor to S3 and S4\n00:40:40    Federica Gazzelloni:    R6: https://r6.r-lib.org/articles/Introduction.html\n00:52:44    Trevin: https://advanced-r-solutions.rbind.io/r6.html#controlling-access\n01:00:34    Federica Gazzelloni:    interesting: https://r-craft.org/r-news/object-oriented-programming-oop-in-r-with-r6-the-complete-guide/\n01:01:58    Trevin: https://hadley.shinyapps.io/cran-downloads/\n01:02:33    Oluwafemi Oyedele:  Thank you !!!"
  },
  {
    "objectID": "videos/12/06.html",
    "href": "videos/12/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:35:02    Trevin: sloop (‚Äúsail the seas of OOP‚Äù)\n00:42:40    Ryan Metcalf:   Awesome input Trevin! I jumped to the vignette, but didn't see the reference directly.\n01:00:01    Trevin: If you're interested there may be a new ‚ÄúR Packages\" cohort starting up soon (also a new version of the book coming out soonish as well?)\n01:08:23    Oluwafemi Oyedele:  Thank you !!!"
  },
  {
    "objectID": "videos/11/07.html",
    "href": "videos/11/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:18:21    collinberke: Jenny Bryan debugging: https://www.youtube.com/watch?v=vgYS-F8opgE\n00:31:10    collinberke: https://purrr.tidyverse.org/reference/slowly.html\n00:47:43    Robert Hilly: By guys!"
  },
  {
    "objectID": "videos/10/06.html",
    "href": "videos/10/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n01:02:25    Trevin: I'm good with combining üëç\n01:02:57    Oluwafemi Oyedele:  I agree with combining the chapter!!!"
  },
  {
    "objectID": "videos/09/07.html",
    "href": "videos/09/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:34:09    Ron:    Someone did: https://cran.r-project.org/web/packages/comprehenr/vignettes/Introduction.html\n00:47:58    collinberke:    https://purrr.tidyverse.org/reference/safely.html\n00:48:24    Ron:    it's a function operator !\n00:49:37    Ron:    \\(x) length(unique(x) is not too verbose though\n00:49:39    Ron:    ;)\n01:06:50    collinberke:    https://colinfay.me/purrr-mappers/\n01:07:45    collinberke:    https://colinfay.me/purrr-web-mining/"
  },
  {
    "objectID": "videos/08/06.html",
    "href": "videos/08/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:19:16    Trevin: https://style.tidyverse.org/error-messages.html\n00:20:14    Trevin: More on errors in the design guide: https://design.tidyverse.org/\n01:14:27    Federica Gazzelloni:    more info here: https://colinfay.me/learn-shiny-production/"
  },
  {
    "objectID": "videos/07/07.html",
    "href": "videos/07/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:06:49    Ryan Honomichl: https://r4ds.github.io/bookclub-Advanced_R/QandA/docs/environments.html\n\n\n\nMeeting chat log\n\n00:14:44    collinberke:    https://ivelasq.rbind.io/blog/macos-rig/index.html\n00:21:10    collinberke:    https://github.com/tidyverse/dplyr/blob/main/NAMESPACE\n01:00:21    collinberke:    https://r4ds.hadley.nz/iteration.html"
  },
  {
    "objectID": "videos/06/06.html",
    "href": "videos/06/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:01:11    Oluwafemi Oyedele:  Hi, Good evening\n00:01:22    Federica Gazzelloni:    Hello!\n00:43:19    Federica Gazzelloni:    https://r4ds.github.io/bookclub-Advanced_R/QandA/docs/welcome.html\n00:52:48    Priyanka:   sounds good actually\n00:52:59    Federica Gazzelloni:    üëçüèª\n\n\n\nMeeting chat log\n\n00:09:30    Oluwafemi Oyedele:  Hi, Good evening\n00:10:41    Federica Gazzelloni:    Hi\n00:14:40    Federica Gazzelloni:    that's great!\n00:54:24    Trevin: Also, sorry if you are repeating üôÇ\n00:54:52    Arthur Shaw:    @ryan, thank you so much for the awesome synthesis! Could you share your reference list? I'd love to dive more deeply into the material you presented.\n00:57:02    Ryan Metcalf:   https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf\n00:59:32    Trevin: https://github.com/COHHIO/RmData\n01:01:48    Ryan Metcalf:   https://mastering-shiny.org/\n01:02:02    Ryan Metcalf:   https://engineering-shiny.org/\n01:02:15    Arthur Shaw:    @trevin, if you get bored with beepr, move to BRRR ;)\n01:02:16    Arthur Shaw:    https://github.com/brooke-watson/BRRR\n01:09:27    Ryan Metcalf:   This is amazing Trevin! I'll take a closer look. Is it ok to reach out to you with any questions?\n01:09:43    Trevin: Yeah, feel free to reach out\n\n\n\nMeeting chat log\n\n00:05:34    Trevin: I didn't catch that\n00:06:02    priyanka gagneja:   i won't be presenting I said .. so you two have the stage\n00:08:39    Federica Gazzelloni:    no worries\n00:08:46    Federica Gazzelloni:    next time you do it\n00:08:56    Federica Gazzelloni:    did you sign up?\n00:09:45    Trevin: Discord is free: https://discord.gg/rstudioconf2022\n00:10:04    Trevin: Free stream link: https://www.rstudio.com/conference/stream\n00:24:32    Arthur Shaw:    Maybe silly question: is the magrittr pipe an infix function?\n00:32:15    Trevin: https://colinfay.me/playing-r-infix-functions/\n00:33:23    Arthur Shaw:    Maybe another example of an infix function: lubridate's `%within%`\n00:33:47    Trevin: That's a good one too ^\n00:33:55    priyanka gagneja:   yes within would be good.\n00:40:13    Arthur Shaw:    no\n00:49:50    Arthur Shaw:    Sorry for dropping in and out. My WiFi router is having issues today--maybe is failing.\n01:08:59    Trevin: Looking forward to it üôÇ"
  },
  {
    "objectID": "videos/05/07.html",
    "href": "videos/05/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:40:18    Ryan Honomichl: What type of vector does each of the following calls to ifelse() return?\n* \"ifelse returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is TRUE or FALSE.\"\n00:42:11    Ryan Honomichl: \"I recommend assigning the results of an if statement only when the entire expression fits on one line; otherwise it tends to be hard to read\"\n00:42:46    Ryan Honomichl: * When you use the single argument form without an `else` statement, `if` invisibly returns NULL if the condition is FALSE. \n-   Since functions like c() and paste() drop NULL inputs, this allows for a compact expression of certain idioms\n00:54:15    collinberke:    https://docs.google.com/spreadsheets/d/1ScrbEw_-vB9DruaJhjtVY8HLQmuNPqyWeOOjmG6OY1M/edit?usp=sharing\n00:58:46    collinberke:    https://www.youtube.com/@safe4democracy/videos"
  },
  {
    "objectID": "videos/04/06.html",
    "href": "videos/04/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:36:02    Arthur Shaw:    TIL that the subset operator has parameters. Thanks, Trevin!\n00:38:55    Vaibhav Janve:  its interesting that carriage \"a\" has two set of wheels instread of 4. I wonder that choice is because its atomic.\n00:40:44    Arthur Shaw:    @Vaibhav, because the load is lighter, the carriage needs fewer axles? ;)  I agree: it's a confusing graphical choice.\n00:41:11    Vaibhav Janve:  lol\n01:05:53    Vaibhav Janve:  Thank you Trevin!"
  },
  {
    "objectID": "videos/03/07.html",
    "href": "videos/03/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:54:07    Ron:    https://www.tidyverse.org/blog/2021/03/clock-0-1-0/\n01:14:39    Robert Hilly:   https://www.amazon.com/Effective-Pandas-Patterns-Manipulation-Treading/dp/B09MYXXSFM"
  },
  {
    "objectID": "videos/02/07.html",
    "href": "videos/02/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:09:40    Ryan Honomichl: https://drdoane.com/three-deep-truths-about-r/\n00:12:51    Robert Hilly:   Be right back\n00:36:12    Ryan Honomichl: brb\n00:41:18    Ron:    I tried mapply and also got different answers\n00:41:44    collinberke:    Interesting, would like to know more what is going on.\n00:49:57    Robert Hilly:   simple_map &lt;- function(x, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], ...)\n  }\n  out\n}"
  },
  {
    "objectID": "videos/01/07.html",
    "href": "videos/01/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:20:42    collinberke:    https://rich-iannone.github.io/pointblank/\n00:27:36    Ryan Honomichl: brb\n00:37:05    collinberke:    https://rstudio.github.io/renv/articles/renv.html\n00:51:52    Ryan Honomichl: gotta sign off I'll be ready to lead chapter 2 next week!\n00:52:43    collinberke:    https://r4ds.had.co.nz/iteration.html\n00:59:44    collinberke:    https://mastering-shiny.org/action-tidy.html\n01:00:12    collinberke:    https://dplyr.tidyverse.org/articles/programming.html\n01:05:02    collinberke:    https://usethis.r-lib.org/reference/create_from_github.html\n01:05:53    collinberke:    https://github.com/r4ds/bookclub-advr\n01:06:28    Ron:    I gotta run ,  fun conversation, and nice to meet you Matthew !"
  },
  {
    "objectID": "slides/25.html#learning-objectives",
    "href": "slides/25.html#learning-objectives",
    "title": "Rewriting R code in C++",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nLearn to improve performance by rewriting bottlenecks in C++\nIntroduction to the {Rcpp} package"
  },
  {
    "objectID": "slides/25.html#introduction",
    "href": "slides/25.html#introduction",
    "title": "Rewriting R code in C++",
    "section": "Introduction",
    "text": "Introduction\nIn this chapter we‚Äôll learn how to rewrite R code in C++ to make it faster using the Rcpp package. The Rcpp package makes it simple to connect C++ to R! With C++ you can fix:\n\nLoops that can‚Äôt be easily vectorised because subsequent iterations depend on previous ones.\nRecursive functions, or problems which involve calling functions millions of times. The overhead of calling a function in C++ is much lower than in R.\nProblems that require advanced data structures and algorithms that R doesn‚Äôt provide. Through the standard template library (STL), C++ has efficient implementations of many important data structures, from ordered maps to double-ended queue\n\n\nLike how?"
  },
  {
    "objectID": "slides/25.html#getting-started-with-c",
    "href": "slides/25.html#getting-started-with-c",
    "title": "Rewriting R code in C++",
    "section": "Getting started with C++",
    "text": "Getting started with C++\n\nlibrary(Rcpp)\n\nInstall a C++ compiler:\n\nRtools, on Windows\nXcode, on Mac\nSudo apt-get install r-base-dev or similar, on Linux.\n\nFirst example\nRcpp compiling the C++ code:\n\ncppFunction('int add(int x, int y, int z) {\n  int sum = x + y + z;\n  return sum;\n}')\n# add works like a regular R function\nadd\n\n#&gt; function (x, y, z) \n#&gt; .Call(&lt;pointer: 0x00007ff9d7e315f0&gt;, x, y, z)\n\nadd(1, 2, 3)\n\n#&gt; [1] 6\n\n\nSome things to note:\n\nThe syntax to create a function is different.\nTypes of inputs and outputs must be explicitly declared\nUse = for assignment, not &lt;-.\nEvery statement is terminated by a ;\nC++ has it‚Äôs own name for the types we are used to:\n\nscalar types are int, double, bool and String\nvector types (for Rcpp) are IntegerVector, NumericVector, LogicalVector and CharacterVector\nOther R types are available in C++: List, Function, DataFrame, and more.\n\nExplicitly use a return statement to return a value from a function."
  },
  {
    "objectID": "slides/25.html#example-with-scalar-input-and-output",
    "href": "slides/25.html#example-with-scalar-input-and-output",
    "title": "Rewriting R code in C++",
    "section": "Example with scalar input and output",
    "text": "Example with scalar input and output\n\nsignR &lt;- function(x) {\n  if (x &gt; 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\n\na &lt;- -0.5\nb &lt;- 0.5\nc &lt;- 0\nsignR(c)\n\n#&gt; [1] 0\n\n\nTranslation:\n\ncppFunction('int signC(int x) {\n  if (x &gt; 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}')\n\n\nNote that the if syntax is identical! Not everything is different!"
  },
  {
    "objectID": "slides/25.html#vector-input-scalar-output",
    "href": "slides/25.html#vector-input-scalar-output",
    "title": "Rewriting R code in C++",
    "section": "Vector Input, Scalar output:",
    "text": "Vector Input, Scalar output:\n\nsumR &lt;- function(x) {\n  total &lt;- 0\n  for (i in seq_along(x)) {\n    total &lt;- total + x[i]\n  }\n  total\n}\n\nx&lt;- runif(100)\nsumR(x)\n\n#&gt; [1] 51.16287\n\n\nTranslation:\n\ncppFunction('double sumC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total;\n}')\n\nSome observations:\n\nvector indices start at 0\nThe for statement has a different syntax: for(init; check; increment)\nMethods are called with .\ntotal += x[i] is equivalent to total = total + x[i].\nother in-place operators are -=, *=, and /=\n\nTo check for the fastest way we can use:\n\n?bench::mark\n\n\nx &lt;- runif(1e3)\nbench::mark(\n  sum(x),\n  sumC(x),\n  sumR(x)\n)\n\n#&gt; # A tibble: 3 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sum(x)        700ns    1.6¬µs   611939.        0B        0\n#&gt; 2 sumC(x)       900ns    1.7¬µs   469982.        0B        0\n#&gt; 3 sumR(x)      14.2¬µs   27.4¬µs    33865.        0B        0"
  },
  {
    "objectID": "slides/25.html#vector-input-and-output",
    "href": "slides/25.html#vector-input-and-output",
    "title": "Rewriting R code in C++",
    "section": "Vector input and output",
    "text": "Vector input and output\n\npdistR &lt;- function(x, ys) {\n  sqrt((x - ys) ^ 2)\n}\n\n\ncppFunction('NumericVector pdistC(double x, NumericVector ys) {\n  int n = ys.size();\n  NumericVector out(n);\n\n  for(int i = 0; i &lt; n; ++i) {\n    out[i] = sqrt(pow(ys[i] - x, 2.0));\n  }\n  return out;\n}')\n\nNote: uses pow(), not ^, for exponentiation\n\ny &lt;- runif(1e6)\nbench::mark(\n  pdistR(0.5, y),\n  pdistC(0.5, y)\n)[1:6]\n\n#&gt; # A tibble: 2 √ó 6\n#&gt;   expression          min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 pdistR(0.5, y)   4.37ms   8.76ms      119.    7.63MB     63.2\n#&gt; 2 pdistC(0.5, y)   2.26ms    5.7ms      182.    7.63MB     87.5"
  },
  {
    "objectID": "slides/25.html#source-your-c-code",
    "href": "slides/25.html#source-your-c-code",
    "title": "Rewriting R code in C++",
    "section": "Source your C++ code",
    "text": "Source your C++ code\nSource stand-alone C++ files into R using sourceCpp()\nC++ files have extension .cpp\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\nAnd for each function that you want available within R, you need to prefix it with:\n// [[Rcpp::export]]\nInside a cpp file you can include R code using special comments\n/*** R\nrcode here\n*/\nExample\nThis block in Rmarkdown uses {Rcpp} as a short hand for engine = ‚ÄúRcpp‚Äù.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble meanC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total / n;\n}\n\n/*** R\nx &lt;- runif(1e5)\nbench::mark(\n  mean(x),\n  meanC(x)\n)\n*/\n\nNOTE: For some reason although the r code above runs, knit doesn‚Äôt include the output. Why?\n\nx &lt;- runif(1e5)\nbench::mark(\n  mean(x),\n  meanC(x)\n)\n\n#&gt; # A tibble: 2 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 mean(x)     122.8¬µs    234¬µs     4084.        0B     2.02\n#&gt; 2 meanC(x)     40.4¬µs    114¬µs     9270.        0B     0"
  },
  {
    "objectID": "slides/25.html#data-frames-functions-and-attributes",
    "href": "slides/25.html#data-frames-functions-and-attributes",
    "title": "Rewriting R code in C++",
    "section": "Data frames, functions, and attributes",
    "text": "Data frames, functions, and attributes\nLists and Dataframes\nContrived example to illustrate how to access a dataframe from c++:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble mpe(List mod) {\n  if (!mod.inherits(\"lm\")) stop(\"Input must be a linear model\");\n\n  NumericVector resid = as&lt;NumericVector&gt;(mod[\"residuals\"]);\n  NumericVector fitted = as&lt;NumericVector&gt;(mod[\"fitted.values\"]);\n\n  int n = resid.size();\n  double err = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    err += resid[i] / (fitted[i] + resid[i]);\n  }\n  return err / n;\n}\n\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmpe(mod)\n\n#&gt; [1] -0.01541615\n\n\n\nNote that you must cast the values to the required type. C++ needs to know the types in advance.\n\nFunctions\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRObject callWithOne(Function f) {\n  return f(1);\n}\n\n\ncallWithOne(function(x) x + 1)\n\n#&gt; [1] 2\n\n\n\nOther values can be accessed from c++ including\n\nattributes (use: .attr(). Also .names() is alias for name attribute.\nEnvironment, DottedPair, Language, Symbol , etc."
  },
  {
    "objectID": "slides/25.html#missing-values",
    "href": "slides/25.html#missing-values",
    "title": "Rewriting R code in C++",
    "section": "Missing values",
    "text": "Missing values\nMissing values behave differently for C++ scalers\n\nScalar NA‚Äôs in Cpp : NA_LOGICAL, NA_INTEGER, NA_REAL, NA_STRING.\nIntegers (int) stores R NA‚Äôs as the smallest integer. Better to use length 1 IntegerVector\nDoubles use IEEE 754 NaN , which behaves a bit differently for logical expressions (but ok for math expressions).\n\n\nevalCpp(\"NA_REAL || FALSE\")\n\n#&gt; [1] TRUE\n\n\n\nStrings are a class from Rcpp, so they handle missing values fine.\nbool can only hold two values, so be careful. Consider using vectors of length 1 or coercing to int\n\nVectors\n\nVectors are all type introduced by RCpp and know how to handle missing values if you use the specific type for that vector.\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList missing_sampler() {\n  return List::create(\n    NumericVector::create(NA_REAL),\n    IntegerVector::create(NA_INTEGER),\n    LogicalVector::create(NA_LOGICAL),\n    CharacterVector::create(NA_STRING)\n  );\n}\n\n\nstr(missing_sampler())\n\n#&gt; List of 4\n#&gt;  $ : num NA\n#&gt;  $ : int NA\n#&gt;  $ : logi NA\n#&gt;  $ : chr NA"
  },
  {
    "objectID": "slides/25.html#standard-template-library",
    "href": "slides/25.html#standard-template-library",
    "title": "Rewriting R code in C++",
    "section": "Standard Template Library",
    "text": "Standard Template Library\nSTL provides powerful data structures and algorithms for C++.\nIterators\nIterators are used extensively in the STL to abstract away details of underlying data structures.\nIf you an iterator it, you can:\n\nGet the value by ‚Äòdereferencing‚Äô with *it\nAdvance to the next value with ++it\nCompare iterators (locations) with ==\n\nAlgorithms\n\nThe real power of iterators comes from using them with STL algorithms.\nA good reference is [https://en.cppreference.com/w/cpp/algorithm]\nBook provides examples using accumulate and upper_buond\nAnother Example:\n\n\n\n#include &lt;algorithm&gt;\n#include &lt;Rcpp.h&gt;\n\nusing namespace Rcpp;\n \n \n// Explicit iterator version\n \n// [[Rcpp::export]]\nNumericVector square_C_it(NumericVector x){\n  NumericVector out(x.size());\n  // Each container has its own iterator type\n  NumericVector::iterator in_it;\n  NumericVector::iterator out_it;\n  \n  for(in_it = x.begin(), out_it = out.begin(); in_it != x.end();  ++in_it, ++out_it) {\n    *out_it = pow(*in_it,2);\n  }\n  \n  return out;\n  \n}\n \n \n// Use algorithm 'transform'\n  \n// [[Rcpp::export]]\nNumericVector square_C(NumericVector x) {\n \n  NumericVector out(x.size());\n \n \n  std::transform(x.begin(),x.end(), out.begin(),\n            [](double v) -&gt; double { return v*v; });\n  return out;\n}\n\n\nsquare_C(c(1.0,2.0,3.0))\n\n#&gt; [1] 1 4 9\n\n\n\nsquare_C_it(c(1.0,2.0,3.0))\n\n#&gt; [1] 1 4 9"
  },
  {
    "objectID": "slides/25.html#data-structures",
    "href": "slides/25.html#data-structures",
    "title": "Rewriting R code in C++",
    "section": "Data Structures",
    "text": "Data Structures\nSTL provides a large set of data structures. Some of the most important:\n\nstd::vector - like an R vector, except knows how to grow efficiently\nstd::unordered_set - unique set of values. Ordered version std::set. Unordered is more efficient.\nstd::map - Moslty similar to R lists, provide an association between a key and a value. There is also an unordered version.\n\nA quick example illustrating the map:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nstd::map&lt;double, int&gt; tableC(NumericVector x) {\n  // Note the types are &lt;key, value&gt;\n  std::map&lt;double, int&gt; counts;\n\n  int n = x.size();\n  for (int i = 0; i &lt; n; i++) {\n    counts[x[i]]++;\n  }\n\n  return counts;\n}\n\n\nres = tableC(c(1,1,2,1,4,5))\nres\n\n#&gt; 1 2 4 5 \n#&gt; 3 1 1 1\n\n\n\nNote that the map is converted to a named vector in this case on return\n\nTo learn more about the STL data structures see containers at cppreference"
  },
  {
    "objectID": "slides/25.html#case-studies",
    "href": "slides/25.html#case-studies",
    "title": "Rewriting R code in C++",
    "section": "Case Studies",
    "text": "Case Studies\n\nCase StudyReal life uses of C++ to replace slow R code."
  },
  {
    "objectID": "slides/25.html#case-study-1-gibbs-sampler",
    "href": "slides/25.html#case-study-1-gibbs-sampler",
    "title": "Rewriting R code in C++",
    "section": "Case study 1: Gibbs sampler",
    "text": "Case study 1: Gibbs sampler\nThe Gibbs sampler is a method for estimating parameters expectations. It is a MCMC algorithm that has been adapted to sample from multidimensional target distributions. Gibbs sampling generates a Markov chain of samples, each of which is correlated with nearby samples.\nExample blogged by Dirk Eddelbuettel, the R and C++ code is very similar but runs about 20 times faster.\n\n‚ÄúDarren Wilkinson stresses the rather pragmatic aspects of how fast and/or easy it is to write the code, rather than just the mere runtime.\n\n\n\n\nR code:\n\ngibbs_r &lt;- function(N, thin) {\n  mat &lt;- matrix(nrow = N, ncol = 2)\n  x &lt;- y &lt;- 0\n\n  for (i in 1:N) {\n    for (j in 1:thin) {\n      x &lt;- rgamma(1, 3, y * y + 4)\n      y &lt;- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))\n    }\n    mat[i, ] &lt;- c(x, y)\n  }\n  mat\n}\n\nActions to convert R to C++:\n\nAdd type declarations to all variables\nUse ( instead of [ to index into the matrix\nSubscript the results of rgamma and rnorm to convert from a vector into a scalar.\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericMatrix gibbs_cpp(int N, int thin) {\n  NumericMatrix mat(N, 2);\n  double x = 0, y = 0;\n\n  for(int i = 0; i &lt; N; i++) {\n    for(int j = 0; j &lt; thin; j++) {\n      x = rgamma(1, 3, 1 / (y * y + 4))[0];\n      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];\n    }\n    mat(i, 0) = x;\n    mat(i, 1) = y;\n  }\n\n  return(mat);\n}\n\nChecking who‚Äôs best:\n\nbench::mark(\n  gibbs_r(100, 10),\n  gibbs_cpp(100, 10),\n  check = FALSE\n)\n\n#&gt; # A tibble: 2 √ó 6\n#&gt;   expression              min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 gibbs_r(100, 10)     1.31ms   3.83ms      283.  103.22KB     18.0\n#&gt; 2 gibbs_cpp(100, 10)  150.1¬µs  416.3¬µs     2456.    1.61KB     16.9"
  },
  {
    "objectID": "slides/25.html#case-study-2-predict-a-model-response-from-three-inputs",
    "href": "slides/25.html#case-study-2-predict-a-model-response-from-three-inputs",
    "title": "Rewriting R code in C++",
    "section": "Case study 2: predict a model response from three inputs",
    "text": "Case study 2: predict a model response from three inputs\nRcpp is smoking fast for agent based models in data frames by Gary Weissman, MD, MSHP.\nStarts with this code:\n\nvacc1a &lt;- function(age, female, ily) {\n  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p &lt;- p * if (female) 1.25 else 0.75\n  p &lt;- max(0, p)\n  p &lt;- min(1, p)\n  p\n}\n\nR code with a for loop:\n\nvacc1 &lt;- function(age, female, ily) {\n  n &lt;- length(age)\n  out &lt;- numeric(n)\n  for (i in seq_len(n)) {\n    out[i] &lt;- vacc1a(age[i], female[i], ily[i])\n  }\n  out\n}\n\nVectorized R code:\n\nvacc2 &lt;- function(age, female, ily) {\n  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p &lt;- p * ifelse(female, 1.25, 0.75)\n  p &lt;- pmax(0, p)\n  p &lt;- pmin(1, p)\n  p\n}\n\nC++:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\ndouble vacc3a(double age, bool female, bool ily){\n  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;\n  p = p * (female ? 1.25 : 0.75);\n  p = std::max(p, 0.0);\n  p = std::min(p, 1.0);\n  return p;\n}\n\n// [[Rcpp::export]]\nNumericVector vacc3(NumericVector age, LogicalVector female, \n                    LogicalVector ily) {\n  int n = age.size();\n  NumericVector out(n);\n\n  for(int i = 0; i &lt; n; ++i) {\n    out[i] = vacc3a(age[i], female[i], ily[i]);\n  }\n\n  return out;\n}\n\nSample data:\n\nn &lt;- 1000\nage &lt;- rnorm(n, mean = 50, sd = 10)\nfemale &lt;- sample(c(T, F), n, rep = TRUE)\nily &lt;- sample(c(T, F), n, prob = c(0.8, 0.2), rep = TRUE)\n\nstopifnot(\n  all.equal(vacc1(age, female, ily), vacc2(age, female, ily)),\n  all.equal(vacc1(age, female, ily), vacc3(age, female, ily))\n)\n\n\nWho‚Äôs faster?\n\n\n\n\n\nbench::mark(\n  vacc1 = vacc1(age, female, ily),\n  vacc2 = vacc2(age, female, ily),\n  vacc3 = vacc3(age, female, ily)\n)\n\n#&gt; # A tibble: 3 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 vacc1       750.5¬µs   1.88ms      546.    7.86KB    28.8 \n#&gt; 2 vacc2        48.4¬µs   72.1¬µs    10005.  146.68KB    16.9 \n#&gt; 3 vacc3        30.8¬µs   41.5¬µs    15519.   11.98KB     4.06"
  },
  {
    "objectID": "slides/25.html#resources",
    "href": "slides/25.html#resources",
    "title": "Rewriting R code in C++",
    "section": "Resources",
    "text": "Resources\n\nRcpp: Seamless R and C++ Integration\ncpp-tutorial is often recommended. Lots of ads though!\ncpp-reference\nC++20 for Programmers is a newer book that covers modern c++ for people who know programming in another language."
  },
  {
    "objectID": "slides/25.html#op-success",
    "href": "slides/25.html#op-success",
    "title": "Rewriting R code in C++",
    "section": "Op Success!",
    "text": "Op Success!\n\n\n\nCongrats!"
  },
  {
    "objectID": "slides/23.html#learning-objectives",
    "href": "slides/23.html#learning-objectives",
    "title": "Measuring performance",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nUnderstand how to improve your code for making it faster\nLearn what are the tools for improving your code\nTest how to profile your code"
  },
  {
    "objectID": "slides/23.html#introduction",
    "href": "slides/23.html#introduction",
    "title": "Measuring performance",
    "section": "Introduction",
    "text": "Introduction\n\n‚ÄúBefore you can make your code faster, you first need to figure out what‚Äôs making it slow.‚Äù\n\n\nSLOW DOWN TO LEARN HOW TO CODE FASTER | credits: packtpub.com\nprofile your code: measure the run-time of each line of code using realistic inputs\nexperiment with alternatives to find faster code\nmicrobenchmark to measure the difference in performance."
  },
  {
    "objectID": "slides/23.html#profiling",
    "href": "slides/23.html#profiling",
    "title": "Measuring performance",
    "section": "Profiling",
    "text": "Profiling\n\nlibrary(profvis)\nlibrary(bench)\n\nThe tool to use is a profiler, it allows for sampling the code performance through stopping the execution of code every few milliseconds and recording all the steps.\nExample:\n\nf &lt;- function() {\n  pause(0.1)\n  g()\n  h()\n}\ng &lt;- function() {\n  pause(0.1)\n  h()\n}\nh &lt;- function() {\n  pause(0.1)\n}\n\nProfile the execution of f():\nprofvis::pause() is used instead of Sys.sleep()\nprofile f(), with utils::Rprof()\n\ntmp &lt;- tempfile()\nRprof(tmp, interval = 0.1)\nf()\n\n#&gt; NULL\n\nRprof(NULL)\nwriteLines(readLines(tmp))\n\n#&gt; sample.interval=100000\n#&gt; \"pause\" \"f\" \"eval\" \"eval\" \"withVisible\" \"withCallingHandlers\" \"eval\" \"eval\" \"with_handlers\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"withRestarts\" \"evaluate::evaluate\" \"evaluate\" \"in_dir\" \"in_input_dir\" \"eng_r\" \"block_exec\" \"call_block\" \"process_group\" \"withCallingHandlers\" \"xfun:::handle_error\" \"process_file\" \"knitr::knit\" \"rmarkdown::render\" \"execute\" \".main\" \n#&gt; \"pause\" \"g\" \"f\" \"eval\" \"eval\" \"withVisible\" \"withCallingHandlers\" \"eval\" \"eval\" \"with_handlers\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"withRestarts\" \"evaluate::evaluate\" \"evaluate\" \"in_dir\" \"in_input_dir\" \"eng_r\" \"block_exec\" \"call_block\" \"process_group\" \"withCallingHandlers\" \"xfun:::handle_error\" \"process_file\" \"knitr::knit\" \"rmarkdown::render\" \"execute\" \".main\" \n#&gt; \"pause\" \"h\" \"g\" \"f\" \"eval\" \"eval\" \"withVisible\" \"withCallingHandlers\" \"eval\" \"eval\" \"with_handlers\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"withRestarts\" \"evaluate::evaluate\" \"evaluate\" \"in_dir\" \"in_input_dir\" \"eng_r\" \"block_exec\" \"call_block\" \"process_group\" \"withCallingHandlers\" \"xfun:::handle_error\" \"process_file\" \"knitr::knit\" \"rmarkdown::render\" \"execute\" \".main\" \n#&gt; \"pause\" \"h\" \"f\" \"eval\" \"eval\" \"withVisible\" \"withCallingHandlers\" \"eval\" \"eval\" \"with_handlers\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"doWithOneRestart\" \"withOneRestart\" \"withRestartList\" \"withRestarts\" \"evaluate::evaluate\" \"evaluate\" \"in_dir\" \"in_input_dir\" \"eng_r\" \"block_exec\" \"call_block\" \"process_group\" \"withCallingHandlers\" \"xfun:::handle_error\" \"process_file\" \"knitr::knit\" \"rmarkdown::render\" \"execute\" \".main\"\n\n\nVisualising profiles\nMakes easier to build up a mental model of what you need to change:\nprofvis::profvis()\nutils::summaryRprof()\n\nsource(\"scripts/profiling-example.R\")\nprofvis(f())\n\n\n\n\n\nMemory profiling and the garbage collector\nProfiling a loop that modifies an existing variable:\n\nprofvis::profvis({\n  x &lt;- integer()\nfor (i in 1:1e4) {\n  x &lt;- c(x, i)\n}\n})\n\n\n\n\n\nYou can figure out what is the source of the problem by looking at the memory column. In this case, copy-on-modify acts in each iteration of the loop creating another copy of x.\nLimitations\n\nProfiling does not extend to C code\nAnonymous functions are hard to figure out\nArguments are evaluated inside another function\n\nExercise\n\nprofvis::profvis({\n  f &lt;- function(n = 1e5) {\n  x &lt;- rep(1, n)\n  rm(x)\n}\n},torture = TRUE)\n\n?rm()\nsolution"
  },
  {
    "objectID": "slides/23.html#microbenchmarking",
    "href": "slides/23.html#microbenchmarking",
    "title": "Measuring performance",
    "section": "Microbenchmarking",
    "text": "Microbenchmarking\nMeasurement of the performance of a very small piece of code is useful for comparing small snippets of code for specific tasks.\n\n\n\n\n\nCredits: Google search-engine\n\n\n\n\nThe {bench} package uses a high precision time.\nbench::mark()\n\nlibrary(bench)\nx &lt;- runif(100)\n(lb &lt;- bench::mark(\n  sqrt(x),\n  x ^ 0.5\n))\n\n#&gt; # A tibble: 2 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sqrt(x)       300ns    400ns  1977692.      848B        0\n#&gt; 2 x^0.5         2.9¬µs      3¬µs   321570.      848B        0\n\n\n\nheavily right-skewed distribution\n\n\nrequire(ggbeeswarm)\n\n#&gt; Loading required package: ggbeeswarm\n\n\n#&gt; Loading required package: ggplot2\n\nplot(lb)"
  },
  {
    "objectID": "slides/23.html#resources",
    "href": "slides/23.html#resources",
    "title": "Measuring performance",
    "section": "Resources",
    "text": "Resources\n\nprofvis package\nbench package\nsolutions"
  },
  {
    "objectID": "slides/21.html#learning-objectives",
    "href": "slides/21.html#learning-objectives",
    "title": "Translating R code",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nBuild DSL (domain specific languages) to aid interoperability between R, HTML and LaTeX\nReinforce metaprogramming concepts (expressions, quasiquotation, evaluation)\n\n\n\n\n\n\n\n\n\nMermaid code\n\n\nDiagrammeR::mermaid(\"\ngraph LR\n\nexpressions --&gt; R\nquasiquotation --&gt; R\nevaluation --&gt; R\n\nR --&gt; HTML\nR --&gt; LaTeX\n\")\n\n\n\n\nSession Info\n\n\nlibrary(DiagrammeR) #for Mermaid flowchart\nlibrary(lobstr)     #abstract syntax trees\nlibrary(purrr)      #functional programming\nlibrary(rlang)      #tidy evaluation\n\n# from section 18.5\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\n\nutils::sessionInfo()\n\n#&gt; R version 4.5.1 (2025-06-13 ucrt)\n#&gt; Platform: x86_64-w64-mingw32/x64\n#&gt; Running under: Windows 11 x64 (build 26100)\n#&gt; \n#&gt; Matrix products: default\n#&gt;   LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] LC_COLLATE=English_United States.utf8 \n#&gt; [2] LC_CTYPE=English_United States.utf8   \n#&gt; [3] LC_MONETARY=English_United States.utf8\n#&gt; [4] LC_NUMERIC=C                          \n#&gt; [5] LC_TIME=English_United States.utf8    \n#&gt; \n#&gt; time zone: America/Chicago\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     \n#&gt; \n#&gt; other attached packages:\n#&gt; [1] rlang_1.1.6       purrr_1.1.0       lobstr_1.1.2      DiagrammeR_1.0.11\n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;  [1] digest_0.6.37      RColorBrewer_1.1-3 R6_2.6.1           fastmap_1.2.0     \n#&gt;  [5] xfun_0.52          magrittr_2.0.3     glue_1.8.0         knitr_1.50        \n#&gt;  [9] htmltools_0.5.8.1  rmarkdown_2.29     lifecycle_1.0.4    cli_3.6.5         \n#&gt; [13] visNetwork_2.1.2   vctrs_0.6.5        compiler_4.5.1     tools_4.5.1       \n#&gt; [17] evaluate_1.0.4     yaml_2.3.10        jsonlite_2.0.0     htmlwidgets_1.6.4 \n#&gt; [21] keyring_1.4.1"
  },
  {
    "objectID": "slides/21.html#case-study-mcq",
    "href": "slides/21.html#case-study-mcq",
    "title": "Translating R code",
    "section": "Case Study: MCQ",
    "text": "Case Study: MCQ\nWe are going to use R code to generate HTML or LaTeX to produce multiple-choice questions such as\nPop Quiz!\n\nWhat is the derivative of \\(f(x) = 1 + 2\\cos(3\\pi x + 4)\\)?\n\n\\(f'(x) = 6\\pi\\sin(3\\pi x + 4)\\)\n\\(f'(x) = -6\\pi\\sin(3\\pi x + 4)\\)\n\\(f'(x) = 24\\pi\\sin(3\\pi x + 4)\\)\n\\(f'(x) = -24\\pi\\sin(3\\pi x + 4)\\)\n\n\n\nA whisker plot"
  },
  {
    "objectID": "slides/21.html#html",
    "href": "slides/21.html#html",
    "title": "Translating R code",
    "section": "HTML",
    "text": "HTML\nWe are trying to produce\n&lt;body&gt;\n  &lt;h1 id = 'pop_quiz'&gt;Pop Quiz&lt;/h1&gt;\n  &lt;ol&gt;\n    &lt;li&gt;What is the &lt;b&gt;derivative&lt;/b&gt; of $f(x) = 1 + 2\\cos(3\\pi x + 4)$?&lt;/li&gt;\n    &lt;ol&gt;\n      &lt;li&gt;$f'(x) = 6\\pi\\sin(3\\pi x + 4)$&lt;/li&gt;\n      &lt;li&gt;$f'(x) = -6\\pi\\sin(3\\pi x + 4)$&lt;/li&gt;\n      &lt;li&gt;$f'(x) = 24\\pi\\sin(3\\pi x + 4)$&lt;/li&gt;\n      &lt;li&gt;$f'(x) = -24\\pi\\sin(3\\pi x + 4)$&lt;/li&gt;\n    &lt;/ol&gt;\n  &lt;/ol&gt;\n  &lt;img src = 'calculus_cat.png' width = '100' height = '100' /&gt;\n&lt;/body&gt;\nusing DSL\n\nwith_html(\n  body(\n    h1(\"Pop quiz!\", id = \"pop_quiz\"),\n    ol(\n      li(\"What is the \", b(\"derivative\"),  \"of $f(x) = 1 + 2cos(3pi x + 4)$?\"),\n      ol(\n        li(\"$f'(x) = 6pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = -6pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = 24pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = -24pi*sin(3pi x + 4)$\")\n      )\n    ),\n    img(src = \"images/translating/calculus_cat.png\", width = 100, height = 100)\n  )\n)\n\nIn particular,\n\ntags such as &lt;b&gt;&lt;/b&gt; have attributes\nvoid tags such as &lt;img /&gt;\nspecial characters: &, &lt;, and &gt;\n\n\n\nHTML verification\n\n\n  Pop Quiz\n  \n    What is the derivative of $f(x) = 1 + 2\\cos(3\\pi x + 4)$?\n    \n      $f'(x) = 6\\pi\\sin(3\\pi x + 4)$\n      $f'(x) = -6\\pi\\sin(3\\pi x + 4)$\n      $f'(x) = 24\\pi\\sin(3\\pi x + 4)$\n      $f'(x) = -24\\pi\\sin(3\\pi x + 4)$"
  },
  {
    "objectID": "slides/21.html#escaping",
    "href": "slides/21.html#escaping",
    "title": "Translating R code",
    "section": "Escaping",
    "text": "Escaping\n\nneed to escape &, &lt;, and &gt;\ndon‚Äôt ‚Äúdouble escape‚Äù\nleave HTML alone\n\nS3 Class\n\nhtml &lt;- function(x) structure(x, class = \"advr_html\")\n\n#dispatch\nprint.advr_html &lt;- function(x, ...) {\n  out &lt;- paste0(\"&lt;HTML&gt; \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\n\nGeneric\n\nescape &lt;- function(x) UseMethod(\"escape\")\nescape.character &lt;- function(x) {\n  x &lt;- gsub(\"&\", \"&amp;\", x)\n  x &lt;- gsub(\"&lt;\", \"&lt;\", x)\n  x &lt;- gsub(\"&gt;\", \"&gt;\", x)\n  html(x)\n}\nescape.advr_html &lt;- function(x) x\n\nChecks\n\nescape(\"This is some text.\")\n\n#&gt; &lt;HTML&gt; This is some text.\n\nescape(\"x &gt; 1 & y &lt; 2\")\n\n#&gt; &lt;HTML&gt; x &gt; 1 &amp; y &lt; 2\n\nescape(escape(\"This is some text. 1 &gt; 2\")) #double escape\n\n#&gt; &lt;HTML&gt; This is some text. 1 &gt; 2\n\nescape(html(\"&lt;hr /&gt;\")) #already html\n\n#&gt; &lt;HTML&gt; &lt;hr /&gt;"
  },
  {
    "objectID": "slides/21.html#named-components",
    "href": "slides/21.html#named-components",
    "title": "Translating R code",
    "section": "Named Components",
    "text": "Named Components\nli(\"What is the \", b(\"derivative\"),  \"of $f(x) = 1 + 2\\cos(3\\pi x + 4)$?\")\n\naiming to classify li and b as named components\n\n\ndots_partition &lt;- function(...) {\n  dots &lt;- list2(...)\n  \n if (is.null(names(dots))) {\n  is_named &lt;- rep(FALSE, length(dots))\n} else {\n  is_named &lt;- names(dots) != \"\"\n}\n  \n  list(\n    named = dots[is_named],\n    unnamed = dots[!is_named]\n  )\n}\n\nCheck\n\nstr(dots_partition(company = \"Posit\",\n                   software = \"RStudio\",\n                   \"DSLC\",\n                   \"Cohort 9\"))\n\n#&gt; List of 2\n#&gt;  $ named  :List of 2\n#&gt;   ..$ company : chr \"Posit\"\n#&gt;   ..$ software: chr \"RStudio\"\n#&gt;  $ unnamed:List of 2\n#&gt;   ..$ : chr \"DSLC\"\n#&gt;   ..$ : chr \"Cohort 9\"\n\n\n\n\nHTML Attributes\n\nFound among the textbook‚Äôs source code\n\nhtml_attributes &lt;- function(list) {\n  if (length(list) == 0) return(\"\")\n\n  attr &lt;- map2_chr(names(list), list, html_attribute)\n  paste0(\" \", unlist(attr), collapse = \"\")\n}\nhtml_attribute &lt;- function(name, value = NULL) {\n  if (length(value) == 0) return(name) # for attributes with no value\n  if (length(value) != 1) stop(\"`value` must be NULL or length 1\")\n\n  if (is.logical(value)) {\n    # Convert T and F to true and false\n    value &lt;- tolower(value)\n  } else {\n    value &lt;- escape_attr(value)\n  }\n  paste0(name, \"='\", value, \"'\")\n}\nescape_attr &lt;- function(x) {\n  x &lt;- escape.character(x)\n  x &lt;- gsub(\"\\'\", '&#39;', x)\n  x &lt;- gsub(\"\\\"\", '&quot;', x)\n  x &lt;- gsub(\"\\r\", '&#13;', x)\n  x &lt;- gsub(\"\\n\", '&#10;', x)\n  x\n}"
  },
  {
    "objectID": "slides/21.html#tags-calls",
    "href": "slides/21.html#tags-calls",
    "title": "Translating R code",
    "section": "Tags (calls)",
    "text": "Tags (calls)\n\ntag &lt;- function(tag) {\n  new_function(\n    exprs(... = ), #arguments of new function\n    expr({         #body of the new function\n      \n      #classify tags as named components\n      dots &lt;- dots_partition(...)\n      \n      #focus on named components as the tags\n      attribs &lt;- html_attributes(dots$named)\n      \n      # otherwise, nested code\n      children &lt;- map_chr(dots$unnamed, escape)\n\n      # paste brackets, tag names, and attributes together\n      # then unquote user arguments\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    }),\n    caller_env() #return the environment\n  )\n}\n\n\n\nVoid tags\n\n\nvoid_tag &lt;- function(tag) {\n  new_function(\n    exprs(... = ), #allows for missing arguments\n    expr({\n      dots &lt;- dots_partition(...)\n      \n      # error check\n      if (length(dots$unnamed) &gt; 0) {\n        abort(!!paste0(\"&lt;\", tag, \"&gt; must not have unnamed arguments\"))\n      }\n      attribs &lt;- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"&lt;\", tag), attribs, \" /&gt;\"))\n    }),\n    caller_env()\n  )\n}\n\n\nChecks\n\ntag(\"ol\")\n\n#&gt; function (...) \n#&gt; {\n#&gt;     dots &lt;- dots_partition(...)\n#&gt;     attribs &lt;- html_attributes(dots$named)\n#&gt;     children &lt;- map_chr(dots$unnamed, escape)\n#&gt;     html(paste0(\"&lt;ol\", attribs, \"&gt;\", paste(children, collapse = \"\"), \n#&gt;         \"&lt;/ol&gt;\"))\n#&gt; }\n\n\n\nimg &lt;- void_tag(\"img\")\n\nimg()\n\n\n\nimg(src = \"images/translating/calculus_cat.png\",\n    width = 100,\n    height = 100)\n\n#&gt; &lt;HTML&gt; &lt;img src='images/translating/calculus_cat.png' width='100'\n#&gt; height='100' /&gt;"
  },
  {
    "objectID": "slides/21.html#tags-processing",
    "href": "slides/21.html#tags-processing",
    "title": "Translating R code",
    "section": "Tags (processing)",
    "text": "Tags (processing)\n\n\nVenn Diagram\n\n\n\n\nVenn Diagram of words in R or HTML\n\n\n\ntags &lt;- c(\"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\",\n  \"b\",\"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\",\"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\",\"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\",\"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\",\"iframe\", \"ins\", \"kbd\", \"label\",\n  \"legend\", \"li\", \"mark\", \"map\",\"menu\", \"meter\", \"nav\",\n  \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\",\n  \"p\", \"pre\", \"progress\", \"q\", \"ruby\", \"rp\",\"rt\", \"s\", \"samp\",\n  \"script\", \"section\", \"select\", \"small\", \"span\", \"strong\",\n  \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\",\n  \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\",\n  \"u\", \"ul\", \"var\", \"video\"\n)\n\nvoid_tags &lt;- c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\",\n  \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n  \"source\", \"track\", \"wbr\"\n)\n\n\n\nhtml_tags &lt;- c(\n  tags |&gt;          #list of tag names from HTML\n    set_names() |&gt; #named variable to avoid reserved words!\n    map(tag),      #make them function calls\n  void_tags |&gt;\n    set_names() |&gt;\n    map(void_tag)\n)\n\nExample\n\nhtml_tags$ol(\n  html_tags$li(\"What is the \", \n               html_tags$b(\"derivative\"),\n               \"of $f(x) = 1 + 2cos(3pi x + 4)$?\"))\n\n#&gt; &lt;HTML&gt; &lt;ol&gt;&lt;li&gt;What is the &lt;b&gt;derivative&lt;/b&gt;of $f(x) = 1 + 2cos(3pi x +\n#&gt; 4)$?&lt;/li&gt;&lt;/ol&gt;"
  },
  {
    "objectID": "slides/21.html#bringing-the-html-together",
    "href": "slides/21.html#bringing-the-html-together",
    "title": "Translating R code",
    "section": "Bringing the HTML Together",
    "text": "Bringing the HTML Together\n\nwith_html &lt;- function(code) {\n  eval_tidy(enquo(code), html_tags)\n}\n\nMain Example\n\nwith_html(\n  body(\n    h1(\"Pop quiz!\", id = \"pop_quiz\"),\n    ol(\n      li(\"What is the \", b(\"derivative\"),  \"of $f(x) = 1 + 2cos(3pi x + 4)$?\"),\n      ol(\n        li(\"$f'(x) = 6pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = -6pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = 24pi*sin(3pi x + 4)$\"),\n        li(\"$f'(x) = -24pi*sin(3pi x + 4)$\")\n      )\n    ),\n    img(src = \"images/translating/calculus_cat.png\", width = 100, height = 100)\n  )\n)\n\n#&gt; &lt;HTML&gt; &lt;body&gt;&lt;h1 id='pop_quiz'&gt;Pop quiz!&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;What is the\n#&gt; &lt;b&gt;derivative&lt;/b&gt;of $f(x) = 1 + 2cos(3pi x + 4)$?&lt;/li&gt;&lt;ol&gt;&lt;li&gt;$f'(x) =\n#&gt; 6pi*sin(3pi x + 4)$&lt;/li&gt;&lt;li&gt;$f'(x) = -6pi*sin(3pi x +\n#&gt; 4)$&lt;/li&gt;&lt;li&gt;$f'(x) = 24pi*sin(3pi x + 4)$&lt;/li&gt;&lt;li&gt;$f'(x) =\n#&gt; -24pi*sin(3pi x + 4)$&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;img\n#&gt; src='images/translating/calculus_cat.png' width='100' height='100'\n#&gt; /&gt;&lt;/body&gt;\n\n\nCheck\nPop quiz!What is the derivative of $f(x) = 1 + 2cos(3pi x + 4)$?$f'(x) = 6pi*sin(3pi x + 4)$$f'(x) = -6pi*sin(3pi x + 4)$$f'(x) = 24pi*sin(3pi x + 4)$$f'(x) = -24pi*sin(3pi x + 4)$"
  },
  {
    "objectID": "slides/21.html#latex",
    "href": "slides/21.html#latex",
    "title": "Translating R code",
    "section": "LaTeX",
    "text": "LaTeX\n\nlatex &lt;- function(x) structure(x, class = \"advr_latex\")\nprint.advr_latex &lt;- function(x) { cat(\"&lt;LATEX&gt; \", x, \"\\n\", sep = \"\") }\n\nto_math\n\nto_math &lt;- function(x) {\n  expr &lt;- enexpr(x)\n  latex(              #return LaTeX code\n    eval_bare(        #eval_bare to ensure use of latex environment \n      expr,           #expression (not quosure)\n      latex_env(expr) #need to define latex_env\n    ))\n}"
  },
  {
    "objectID": "slides/21.html#known-symbols",
    "href": "slides/21.html#known-symbols",
    "title": "Translating R code",
    "section": "Known Symbols",
    "text": "Known Symbols\n\ngreek_letters &lt;- c(\n  \"alpha\", \"beta\", \"chi\", \"delta\", \"Delta\", \"epsilon\", \"eta\", \n\"gamma\", \"Gamma\", \"iota\", \"kappa\", \"lambda\", \"Lambda\", \"mu\", \n\"nu\", \"omega\", \"Omega\", \"phi\", \"Phi\", \"pi\", \"Pi\", \"psi\", \"Psi\", \n\"rho\", \"sigma\", \"Sigma\", \"tau\", \"theta\", \"Theta\", \"upsilon\", \n\"Upsilon\", \"varepsilon\", \"varphi\", \"varrho\", \"vartheta\", \"xi\", \n\"Xi\", \"zeta\"\n)\n\ngreek_env &lt;- rlang::as_environment(\n  rlang::set_names(\n    paste0(\"\\\\\", greek_letters), #latex values\n    greek_letters                #R names\n  )\n)\n\n\nstr(as.list(greek_env))\n\n#&gt; List of 38\n#&gt;  $ zeta      : chr \"\\\\zeta\"\n#&gt;  $ Xi        : chr \"\\\\Xi\"\n#&gt;  $ xi        : chr \"\\\\xi\"\n#&gt;  $ vartheta  : chr \"\\\\vartheta\"\n#&gt;  $ varrho    : chr \"\\\\varrho\"\n#&gt;  $ varphi    : chr \"\\\\varphi\"\n#&gt;  $ varepsilon: chr \"\\\\varepsilon\"\n#&gt;  $ Upsilon   : chr \"\\\\Upsilon\"\n#&gt;  $ upsilon   : chr \"\\\\upsilon\"\n#&gt;  $ Theta     : chr \"\\\\Theta\"\n#&gt;  $ theta     : chr \"\\\\theta\"\n#&gt;  $ tau       : chr \"\\\\tau\"\n#&gt;  $ Sigma     : chr \"\\\\Sigma\"\n#&gt;  $ sigma     : chr \"\\\\sigma\"\n#&gt;  $ rho       : chr \"\\\\rho\"\n#&gt;  $ Psi       : chr \"\\\\Psi\"\n#&gt;  $ psi       : chr \"\\\\psi\"\n#&gt;  $ Pi        : chr \"\\\\Pi\"\n#&gt;  $ pi        : chr \"\\\\pi\"\n#&gt;  $ Phi       : chr \"\\\\Phi\"\n#&gt;  $ phi       : chr \"\\\\phi\"\n#&gt;  $ Omega     : chr \"\\\\Omega\"\n#&gt;  $ omega     : chr \"\\\\omega\"\n#&gt;  $ nu        : chr \"\\\\nu\"\n#&gt;  $ mu        : chr \"\\\\mu\"\n#&gt;  $ Lambda    : chr \"\\\\Lambda\"\n#&gt;  $ lambda    : chr \"\\\\lambda\"\n#&gt;  $ kappa     : chr \"\\\\kappa\"\n#&gt;  $ iota      : chr \"\\\\iota\"\n#&gt;  $ Gamma     : chr \"\\\\Gamma\"\n#&gt;  $ gamma     : chr \"\\\\gamma\"\n#&gt;  $ eta       : chr \"\\\\eta\"\n#&gt;  $ epsilon   : chr \"\\\\epsilon\"\n#&gt;  $ Delta     : chr \"\\\\Delta\"\n#&gt;  $ delta     : chr \"\\\\delta\"\n#&gt;  $ chi       : chr \"\\\\chi\"\n#&gt;  $ beta      : chr \"\\\\beta\"\n#&gt;  $ alpha     : chr \"\\\\alpha\""
  },
  {
    "objectID": "slides/21.html#known-functions",
    "href": "slides/21.html#known-functions",
    "title": "Translating R code",
    "section": "Known Functions",
    "text": "Known Functions\nUnary Operations\n\nunary_op &lt;- function(left, right) {\n  new_function(\n    exprs(e1 = ),\n    expr(\n      paste0(!!left, e1, !!right)\n    ),\n    caller_env()\n  )\n}\n\n\n#example\nunary_op(\"\\\\sqrt{\", \"}\")\n\n#&gt; function (e1) \n#&gt; paste0(\"\\\\sqrt{\", e1, \"}\")\n\n\nBinary Operations\n\nbinary_op &lt;- function(sep) {\n  new_function(\n    exprs(e1 = , e2 = ),\n    expr(\n      paste0(e1, !!sep, e2)\n    ),\n    caller_env()\n  )\n}\n\n\n#example\nbinary_op(\"+\")\n\n#&gt; function (e1, e2) \n#&gt; paste0(e1, \"+\", e2)\n\n\n\n\nEven more LaTeX syntax\n\n\nknown_func_env &lt;- child_env(\n  .parent = empty_env(),\n  \n  # Binary operators\n  `+` = binary_op(\" + \"),\n  `-` = binary_op(\" - \"),\n  `*` = binary_op(\" * \"),\n  `/` = binary_op(\" / \"),\n  `^` = binary_op(\"^\"),\n  `[` = binary_op(\"_\"),\n\n  # Grouping\n  `{` = unary_op(\"\\\\left{ \", \" \\\\right}\"),\n  `(` = unary_op(\"\\\\left( \", \" \\\\right)\"),\n  paste = paste,\n\n  # Other math functions\n  sqrt = unary_op(\"\\\\sqrt{\", \"}\"),\n  sin =  unary_op(\"\\\\sin(\", \")\"),\n  cos =  unary_op(\"\\\\cos(\", \")\"),\n  tan =  unary_op(\"\\\\tan(\", \")\"),\n  log =  unary_op(\"\\\\log(\", \")\"),\n  abs =  unary_op(\"\\\\left| \", \"\\\\right| \"),\n  frac = function(a, b) {\n    paste0(\"\\\\frac{\", a, \"}{\", b, \"}\")\n  },\n\n  # Labelling\n  hat =   unary_op(\"\\\\hat{\", \"}\"),\n  tilde = unary_op(\"\\\\tilde{\", \"}\")\n)"
  },
  {
    "objectID": "slides/21.html#unknown-symbols",
    "href": "slides/21.html#unknown-symbols",
    "title": "Translating R code",
    "section": "Unknown Symbols",
    "text": "Unknown Symbols\n\nnames_grabber &lt;- function(x) {\n  switch_expr(x,\n              constant = character(),\n              symbol =   as.character(x),\n              call =     flat_map_chr(as.list(x[-1]), names_grabber)\n  ) |&gt;\n    unique()\n}\n\n\\[x + y + f(a, b, c, 10)\\]\n\nnames_grabber(expr(x + y + f(a, b, c, 10)))\n\n#&gt; [1] \"x\" \"y\" \"a\" \"b\" \"c\"\n\n\n\nlobstr::ast(expr(x + y + f(a, b, c, 10)))\n\n#&gt; ‚ñà‚îÄexpr \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`+` \n#&gt;   ‚îú‚îÄ‚ñà‚îÄ`+` \n#&gt;   ‚îÇ ‚îú‚îÄx \n#&gt;   ‚îÇ ‚îî‚îÄy \n#&gt;   ‚îî‚îÄ‚ñà‚îÄf \n#&gt;     ‚îú‚îÄa \n#&gt;     ‚îú‚îÄb \n#&gt;     ‚îú‚îÄc \n#&gt;     ‚îî‚îÄ10"
  },
  {
    "objectID": "slides/21.html#unknown-functions",
    "href": "slides/21.html#unknown-functions",
    "title": "Translating R code",
    "section": "Unknown Functions",
    "text": "Unknown Functions\n\ncalls_grabber &lt;- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol =   character(),\n    call = {\n      fname &lt;- as.character(x[[1]])\n      children &lt;- flat_map_chr(as.list(x[-1]), calls_grabber)\n      c(fname, children)\n    }\n  ) |&gt;\n    unique()\n}\n\n\\[f(g + b, c, d(a))\\]\n\nnames_grabber(expr(f(g + b, c, d(a))))\n\n#&gt; [1] \"g\" \"b\" \"c\" \"a\"\n\ncalls_grabber(expr(f(g + b, c, d(a))))\n\n#&gt; [1] \"f\" \"+\" \"d\"\n\nlobstr::ast(expr(f(g + b, c, d(a))))\n\n#&gt; ‚ñà‚îÄexpr \n#&gt; ‚îî‚îÄ‚ñà‚îÄf \n#&gt;   ‚îú‚îÄ‚ñà‚îÄ`+` \n#&gt;   ‚îÇ ‚îú‚îÄg \n#&gt;   ‚îÇ ‚îî‚îÄb \n#&gt;   ‚îú‚îÄc \n#&gt;   ‚îî‚îÄ‚ñà‚îÄd \n#&gt;     ‚îî‚îÄa"
  },
  {
    "objectID": "slides/21.html#bringing-the-latex-together",
    "href": "slides/21.html#bringing-the-latex-together",
    "title": "Translating R code",
    "section": "Bringing the LaTeX Together",
    "text": "Bringing the LaTeX Together\n\nlatex_env &lt;- function(expr) {\n  \n  # Unknown Functions\n  calls &lt;- calls_grabber(expr)\n  call_list &lt;- map(set_names(calls), seek_closure)\n  call_env &lt;- as_environment(call_list)\n\n  # Known Functions\n  known_func_env &lt;- env_clone(known_func_env, call_env)\n\n  # Unknown Symbols\n  names &lt;- names_grabber(expr)\n  symbol_env &lt;- as_environment(set_names(names), parent = known_func_env)\n\n  # Known symbols\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\n\nto_math &lt;- function(x) {\n  expr &lt;- enexpr(x)\n  latex(              #return LaTeX code\n    eval_bare(        #eval_bare to ensure use of latex environment \n      expr,           #expression (not quosure)\n      latex_env(expr) #need to define latex_env\n    ))\n}\n\nCheck\n\nto_math(sin(pi) + f(a))\n\n#&gt; &lt;LATEX&gt; \\sin(\\pi) + \\mathrm{f}(a)"
  },
  {
    "objectID": "slides/21.html#finishing-the-example",
    "href": "slides/21.html#finishing-the-example",
    "title": "Translating R code",
    "section": "Finishing the Example",
    "text": "Finishing the Example\n(TO DO)"
  },
  {
    "objectID": "slides/19.html#learning-objectives",
    "href": "slides/19.html#learning-objectives",
    "title": "Quasiquotation",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nWhat quasiquotation means\nWhy it‚Äôs important\nLearn some practical uses\n\n\nlibrary(rlang)\nlibrary(purrr)"
  },
  {
    "objectID": "slides/19.html#introduction",
    "href": "slides/19.html#introduction",
    "title": "Quasiquotation",
    "section": "Introduction",
    "text": "Introduction\nThree pillars of tidy evaluation\n\nQuasiquotation\nQuosures (chapter 20)\nData masks (Chapter 20)\n\nQuasiquotation = quotation + unquotation\n\nQuote. Capture unevaluated expression‚Ä¶ (‚Äúdefuse‚Äù)\n\nUnquote. Evaluate selections of quoted expression! (‚Äúinject‚Äù)\nFunctions that use these features are said to use Non-standard evaluation (NSE)\nNote: related to Lisp macros, and also exists in other languages with Lisp heritage, e.g.¬†Julia\n\n\nOn it‚Äôs own, Quasiquotation good for programming, but combined with other tools, important for data analysis."
  },
  {
    "objectID": "slides/19.html#motivation",
    "href": "slides/19.html#motivation",
    "title": "Quasiquotation",
    "section": "Motivation",
    "text": "Motivation\nSimple concrete example:\ncement() is a function that works like paste() but doesn‚Äôt need need quotes\n(Think of automatically adding ‚Äòquotes‚Äô to the arguments)\n\ncement &lt;- function(...) {\n  args &lt;- ensyms(...)\n  paste(purrr::map(args, as_string), collapse = \" \")\n}\n\ncement(Good, morning, Hadley)\n\n#&gt; [1] \"Good morning Hadley\"\n\n\nWhat if we wanted to use variables? What is an object and what should be quoted?\nThis is where ‚Äòunquoting‚Äô comes in!\n\nname &lt;- \"Bob\"\ncement(Good, afternoon, !!name) # Bang-bang!\n\n#&gt; [1] \"Good afternoon Bob\""
  },
  {
    "objectID": "slides/19.html#vocabulary",
    "href": "slides/19.html#vocabulary",
    "title": "Quasiquotation",
    "section": "Vocabulary",
    "text": "Vocabulary\nCan think of cement() and paste() as being ‚Äòmirror-images‚Äô of each other.\n\npaste() - define what to quote - Evaluates arguments\ncement() - define what to unquote - Quotes arguments\n\nQuoting function similar to, but more precise than, Non-standard evaluation (NSE)\n\nTidyverse functions - e.g., dplyr::mutate(), tidyr::pivot_longer()\nBase functions - e.g., library(), subset(), with()\n\nQuoting function arguments cannot be evaluated outside of function:\n\ncement(Good, afternoon, Cohort) # No problem\n\n#&gt; [1] \"Good afternoon Cohort\"\n\nGood      # Error!\n\n#&gt; Error: object 'Good' not found\n\n\nNon-quoting (standard) function arguments can be evaluated:\n\npaste(\"Good\", \"afternoon\", \"Cohort\")\n\n#&gt; [1] \"Good afternoon Cohort\"\n\n\"Good\"\n\n#&gt; [1] \"Good\""
  },
  {
    "objectID": "slides/19.html#quoting",
    "href": "slides/19.html#quoting",
    "title": "Quasiquotation",
    "section": "Quoting",
    "text": "Quoting\nCapture expressions without evaluating them\n\n\n#&gt; Warning in body[[col]][rows][!is.na(result)] &lt;- omit_na(result): number of\n#&gt; items to replace is not a multiple of replacement length\n\n\n\n\n\n\n\n\n\nDeveloper\nUser\n\n\n\n\nExpression (Quasiquotation)\n\n\nOne\nexpr()\nenexpr()\n\n\nMany\nexprs()\nenexprs()\n\n\nSymbol (Quasiquotation)\n\n\nOne\nexpr()\nensym()\n\n\nMany\nexprs()\nensyms()\n\n\nR Base (Quotation)\n\n\nOne\nquote()\nalist()\n\n\nMany\nsubstitute()\nas.list(substitute(...()))\n\n\n\n\n\n\n\n\nNon-base functions are from rlang\nDeveloper - From you, direct, fixed, interactive\nUser - From the user, indirect, varying, programmatic\n\nAlso:\n\nbquote() provides a limited form of quasiquotation\n~, the formula, is a quoting function (see Section 20.3.4)\n\nexpr() and exprs()\n\nexpr(x + y)\n\n#&gt; x + y\n\nexprs(exp1 = x + y, exp2 = x * y)\n\n#&gt; $exp1\n#&gt; x + y\n#&gt; \n#&gt; $exp2\n#&gt; x * y\n\n\nenexpr()1 and enexprs()\n\nf &lt;- function(x) enexpr(x)\nf(a + b + c)\n\n#&gt; a + b + c\n\nf2 &lt;- function(x, y) enexprs(exp1 = x, exp2 = y)\nf2(x = a + b, y = c + d)\n\n#&gt; $exp1\n#&gt; a + b\n#&gt; \n#&gt; $exp2\n#&gt; c + d\n\n\nensym() and ensyms()\n\nRemember: Symbol represents the name of an object. Can only be length 1.\nThese are stricter than enexpr/s()\n\n\nf &lt;- function(x) ensym(x)\nf(a)\n\n#&gt; a\n\nf2 &lt;- function(x, y) ensyms(sym1 = x, sym2 = y)\nf2(x = a, y = \"b\")\n\n#&gt; $sym1\n#&gt; a\n#&gt; \n#&gt; $sym2\n#&gt; b\n\n\nenexpr() = enrich expr()"
  },
  {
    "objectID": "slides/19.html#unquoting",
    "href": "slides/19.html#unquoting",
    "title": "Quasiquotation",
    "section": "Unquoting",
    "text": "Unquoting\nSelectively evaluate parts of an expression\n\nMerges ASTs with template\n1 argument !! (unquote, bang-bang)\n\nUnquoting a function call evaluates and returns results\nUnquoting a function (name) replaces the function (alternatively use call2())\n\n&gt;1 arguments !!! (unquote-splice, bang-bang-bang, triple bang)\n!! and !!! only work like this inside quoting function using rlang\n\nBasic unquoting\nOne argument\n\nx &lt;- expr(a + b)\ny &lt;- expr(c / d)\n\n\nexpr(f(x, y))      # No unquoting\n#&gt; f(x, y)\nexpr(f(!!x, !!y))  # Unquoting\n#&gt; f(a + b, c/d)\n\nMultiple arguments\n\nz &lt;- exprs(a + b, c + d)\nw &lt;- exprs(exp1 = a + b, exp2 = c + d)\n\n\nexpr(f(z))      # No unquoting\n#&gt; f(z)\nexpr(f(!!!z))   # Unquoting\n#&gt; f(a + b, c + d)\nexpr(f(!!!w))   # Unquoting when named\n#&gt; f(exp1 = a + b, exp2 = c + d)\n\nSpecial usages or cases\nFor example, get the AST of an expression\n\nlobstr::ast(x)\n#&gt; x\nlobstr::ast(!!x)\n#&gt; ‚ñà‚îÄ`+` \n#&gt; ‚îú‚îÄa \n#&gt; ‚îî‚îÄb\n\nUnquote function call\n\nexpr(f(!!mean(c(100, 200, 300)), y))\n#&gt; f(200, y)\n\nUnquote function\n\nf &lt;- expr(sd)\nexpr((!!f)(x))\n#&gt; sd(x)\nexpr((!!f)(!!x + !!y))\n#&gt; sd(a + b + c/d)"
  },
  {
    "objectID": "slides/19.html#non-quoting",
    "href": "slides/19.html#non-quoting",
    "title": "Quasiquotation",
    "section": "Non-quoting",
    "text": "Non-quoting\nOnly bquote() provides a limited form of quasiquotation.\nThe rest of base selectively uses or does not use quoting (rather than unquoting).\nFour basic forms of quoting/non-quoting:\n\nPair of functions - Quoting and non-quoting\n\ne.g., $ (quoting) and [[ (non-quoting)\n\nPair of Arguments - Quoting and non-quoting\n\ne.g., rm(...) (quoting) and rm(list = c(...)) (non-quoting)\n\nArg to control quoting\n\ne.g., library(rlang) (quoting) and library(pkg, character.only = TRUE) (where pkg &lt;- \"rlang\")\n\nQuote if evaluation fails\n\nhelp(var) - Quote, show help for var\nhelp(var) (where var &lt;- \"mean\") - No quote, show help for mean\nhelp(var) (where var &lt;- 10) - Quote fails, show help for var"
  },
  {
    "objectID": "slides/19.html#dot-dot-dot-when-using-with-quoting",
    "href": "slides/19.html#dot-dot-dot-when-using-with-quoting",
    "title": "Quasiquotation",
    "section": "‚Ä¶ (dot-dot-dot) [When using ‚Ä¶ with quoting]",
    "text": "‚Ä¶ (dot-dot-dot) [When using ‚Ä¶ with quoting]\n\nSometimes need to supply an arbitrary list of expressions or arguments in a function (...)\nBut need a way to use these when we don‚Äôt necessarily have the names\nRemember !! and !!! only work with functions that use rlang\nCan use list2(...) to turn ... into ‚Äútidy dots‚Äù which can be unquoted and spliced\nRequire list2() if going to be passing or using !! or !!! in ...\nlist2() is a wrapper around dots_list() with the most common defaults\n\nNo need for list2()\n\nd &lt;- function(...) data.frame(list(...))\nd(x = c(1:3), y = c(2, 4, 6))\n#&gt;   x y\n#&gt; 1 1 2\n#&gt; 2 2 4\n#&gt; 3 3 6\n\nRequire list2()\n\nvars &lt;- list(x = c(1:3), y = c(2, 4, 6))\nd(!!!vars)\n#&gt; Error in !vars: invalid argument type\nd2 &lt;- function(...) data.frame(list2(...))\nd2(!!!vars)\n#&gt;   x y\n#&gt; 1 1 2\n#&gt; 2 2 4\n#&gt; 3 3 6\n# Same result but x and y evaluated later\nvars_expr &lt;- exprs(x = c(1:3), y = c(2, 4, 6))\nd2(!!!vars_expr)  \n#&gt;   x y\n#&gt; 1 1 2\n#&gt; 2 2 4\n#&gt; 3 3 6\n\nGetting argument names (symbols) from variables\n\nnm &lt;- \"z\"\nval &lt;- letters[1:4]\nd2(x = 1:4, !!nm := val)\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n#&gt; 4 4 d"
  },
  {
    "objectID": "slides/19.html#exec-making-your-own",
    "href": "slides/19.html#exec-making-your-own",
    "title": "Quasiquotation",
    "section": "exec() [Making your own ‚Ä¶]",
    "text": "exec() [Making your own ‚Ä¶]\nWhat if your function doesn‚Äôt have tidy dots?\nCan‚Äôt use !! or := if doesn‚Äôt support rlang or dynamic dots\n\nmy_mean &lt;- function(x, arg_name, arg_val) {\n  mean(x, !!arg_name := arg_val)\n}\n\nmy_mean(c(NA, 1:10), arg_name = \"na.rm\", arg_val = TRUE)     \n#&gt; Error in `my_mean()`:\n#&gt; ! `:=` can only be used within dynamic dots.\n\nLet‚Äôs use the ‚Ä¶ from exec()\n\nexec(.fn, ..., .env = caller_env())\n\n\nmy_mean &lt;- function(x, arg_name, arg_val) {\n  exec(\"mean\", x, !!arg_name := arg_val)\n}\n\nmy_mean(c(NA, 1:10), arg_name = \"na.rm\", arg_val = TRUE)     \n#&gt; [1] 5.5\n\nNote that you do not unquote arg_val.\nAlso exec is useful for mapping over a list of functions:\n\nx &lt;- c(runif(10), NA)\nfuns &lt;- c(\"mean\", \"median\", \"sd\")\npurrr::map_dbl(funs, exec, x, na.rm = TRUE)\n\n#&gt; [1] 0.4445205 0.4886247 0.3166360"
  },
  {
    "objectID": "slides/19.html#base-r-do.call",
    "href": "slides/19.html#base-r-do.call",
    "title": "Quasiquotation",
    "section": "Base R do.call",
    "text": "Base R do.call\ndo.call(what, args)\n\nwhat is a function to call\nargs is a list of arguments to pass to the function.\n\n\nnrow(mtcars)\n#&gt; [1] 32\nmtcars3 &lt;- do.call(\"rbind\", list(mtcars, mtcars, mtcars))\nnrow(mtcars3)\n#&gt; [1] 96\n\nExercise 19.5.5 #1\nOne way to implement exec is shown here: Describe how it works. What are the key ideas?\n\nexec_ &lt;- function(f, ..., .env = caller_env()){\n  args &lt;- list2(...)\n  do.call(f, args, envir  = .env)\n}"
  },
  {
    "objectID": "slides/19.html#case-studies-side-note",
    "href": "slides/19.html#case-studies-side-note",
    "title": "Quasiquotation",
    "section": "Case Studies (side note)",
    "text": "Case Studies (side note)\nSometimes you want to run a bunch of models, without having to copy/paste each one.\nBUT, you also want the summary function to show the appropriate model call, not one with hidden variables (e.g., lm(y ~ x, data = data)).\nWe can achieve this by building expressions and unquoting as needed:\n\nlibrary(purrr)\n\nvars &lt;- data.frame(x = c(\"hp\", \"hp\"),\n                   y = c(\"mpg\", \"cyl\"))\n\nx_sym &lt;- syms(vars$x)\ny_sym &lt;- syms(vars$y)\n\nformulae &lt;- map2(x_sym, y_sym, \\(x, y) expr(!!y ~ !!x))\nformulae\n#&gt; [[1]]\n#&gt; mpg ~ hp\n#&gt; \n#&gt; [[2]]\n#&gt; cyl ~ hp\nmodels &lt;- map(formulae, \\(f) expr(lm(!!f, data = mtcars)))\nsummary(eval(models[[1]]))\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ hp, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;     Min      1Q  Median      3Q     Max \n#&gt; -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\n#&gt; hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.863 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n#&gt; F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\nAs a function:\n\nlm_df &lt;- function(df, data) {\n  x_sym &lt;- map(df$x, as.symbol)\n  y_sym &lt;- map(df$y, as.symbol)\n  data &lt;- enexpr(data)\n  \n  formulae &lt;- map2(x_sym, y_sym, \\(x, y) expr(!!y ~ !!x))\n  models &lt;- map(formulae, \\(f) expr(lm(!!f, !!data)))\n  \n  map(models, \\(m) summary(eval(m)))\n}\n\nvars &lt;- data.frame(x = c(\"hp\", \"hp\"),\n                   y = c(\"mpg\", \"cyl\"))\nlm_df(vars, data = mtcars)\n#&gt; [[1]]\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ hp, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;     Min      1Q  Median      3Q     Max \n#&gt; -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\n#&gt; hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.863 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n#&gt; F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = cyl ~ hp, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;      Min       1Q   Median       3Q      Max \n#&gt; -2.27078 -0.74879 -0.06417  0.63512  1.74067 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) 3.006795   0.425485   7.067 7.41e-08 ***\n#&gt; hp          0.021684   0.002635   8.229 3.48e-09 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 1.006 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.693,  Adjusted R-squared:  0.6827 \n#&gt; F-statistic: 67.71 on 1 and 30 DF,  p-value: 3.478e-09"
  },
  {
    "objectID": "slides/17.html#learning-objectives",
    "href": "slides/17.html#learning-objectives",
    "title": "Big picture",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nBecome familiar with some metaprogramming principals and how they relate to each other\nReview vocabulary associated with metaprogramming\n\n\nlibrary(rlang)\nlibrary(lobstr)"
  },
  {
    "objectID": "slides/17.html#code-is-data",
    "href": "slides/17.html#code-is-data",
    "title": "Big picture",
    "section": "Code is data",
    "text": "Code is data\n\nexpression - Captured code (call, symbol, constant, or pairlist)\nUse rlang::expr()1 to capture code directly\n\n\nexpr(mean(x, na.rm = TRUE))\n\n#&gt; mean(x, na.rm = TRUE)\n\n\n\nUse rlang::enexpr() to capture code indirectly\n\n\ncapture_it &lt;- function(x) { # 'automatically quotes first argument'\n  enexpr(x)\n}\ncapture_it(a + b + c)\n\n#&gt; a + b + c\n\n\n\n‚ÄòCaptured‚Äô code can be modified (like a list)!\n\nFirst element is the function, next elements are the arguments\n\n\n\nf &lt;- expr(f(x = 1, y = 2))\nnames(f)\n\n#&gt; [1] \"\"  \"x\" \"y\"\n\nff &lt;- fff &lt;- f   # Create two copies\n\nff$z &lt;- 3        # Add an argument to one\nfff[[2]] &lt;- NULL # Remove an argument from another\n\nf\n\n#&gt; f(x = 1, y = 2)\n\nff\n\n#&gt; f(x = 1, y = 2, z = 3)\n\nfff\n\n#&gt; f(y = 2)\n\n\n\nMore on this next week!\n\nEquivalent to base::bquote()"
  },
  {
    "objectID": "slides/17.html#code-is-a-tree",
    "href": "slides/17.html#code-is-a-tree",
    "title": "Big picture",
    "section": "Code is a tree",
    "text": "Code is a tree\n\nAbstract syntax tree (AST) - Almost every language represents code as a tree\nUse lobstr::ast() to inspect these code trees\n\n\nast(f1(f2(a, b), f3(1)))\n\n#&gt; ‚ñà‚îÄf1 \n#&gt; ‚îú‚îÄ‚ñà‚îÄf2 \n#&gt; ‚îÇ ‚îú‚îÄa \n#&gt; ‚îÇ ‚îî‚îÄb \n#&gt; ‚îî‚îÄ‚ñà‚îÄf3 \n#&gt;   ‚îî‚îÄ1\n\nast(1 + 2 * 3)\n\n#&gt; ‚ñà‚îÄ`+` \n#&gt; ‚îú‚îÄ1 \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`*` \n#&gt;   ‚îú‚îÄ2 \n#&gt;   ‚îî‚îÄ3"
  },
  {
    "objectID": "slides/17.html#code-can-generate-code",
    "href": "slides/17.html#code-can-generate-code",
    "title": "Big picture",
    "section": "Code can generate code",
    "text": "Code can generate code\n\nrlang::call2() creates function call\n\n\ncall2(\"f\", 1, 2, 3)\n\n#&gt; f(1, 2, 3)\n\n\n\nGoing backwards from the tree, can use functions to create calls\n\n\ncall2(\"f1\", call2(\"f2\", \"a\", \"b\"), call2(\"f3\", 1))\n\n#&gt; f1(f2(\"a\", \"b\"), f3(1))\n\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n\n#&gt; 1 + 2 * 3\n\n\n\n!! bang-bang - unquote operator\n\ninserts previously defined expressions into the current one\n\n\n\nxx &lt;- expr(x + x)\nyy &lt;- expr(y + y)\nexpr(xx / yy)     # Nope!\n\n#&gt; xx/yy\n\nexpr(!!xx / !!yy) # Yup!\n\n#&gt; (x + x)/(y + y)\n\n\n\ncv &lt;- function(var) {\n  var &lt;- enexpr(var)            # Get user's expression\n  expr(sd(!!var) / mean(!!var)) # Insert user's expression\n}\n\ncv(x)\n\n#&gt; sd(x)/mean(x)\n\ncv(x + y)\n\n#&gt; sd(x + y)/mean(x + y)\n\n\n\nAvoid paste() for building code\n\nProblems with non-syntactic names and precedence among expressions\n\n\n\n‚ÄúYou might think this is an esoteric concern, but not worrying about it when generating SQL code in web applications led to SQL injection attacks that have collectively cost billions of dollars.‚Äù"
  },
  {
    "objectID": "slides/17.html#evaluation-runs-code",
    "href": "slides/17.html#evaluation-runs-code",
    "title": "Big picture",
    "section": "Evaluation runs code",
    "text": "Evaluation runs code\n\nevaluate - run/execute an expression\nneed both expression and environment\neval() uses current environment if not set\nmanual evaluation means you can tweak the environment!\n\n\nxy &lt;- expr(x + y)\n\neval(xy, env(x = 1, y = 10))\n\n#&gt; [1] 11\n\neval(xy, env(x = 2, y = 100))\n\n#&gt; [1] 102"
  },
  {
    "objectID": "slides/17.html#customizing-evaluations-with-functions",
    "href": "slides/17.html#customizing-evaluations-with-functions",
    "title": "Big picture",
    "section": "Customizing evaluations with functions",
    "text": "Customizing evaluations with functions\n\nCan also bind names to functions in supplied environment\nAllows overriding function behaviour\nThis is how dplyr generates SQL for working with databases\n\nFor example‚Ä¶\n\nstring_math &lt;- function(x) {\n  e &lt;- env(\n    caller_env(),\n    `+` = function(x, y) paste(x, y),\n    `*` = function(x, y) strrep(x, y)\n  )\n\n  eval(enexpr(x), e)\n}\n\ncohort &lt;- 9\nstring_math(\"Hello\" + \"cohort\" + cohort)\n\n#&gt; [1] \"Hello cohort 9\"\n\nstring_math((\"dslc\" + \"is\" + \"awesome---\") * cohort)\n\n#&gt; [1] \"dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---dslc is awesome---\""
  },
  {
    "objectID": "slides/17.html#customizing-evaluation-with-data",
    "href": "slides/17.html#customizing-evaluation-with-data",
    "title": "Big picture",
    "section": "Customizing evaluation with data",
    "text": "Customizing evaluation with data\n\nLook for variables inside data frame\nData mask - typically a data frame\nuse rlang::eval_tidy() rather than eval()\n\n\ndf &lt;- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n\n#&gt; [1] 2 4 6 9 9\n\n\nCatch user input with enexpr()‚Ä¶\n\nwith2 &lt;- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n\n#&gt; [1] 2 4 6 9 9\n\n\nBut there‚Äôs a bug!\n\nEvaluates in environment inside with2(), but the expression likely refers to objects in the Global environment\n\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enexpr(expr), df)\n}\n\ndf &lt;- data.frame(x = 1:3)\na &lt;- 10\nwith2(df, x + a)\n\n#&gt; [1] 1001 1002 1003\n\n\n\nSolved with Quosures‚Ä¶"
  },
  {
    "objectID": "slides/17.html#quosures",
    "href": "slides/17.html#quosures",
    "title": "Big picture",
    "section": "Quosures",
    "text": "Quosures\n\nQuosures bundles expression with an environment\nUse enquo() instead of enexpr() (with eval_tidy())\n\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enquo(expr), df)\n}\n\ndf &lt;- data.frame(x = 1:3)\na &lt;- 10\nwith2(df, x + a)\n\n#&gt; [1] 11 12 13\n\n\n\n‚ÄúWhenever you use a data mask, you must always use enquo() instead of enexpr().\n\nThis comes back in Chapter 20.\nWhich environment is bundled?\n\nThe environment where the expression is created (i.e.¬†the parent of where enquo() is called)\n\nHere, the global environment\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eq &lt;- enquo(expr)\n  message(\"with2() Parent/Calling environment: \")\n  print(rlang::caller_env())\n  message(\"with2() environment: \")\n  print(rlang::current_env())\n  message(\"Quosure details: \")\n  print(eq)  # Print the details of the quosure\n  eval_tidy(eq, df)\n}\n\na &lt;- 10000\ndf &lt;- data.frame(x = 1:3)\nwith2(df, x + a)\n\n#&gt; with2() Parent/Calling environment:\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n#&gt; with2() environment:\n\n\n#&gt; &lt;environment: 0x0000018dede5ddd0&gt;\n\n\n#&gt; Quosure details:\n\n\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + a\n#&gt; env:  global\n\n\n#&gt; [1] 10001 10002 10003\n\n\nHere, the fun1() environment\n\nfun1 &lt;- function(df) {\n  a &lt;- 10\n  message(\"fun1() Parent/Calling environment: \")\n  print(rlang::caller_env())\n  message(\"fun1() environment: \")\n  print(rlang::current_env())\n  with2(df, x + a)\n}\n\na &lt;- 10000\ndf &lt;- data.frame(x = 1:3)\nfun1(df)\n\n#&gt; fun1() Parent/Calling environment:\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n#&gt; fun1() environment:\n\n\n#&gt; &lt;environment: 0x0000018df3e748f8&gt;\n\n\n#&gt; with2() Parent/Calling environment:\n\n\n#&gt; &lt;environment: 0x0000018df3e748f8&gt;\n\n\n#&gt; with2() environment:\n\n\n#&gt; &lt;environment: 0x0000018df3ebc698&gt;\n\n\n#&gt; Quosure details:\n\n\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + a\n#&gt; env:  0x0000018df3e748f8\n\n\n#&gt; [1] 11 12 13"
  },
  {
    "objectID": "slides/15.html#introduction",
    "href": "slides/15.html#introduction",
    "title": "S4",
    "section": "Introduction",
    "text": "Introduction\nObject consists of:\n\nSlots. Like fields in R6.\nMethods. Accessed through generics. Dispatched to particular methods.\n\nUses functions to define classes and their methods:\n\nsetClass(). Define class and its components.\nsetGenerics(). Define generic functions. Used to dispatch.\nsetMethods(). Define methods"
  },
  {
    "objectID": "slides/15.html#basics-overview",
    "href": "slides/15.html#basics-overview",
    "title": "S4",
    "section": "Basics overview",
    "text": "Basics overview\nSet class\nDefine the class:\n\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    age = \"numeric\"\n  )\n)\n\nCreate an instance of the class\n\njohn &lt;- new(\"Person\", name = \"John Smith\", age = NA_real_)\n\nSet generics\nDefine generic functions for setting and getting the age slot\n\n# get the value\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n\n#&gt; [1] \"age\"\n\n# set the value\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n\n#&gt; [1] \"age&lt;-\"\n\n\nSet methods\nDefine methods for the generics:\n\n# get the value\nsetMethod(\"age\", \"Person\", function(x) x@age)\n# set the value\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  x\n})\n\n# set the value\nage(john) &lt;- 50\n# get the value\nage(john)\n\n#&gt; [1] 50\n\n\nTo give a flavor, there is only one method per slot. In more realistic cases, there might be several methods."
  },
  {
    "objectID": "slides/15.html#details-on-defining-the-class",
    "href": "slides/15.html#details-on-defining-the-class",
    "title": "S4",
    "section": "Details on defining the class",
    "text": "Details on defining the class\nInheritance\n\nsetClass(\"Employee\", \n  contains = \"Person\", \n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nInstantiation\nCreate an instance of the class at two levels:\n\nFor developer (you): methods::new()\nFor user: constructor function\n\n\n# how user constructs an instance\nPerson &lt;- function(name, age = NA) {\n  age &lt;- as.double(age)\n  \n  # how the developer constructs an instance\n  new(\"Person\", name = name, age = age)\n}\n\nPerson(\"Someone\")\n\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Someone\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] NA\n\n\nValidation\nS4 objects\n\nCheck class of slot at creation\n\n\nPerson(mtcars)\n\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: invalid object for slot \"name\" in class \"Person\": got class \"data.frame\", should be or extend class \"character\"\n\n\n\nDo not check other things\n\n\nPerson(\"Hadley\", age = c(30, 37))\n\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] 30 37\n\n\nThat‚Äôs where validation comes in‚Äìat two stages:\n\nAt creation\nAt modification\n\nAt creation\n\nsetValidity(\"Person\", function(object) {\n  if (length(object@name) != length(object@age)) {\n    \"@name and @age must be same length\"\n  } else {\n    TRUE\n  }\n})\n\n#&gt; Class \"Person\" [in \".GlobalEnv\"]\n#&gt; \n#&gt; Slots:\n#&gt;                           \n#&gt; Name:       name       age\n#&gt; Class: character   numeric\n\nPerson(\"Hadley\", age = c(30, 37))\n\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: @name and @age must be same length\n\n\nAt modification\n\n# get value\nsetGeneric(\"name\", function(x) standardGeneric(\"name\"))\n\n#&gt; [1] \"name\"\n\nsetMethod(\"name\", \"Person\", function(x) x@name)\n\n# set value--and assess whether resulting object is valid\nsetGeneric(\"name&lt;-\", function(x, value) standardGeneric(\"name&lt;-\"))\n\n#&gt; [1] \"name&lt;-\"\n\nsetMethod(\"name&lt;-\", \"Person\", function(x, value) {\n  x@name &lt;- value\n  validObject(x)\n  x\n})\n\n# normal name; no problem\nname(john) &lt;- \"Jon Smythe\"\nname(john)\n\n#&gt; [1] \"Jon Smythe\"\n\n# invalid name; error thrown\nname(john) &lt;- letters\n\n#&gt; Error in validObject(x): invalid class \"Person\" object: @name and @age must be same length"
  },
  {
    "objectID": "slides/15.html#details-on-generics-and-methods",
    "href": "slides/15.html#details-on-generics-and-methods",
    "title": "S4",
    "section": "Details on generics and methods",
    "text": "Details on generics and methods\nDictate dispatch via signature\nSpecify function arguments to be used in determining method.\n\nsetGeneric(\"myGeneric\", \n  function(x, ..., verbose = TRUE) standardGeneric(\"myGeneric\"),\n  signature = \"x\"\n)\n\n#&gt; [1] \"myGeneric\"\n\n\nDefine generics\nGeneral form:\n\nsetMethod(\"myGeneric\", \"Person\", function(x) {\n  # method implementation\n})\n\nExample to print object:\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n      \"  Name: \", object@name, \"\\n\",\n      \"  Age:  \", object@age, \"\\n\",\n      sep = \"\"\n  )\n})\njohn\n\n#&gt; Person\n#&gt;   Name: Jon Smythe\n#&gt;   Age:  50\n\n\nExample to access slot:\n\nsetGeneric(\"name\", function(x) standardGeneric(\"name\"))\n\n#&gt; [1] \"name\"\n\nsetMethod(\"name\", \"Person\", function(x) x@name)\n\nname(john)\n\n#&gt; [1] \"Jon Smythe\"\n\n\nThis is how end users should access slots."
  },
  {
    "objectID": "slides/15.html#example-lubridateperiod",
    "href": "slides/15.html#example-lubridateperiod",
    "title": "S4",
    "section": "Example: lubridate::period()",
    "text": "Example: lubridate::period()\nDefine the class\n\nsetClass(\"Period\",\n  # inherits from these classes\n  contains = c(\"Timespan\", \"numeric\"),\n  # has slots for time components\n  slots = c(\n    year = \"numeric\", \n    month = \"numeric\", \n    day = \"numeric\",\n    hour = \"numeric\", \n    minute = \"numeric\"\n  ),\n  # defines prototype as period of zero duration for all slots\n  prototype = prototype(year = 0, month = 0, day = 0, hour = 0, minute = 0),\n  # check validity with `check_period` function; see section below\n  validity = check_period\n)\n\nSee source code here\nValidate object\nCheck whether object is valid‚Äìnotably if all arugments have the same length and are integers.\n\ncheck_period &lt;- function(object) {\n  # start with an empty vector of error messages\n  errors &lt;- character()\n\n  # check length of object's data\n  length(object@.Data) -&gt; n\n  # check length of each slot\n  lengths &lt;- c(\n    length(object@year), \n    length(object@month),\n    length(object@day), \n    length(object@hour), \n    length(object@minute)\n  )\n\n  # if length of any slot is different than overall length, compose error message\n  if (any(lengths != n)) {\n    msg &lt;- paste(\"Inconsistent lengths: year = \", lengths[1],\n      \", month = \", lengths[2],\n      \", day = \", lengths[3],\n      \", hour = \", lengths[4],\n      \", minute = \", lengths[5],\n      \", second = \", n,\n      sep = \"\"\n    )\n    # add just-composed error to vector of error messages\n    errors &lt;- c(errors, msg)\n  }\n\n  values &lt;- c(object@year, object@month, object@day, object@hour, object@minute)\n  values &lt;- na.omit(values)\n  if (sum(values - trunc(values))) {\n    msg &lt;- \"periods must have integer values\"\n    errors &lt;- c(errors, msg)\n  }\n\n  if (length(errors) == 0) {\n    TRUE\n  } else {\n    errors\n  }\n}\n\nSee source code here.\nSet methods\nShow period:\n\n#' @export\nsetMethod(\"show\", signature(object = \"Period\"), function(object) {\n  if (length(object@.Data) == 0) {\n    cat(\"&lt;Period[0]&gt;\\n\")\n  } else {\n    print(format(object))\n  }\n})\n\n#' @export\nformat.Period &lt;- function(x, ...) {\n  if (length(x) == 0) {\n    return(character())\n  }\n\n  show &lt;- paste(\n    x@year, \"y \", x@month, \"m \", x@day, \"d \",\n    x@hour, \"H \", x@minute, \"M \", x@.Data, \"S\",\n    sep = \"\"\n  )\n  start &lt;- regexpr(\"[-1-9]|(0\\\\.)\", show)\n  show &lt;- ifelse(start &gt; 0, substr(show, start, nchar(show)), \"0S\")\n\n  show[is.na(x)] &lt;- NA\n  show\n}\n\nSee source code here"
  },
  {
    "objectID": "slides/13.html#basics",
    "href": "slides/13.html#basics",
    "title": "S3",
    "section": "Basics",
    "text": "Basics\n\nHas class\nUses a generic function to decide on method\n\nmethod = implementation for a specific class\ndispatch = process of searching for right method"
  },
  {
    "objectID": "slides/13.html#classes",
    "href": "slides/13.html#classes",
    "title": "S3",
    "section": "Classes",
    "text": "Classes\nTheory:\nWhat is class?\n\nNo formal definition in S3\nSimply set class attribute\n\nHow to set class?\n\nAt time of object creation\nAfter object creation\n\n\n# at time of object creation\nx &lt;- structure(list(), class = \"my_class\")\n\n# after object creation\nx &lt;- list()\nclass(x) &lt;- \"my_class\"\n\nSome advice on style:\n\nRules: Can be any string\nAdvice: Consider using/including package name to avoid collision with name of another class (e.g., blob, which defines a single class; haven has labelled and haven_labelled)\nConvention: letters and _; avoid . since it might be confused as separator between generic and class name\n\nPractice:\nHow to compose a class in practice?\n\nConstructor, which helps the developer create new object of target class. Provide always.\nValidator, which checks that values in constructor are valid. May not be necessary for simple classes.\nHelper, which helps users create new objects of target class. May be relevant only for user-facing classes.\n\nConstructors\nHelp developers construct an object of the target class:\n\nnew_difftime &lt;- function(x = double(), units = \"secs\") {\n  # check inputs\n  # issue generic system error if unexpected type or value\n  stopifnot(is.double(x))\n  units &lt;- match.arg(units, c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))\n\n  # construct instance of target class\n  structure(x,\n    class = \"difftime\",\n    units = units\n  )\n}\n\nValidators\nContrast a constructor, aimed at quickly creating instances of a class, which only checks type of inputs ‚Ä¶\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\n# error messages are for system default and developer-facing\nnew_factor(1:5, \"a\")\n\n#&gt; Error in as.character.factor(x): malformed factor\n\n\n‚Ä¶ with a validator, aimed at emitting errors if inputs pose problems, which makes more expensive checks\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values &gt; 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\n# error messages are informative and user-facing\nvalidate_factor(new_factor(1:5, \"a\"))\n\n#&gt; Error: There must be at least as many `levels` as possible values in `x`\n\n\nMaybe there is a typo in the validate_factor() function? Do the integers need to start at 1 and be consecutive?\n\nIf not, then length(levels) &lt; max(values) should be length(levels) &lt; length(values), right?\nIf so, why do the integers need to start at 1 and be consecutive? And if they need to be as such, we should tell the user, right?\n\n\nvalidate_factor(new_factor(1:3, levels = c(\"a\", \"b\", \"c\")))\n\n#&gt; [1] a b c\n#&gt; Levels: a b c\n\nvalidate_factor(new_factor(10:12, levels = c(\"a\", \"b\", \"c\")))\n\n#&gt; Error: There must be at least as many `levels` as possible values in `x`\n\n\nHelpers\nSome desired virtues:\n\nHave the same name as the class\nCall the constructor and validator, if the latter exists.\nIssue error informative, user-facing error messages\nAdopt thoughtful/useful defaults or type conversion\n\nExercise 5 in 13.3.4\nQ: Read the documentation for utils::as.roman(). How would you write a constructor for this class? Does it need a validator? What might a helper do?\nA: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n  structure(x, class = \"roman\")\n}\n\nThe documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.\n\nvalidate_roman &lt;- function(x) {\n  values &lt;- unclass(x)\n  \n  if (any(values &lt; 1 | values &gt; 3899)) {\n    stop(\n      \"Roman numbers must fall between 1 and 3899.\",\n      call. = FALSE\n    )\n  }\n  x\n}\n\nFor convenience, we allow the user to also pass real values to a helper function.\n\nroman &lt;- function(x = integer()) {\n  x &lt;- as.integer(x)\n  \n  validate_roman(new_roman(x))\n}\n\n# Test\nroman(c(1, 753, 2024))\n\n#&gt; [1] I       DCCLIII MMXXIV\n\nroman(0)\n\n#&gt; Error: Roman numbers must fall between 1 and 3899."
  },
  {
    "objectID": "slides/13.html#generics-and-methods",
    "href": "slides/13.html#generics-and-methods",
    "title": "S3",
    "section": "Generics and methods",
    "text": "Generics and methods\nGeneric functions:\n\nConsist of a call to UseMethod()\nPass arguments from the generic to the dispatched method ‚Äúauto-magically‚Äù\n\n\nmy_new_generic &lt;- function(x) {\n  UseMethod(\"my_new_generic\")\n}\n\nMethod dispatch\n\nUseMethod() creates a vector of method names\nDispatch\n\nExamines all methods in the vector\nSelects a method\n\n\n\nx &lt;- Sys.Date()\nsloop::s3_dispatch(print(x))\n\n#&gt; =&gt; print.Date\n#&gt;  * print.default\n\n\nFinding methods\nWhile sloop::s3_dispatch() gives the specific method selected for a specific call, on can see the methods defined:\n\nFor a generic\n\n\nsloop::s3_methods_generic(\"mean\")\n\n#&gt; # A tibble: 7 √ó 4\n#&gt;   generic class      visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 mean    Date       TRUE    base               \n#&gt; 2 mean    default    TRUE    base               \n#&gt; 3 mean    difftime   TRUE    base               \n#&gt; 4 mean    POSIXct    TRUE    base               \n#&gt; 5 mean    POSIXlt    TRUE    base               \n#&gt; 6 mean    quosure    FALSE   registered S3method\n#&gt; 7 mean    vctrs_vctr FALSE   registered S3method\n\n\n\nFor a class\n\n\nsloop::s3_methods_class(\"ordered\")\n\n#&gt; # A tibble: 4 √ó 4\n#&gt;   generic       class   visible source             \n#&gt;   &lt;chr&gt;         &lt;chr&gt;   &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 as.data.frame ordered TRUE    base               \n#&gt; 2 Ops           ordered TRUE    base               \n#&gt; 3 relevel       ordered FALSE   registered S3method\n#&gt; 4 Summary       ordered TRUE    base\n\n\nCreating methods\nTwo rules:\n\nOnly write a method if you own the generic. Otherwise, bad manners.\nMethod must have same arguments as its generic‚Äìwith one important exception: ...\n\nExample from text:\nI thought it would be good for us to work through this problem.\n\nCarefully read the documentation for UseMethod() and explain why the following code returns the results that it does. What two usual rules of function evaluation does UseMethod() violate?\n\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\n\nx &lt;- 1\ny &lt;- 1\ng(x)\n\n#&gt; x y \n#&gt; 1 1\n\ng.default(x)\n\n#&gt; x y \n#&gt; 1 1\n\n\nExamples caught in the wild:\n\nhaven::zap_label, which removes column labels\ndplyr::mutate\ntidyr::pivot_longer"
  },
  {
    "objectID": "slides/13.html#object-styles",
    "href": "slides/13.html#object-styles",
    "title": "S3",
    "section": "Object styles",
    "text": "Object styles"
  },
  {
    "objectID": "slides/13.html#inheritance",
    "href": "slides/13.html#inheritance",
    "title": "S3",
    "section": "Inheritance",
    "text": "Inheritance\nThree ideas:\n\nClass is a vector of classes\n\n\nclass(ordered(\"x\"))\n\n#&gt; [1] \"ordered\" \"factor\"\n\nclass(Sys.time())\n\n#&gt; [1] \"POSIXct\" \"POSIXt\"\n\n\n\nDispatch moves through class vector until it finds a defined method\n\n\nsloop::s3_dispatch(print(ordered(\"x\")))\n\n#&gt;    print.ordered\n#&gt; =&gt; print.factor\n#&gt;  * print.default\n\n\n\nMethod can delegate to another method via NextMethod(), which is indicated by -&gt; as below:\n\n\nsloop::s3_dispatch(ordered(\"x\")[1])\n\n#&gt;    [.ordered\n#&gt; =&gt; [.factor\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\n\nNextMethod()\nConsider secret class that masks each character of the input with x in output\n\nnew_secret &lt;- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret &lt;- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\ny &lt;- new_secret(c(15, 1, 456))\ny\n\n#&gt; [1] \"xx\"  \"x\"   \"xxx\"\n\n\nNotice that the [ method is problematic in that it does not preserve the secret class. Additionally, it returns 15 as the first element instead of xx.\n\nsloop::s3_dispatch(y[1])\n\n#&gt;    [.secret\n#&gt;    [.default\n#&gt; =&gt; [ (internal)\n\ny[1]\n\n#&gt; [1] 15\n\n\nFix this with a [.secret method:\nThe first fix (not run) is inefficient because it creates a copy of y.\n\n# not run\n`[.secret` &lt;- function(x, i) {\n  x &lt;- unclass(x)\n  new_secret(x[i])\n}\n\nNextMethod() is more efficient.\n\n`[.secret` &lt;- function(x, i) {\n  # first, dispatch to `[`\n  # then, coerce subset value to `secret` class\n  new_secret(NextMethod())\n}\n\nNotice that [.secret is selected for dispatch, but that the method delegates to the internal [.\n\nsloop::s3_dispatch(y[1])\n\n#&gt; =&gt; [.secret\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\ny[1]\n\n#&gt; [1] \"xx\"\n\n\nAllowing subclassing\nContinue the example above to have a supersecret subclass that hides even the number of characters in the input (e.g., 123 -&gt; xxxxx, 12345678 -&gt; xxxxx, 1 -&gt; xxxxx).\nTo allow for this subclass, the constructor function needs to include two additional arguments:\n\n... for passing an arbitrary set of arguments to different subclasses\nclass for defining the subclass\n\n\nnew_secret &lt;- function(x, ..., class = character()) {\n  stopifnot(is.double(x))\n\n  structure(\n    x,\n    ...,\n    class = c(class, \"secret\")\n  )\n}\n\nTo create the subclass, simply invoke the parent class constructor inside of the subclass constructor:\n\nnew_supersecret &lt;- function(x) {\n  new_secret(x, class = \"supersecret\")\n}\n\nprint.supersecret &lt;- function(x, ...) {\n  print(rep(\"xxxxx\", length(x)))\n  invisible(x)\n}\n\nBut this means the subclass inherits all parent methods and needs to overwrite all parent methods with subclass methods that return the sublclass rather than the parent class.\nThere‚Äôs no easy solution to this problem in base R.\nThere is a solution in the vectors package: vctrs::vec_restore()"
  },
  {
    "objectID": "slides/11.html#learning-objectives",
    "href": "slides/11.html#learning-objectives",
    "title": "Function operators",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nDefine function operator\nExplore some existing function operators\nMake our own function operator"
  },
  {
    "objectID": "slides/11.html#introduction",
    "href": "slides/11.html#introduction",
    "title": "Function operators",
    "section": "Introduction",
    "text": "Introduction\n\n\nA function operator is a function that takes one (or more) functions as input and returns a function as output.\nFunction operators are a special case of function factories, since they return functions.\nThey are often used to wrap an existing function to provide additional capability, similar to python‚Äôs decorators.\n\n\nchatty &lt;- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    res &lt;- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\n\nf &lt;- function(x) x ^ 2\ns &lt;- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n\n#&gt; Processing 3\n#&gt; Processing 2\n#&gt; Processing 1\n\n\n#&gt; [1] 9 4 1"
  },
  {
    "objectID": "slides/11.html#existing-function-operators",
    "href": "slides/11.html#existing-function-operators",
    "title": "Function operators",
    "section": "Existing function operators",
    "text": "Existing function operators\nTwo function operator examples are purrr:safely() and memoise::memoise(). These can be found in purr and memoise:\n\nlibrary(purrr)\nlibrary(memoise)"
  },
  {
    "objectID": "slides/11.html#purrrsafely",
    "href": "slides/11.html#purrrsafely",
    "title": "Function operators",
    "section": "purrr::safely",
    "text": "purrr::safely\nCapturing Errors: turns errors into data!\n\nx &lt;- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\n\nmap_dbl(x, sum)\n#&gt; Error in .Primitive(\"sum\")(..., na.rm = na.rm): invalid 'type' (character) of\n#&gt; argument\n\n\n# note use of map (not map_dbl), safely returns a lisst\n\nout &lt;- map(x, safely(sum))\nstr(transpose(out))\n\n#&gt; List of 2\n#&gt;  $ result:List of 4\n#&gt;   ..$ : num 1.39\n#&gt;   ..$ : num 1.27\n#&gt;   ..$ : num 2.17\n#&gt;   ..$ : NULL\n#&gt;  $ error :List of 4\n#&gt;   ..$ : NULL\n#&gt;   ..$ : NULL\n#&gt;   ..$ : NULL\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\""
  },
  {
    "objectID": "slides/11.html#other-purrr-function-operators",
    "href": "slides/11.html#other-purrr-function-operators",
    "title": "Function operators",
    "section": "Other purrr function operators",
    "text": "Other purrr function operators\n\n\npurrr comes with three other function operators in a similar vein:\n\n  possibly(): returns a default value when there‚Äôs an error. It provides no way to tell if an error occured or not, so it‚Äôs best reserved for cases when there‚Äôs some obvious sentinel value (like NA).\n\n  quietly(): turns output, messages, and warning side-effects into output, message, and warning components of the output.\n\n  auto_browser(): automatically executes browser() inside the function when there‚Äôs an error."
  },
  {
    "objectID": "slides/11.html#memoisememoise",
    "href": "slides/11.html#memoisememoise",
    "title": "Function operators",
    "section": "memoise::memoise",
    "text": "memoise::memoise\nCaching computations: avoid repeated computations!\n\nslow_function &lt;- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n\n#&gt; [1] 3.054764\n\n\n#&gt;    user  system elapsed \n#&gt;    0.02    0.00    1.02\n\nsystem.time(print(slow_function(1)))\n\n#&gt; [1] 3.644634\n\n\n#&gt;    user  system elapsed \n#&gt;    0.00    0.00    1.03\n\n\n\nfast_function &lt;- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n\n#&gt; [1] 7.451108\n\n\n#&gt;    user  system elapsed \n#&gt;    0.00    0.00    1.01\n\nsystem.time(print(fast_function(1)))\n\n#&gt; [1] 7.451108\n\n\n#&gt;    user  system elapsed \n#&gt;    0.00    0.00    0.01\n\n\n\nBe careful about memoising impure functions!"
  },
  {
    "objectID": "slides/11.html#exercise",
    "href": "slides/11.html#exercise",
    "title": "Function operators",
    "section": "Exercise",
    "text": "Exercise\nHow does safely() work?\nThe source code looks like this:\n\nsafely\n\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) capture_error(.f(...), otherwise, quiet)\n#&gt; }\n#&gt; &lt;bytecode: 0x00000183867aacf0&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\n\nThe real work is done in capture_error which is defined in the package namespace. We can access it with the ::: operator. (Could also grab it from the function‚Äôs environment.)\n\npurrr:::capture_error\n\n#&gt; function (code, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     tryCatch(list(result = code, error = NULL), error = function(e) {\n#&gt;         if (!quiet) {\n#&gt;             message(\"Error: \", conditionMessage(e))\n#&gt;         }\n#&gt;         list(result = otherwise, error = e)\n#&gt;     })\n#&gt; }\n#&gt; &lt;bytecode: 0x0000018386817b60&gt;\n#&gt; &lt;environment: namespace:purrr&gt;"
  },
  {
    "objectID": "slides/11.html#case-study-make-your-own-function-operator",
    "href": "slides/11.html#case-study-make-your-own-function-operator",
    "title": "Function operators",
    "section": "Case study: make your own function operator",
    "text": "Case study: make your own function operator\n\nurls &lt;- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath &lt;- paste(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\n\nHere we make a function operator that add a little delay in reading each page:\n\ndelay_by &lt;- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\nsystem.time(delay_by(runif, 0.1)(100))\n\n#&gt;    user  system elapsed \n#&gt;    0.00    0.00    0.11\n\n\nAnd another to add a dot after nth invocation:\n\ndot_every &lt;- function(f, n) {\n  force(f)\n  force(n)\n  \n  i &lt;- 0\n  function(...) {\n    i &lt;&lt;- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\n\nwalk(1:100, dot_every(runif, 10))\n\n#&gt; ..........\n\n\nCan now use both of these function operators to express our desired result:\n\nwalk2(\n  urls, path, \n  download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1), \n  quiet = TRUE\n)"
  },
  {
    "objectID": "slides/11.html#exercise-1",
    "href": "slides/11.html#exercise-1",
    "title": "Function operators",
    "section": "Exercise",
    "text": "Exercise\n\nShould you memoise file.download? Why or why not?"
  },
  {
    "objectID": "slides/09.html#learning-objectives",
    "href": "slides/09.html#learning-objectives",
    "title": "Functionals",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nDefine functionals.\nUse the purrr::map() family of functionals.\nUse the purrr::walk() family of functionals.\nUse the purrr::reduce() and purrr::accumulate() family of functionals.\nUse purrr::safely() and purrr::possibly() to deal with failure.\n\n9.1. Introduction\n9.2. map()\n9.3. purrr style\n9.4. map_ variants\n9.5. reduce() and accumulate family of functions\n\nSome functions that weren‚Äôt covered"
  },
  {
    "objectID": "slides/09.html#what-are-functionals",
    "href": "slides/09.html#what-are-functionals",
    "title": "Functionals",
    "section": "What are functionals",
    "text": "What are functionals"
  },
  {
    "objectID": "slides/09.html#introduction",
    "href": "slides/09.html#introduction",
    "title": "Functionals",
    "section": "Introduction",
    "text": "Introduction\nFunctionals are functions that take function as input and return a vector as output. Functionals that you probably have used before are: apply(), lapply() or tapply().\n\nalternatives to loops\na functional is better than a for loop is better than while is better than repeat\n\nBenefits\n\nencourages function logic to be separated from iteration logic\ncan collapse into vectors/data frames easily"
  },
  {
    "objectID": "slides/09.html#map",
    "href": "slides/09.html#map",
    "title": "Functionals",
    "section": "Map",
    "text": "Map\nmap() has two arguments, a vector and a function. It performs the function on each element of the vector and returns a list. We can also pass in some additional argument into the function.\n\n\nsimple_map &lt;- function(x, f, ...) {\nout &lt;- vector(\"list\", length(x))\nfor (i in seq_along(x)) {\nout[[i]] &lt;- f(x[[i]], ...)\n}\nout\n}"
  },
  {
    "objectID": "slides/09.html#benefit-of-using-the-map-function-in-purrr",
    "href": "slides/09.html#benefit-of-using-the-map-function-in-purrr",
    "title": "Functionals",
    "section": "Benefit of using the map function in purrr",
    "text": "Benefit of using the map function in purrr\n\npurrr::map() is equivalent to lapply()\nreturns a list and is the most general\nthe length of the input == the length of the output\nmap() is more flexible, with additional arguments allowed\nmap() has a host of extensions"
  },
  {
    "objectID": "slides/09.html#atomic-vectors",
    "href": "slides/09.html#atomic-vectors",
    "title": "Functionals",
    "section": "Atomic vectors",
    "text": "Atomic vectors\n\nhas 4 variants to return atomic vectors\n\nmap_chr()\nmap_dbl()\nmap_int()\nmap_lgl()\n\n\n\ntriple &lt;- function(x) x * 3\nmap(.x=1:3, .f=triple)\n\n#&gt; [[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 9\n\nmap_dbl(.x=1:3, .f=triple)\n\n#&gt; [1] 3 6 9\n\nmap_lgl(.x=c(1, NA, 3), .f=is.na)\n\n#&gt; [1] FALSE  TRUE FALSE"
  },
  {
    "objectID": "slides/09.html#anonymous-functions-and-shortcuts",
    "href": "slides/09.html#anonymous-functions-and-shortcuts",
    "title": "Functionals",
    "section": "Anonymous functions and shortcuts",
    "text": "Anonymous functions and shortcuts\nAnonymous functions\n\nmap_dbl(.x=mtcars, .f=function(x) mean(x, na.rm = TRUE)) |&gt; \n  head()\n\n#&gt;        mpg        cyl       disp         hp       drat         wt \n#&gt;  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250\n\n\n\nthe ‚Äútwiddle‚Äù uses a twiddle ~ to set a formula\ncan use .x to reference the input map(.x = ..., .f = )\n\n\nmap_dbl(.x=mtcars,  .f=~mean(.x, na.rm = TRUE))\n\n\ncan be simplified further as\n\n\nmap_dbl(.x=mtcars, .f=mean, na.rm = TRUE)\n\n#&gt;        mpg        cyl       disp         hp       drat         wt       qsec \n#&gt;  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n#&gt;         vs         am       gear       carb \n#&gt;   0.437500   0.406250   3.687500   2.812500\n\n\n\nwhat happens when we try a handful of variants of the task at hand? (how many unique values are there for each variable?)\n\nNote that .x is the name of the first argument in map() (.f is the name of the second argument).\n\n# the task\nmap_dbl(mtcars, function(x) length(unique(x)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nmap_dbl(mtcars, function(unicorn) length(unique(unicorn)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nmap_dbl(mtcars, ~length(unique(.x)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nmap_dbl(mtcars, ~length(unique(..1)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nmap_dbl(mtcars, ~length(unique(.)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# not the task\nmap_dbl(mtcars, length)\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   32   32   32   32   32   32   32   32   32   32   32\n\nmap_dbl(mtcars, length(unique))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00\n\nmap_dbl(mtcars, 1)\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00\n\n\n\n#error\nmap_dbl(mtcars, length(unique()))\n\n#&gt; Error in unique.default(): argument \"x\" is missing, with no default\n\nmap_dbl(mtcars, ~length(unique(x)))\n\n#&gt; Error in `map_dbl()`:\n#&gt; ‚Ñπ In index: 1.\n#&gt; ‚Ñπ With name: mpg.\n#&gt; Caused by error in `.f()`:\n#&gt; ! object 'x' not found"
  },
  {
    "objectID": "slides/09.html#modify",
    "href": "slides/09.html#modify",
    "title": "Functionals",
    "section": "Modify",
    "text": "Modify\nSometimes we might want the output to be the same as the input, then in that case we can use the modify function rather than map\n\ndf &lt;- data.frame(x=1:3,y=6:4)\n\nmap(df, .f=~.x*3)\n\n#&gt; $x\n#&gt; [1] 3 6 9\n#&gt; \n#&gt; $y\n#&gt; [1] 18 15 12\n\nmodify(.x=df,.f=~.x*3)\n\n#&gt;   x  y\n#&gt; 1 3 18\n#&gt; 2 6 15\n#&gt; 3 9 12\n\n\nNote that modify() always returns the same type of output (which is not necessarily true with map()). Additionally, modify() does not actually change the value of df.\n\ndf\n\n#&gt;   x y\n#&gt; 1 1 6\n#&gt; 2 2 5\n#&gt; 3 3 4"
  },
  {
    "objectID": "slides/09.html#purrr-style",
    "href": "slides/09.html#purrr-style",
    "title": "Functionals",
    "section": "purrr style",
    "text": "purrr style\n\nmtcars |&gt; \n  map(head, 20) |&gt; # pull first 20 of each column\n  map_dbl(mean) |&gt; # mean of each vector\n  head()\n\n#&gt;       mpg       cyl      disp        hp      drat        wt \n#&gt;  20.13000   6.20000 233.93000 136.20000   3.54500   3.39845\n\n\nAn example from tidytuesday\n\ntt &lt;- tidytuesdayR::tt_load(\"2020-06-30\")\n\n# filter data & exclude columns with lost of nulls\nlist_df &lt;- \n  map(\n    .x = tt[1:3], \n    .f = \n      ~ .x |&gt; \n      filter(issue &lt;= 152 | issue &gt; 200) |&gt; \n      mutate(timeframe = ifelse(issue &lt;= 152, \"first 5 years\", \"last 5 years\")) |&gt; \n      select_if(~mean(is.na(.x)) &lt; 0.2) \n  )\n\n\n# write to global environment\niwalk(\n  .x = list_df,\n  .f = ~ assign(x = .y, value = .x, envir = globalenv())\n)"
  },
  {
    "objectID": "slides/09.html#map_-variants",
    "href": "slides/09.html#map_-variants",
    "title": "Functionals",
    "section": "map_*() variants",
    "text": "map_*() variants\nThere are many variants"
  },
  {
    "objectID": "slides/09.html#map2_",
    "href": "slides/09.html#map2_",
    "title": "Functionals",
    "section": "map2_*()",
    "text": "map2_*()\n\nraise each value .x by 2\n\n\nmap_dbl(\n  .x = 1:5, \n  .f = function(x) x ^ 2\n)\n\n#&gt; [1]  1  4  9 16 25\n\n\n\nraise each value .x by another value .y\n\n\nmap2_dbl(\n  .x = 1:5, \n  .y = 2:6, \n  .f = ~ (.x ^ .y)\n)\n\n#&gt; [1]     1     8    81  1024 15625"
  },
  {
    "objectID": "slides/09.html#the-benefit-of-using-the-map-over-apply-family-of-function",
    "href": "slides/09.html#the-benefit-of-using-the-map-over-apply-family-of-function",
    "title": "Functionals",
    "section": "The benefit of using the map over apply family of function",
    "text": "The benefit of using the map over apply family of function\n\nIt is written in C\nIt preserves names\nWe always know the return value type\nWe can apply the function for multiple input values\nWe can pass additional arguments into the function"
  },
  {
    "objectID": "slides/09.html#walk",
    "href": "slides/09.html#walk",
    "title": "Functionals",
    "section": "walk()",
    "text": "walk()\n\nWe use walk() when we want to call a function for it side effect(s) rather than its return value, like generating plots, write.csv(), or ggsave(). If you don‚Äôt want a return value, map() will print more info than you may want.\n\n\nmap(1:3, ~cat(.x, \"\\n\"))\n\n#&gt; 1 \n#&gt; 2 \n#&gt; 3\n\n\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL\n#&gt; \n#&gt; [[3]]\n#&gt; NULL\n\n\n\nfor these cases, use walk() instead\n\n\nwalk(1:3, ~cat(.x, \"\\n\"))\n\n#&gt; 1 \n#&gt; 2 \n#&gt; 3\n\n\ncat() does have a result, it‚Äôs just usually returned invisibly.\n\ncat(\"hello\")\n\n#&gt; hello\n\n(cat(\"hello\"))\n\n#&gt; hello\n\n\n#&gt; NULL\n\n\nWe can use pwalk() to save a list of plot to disk. Note that the ‚Äúp‚Äù in pwalk() means that we have more than 1 (or 2) variables to pipe into the function. Also note that the name of the first argument in all of the ‚Äúp‚Äù functions is now .l (instead of .x).\n\nplots &lt;- mtcars |&gt;  \n  split(mtcars$cyl) |&gt;  \n  map(~ggplot(.x, aes(mpg,wt)) +\n        geom_point())\n\npaths &lt;- stringr::str_c(names(plots), '.png')\n\npwalk(.l = list(paths,plots), .f = ggsave, path = tempdir())\n\n#&gt; Saving 7 x 5 in image\n#&gt; Saving 7 x 5 in image\n#&gt; Saving 7 x 5 in image\n\npmap(.l = list(paths,plots), .f = ggsave, path = tempdir())\n\n#&gt; Saving 7 x 5 in image\n#&gt; Saving 7 x 5 in image\n#&gt; Saving 7 x 5 in image\n\n\n#&gt; [[1]]\n#&gt; [1] \"C:\\\\Users\\\\jonth\\\\AppData\\\\Local\\\\Temp\\\\RtmpSMVSZz/4.png\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"C:\\\\Users\\\\jonth\\\\AppData\\\\Local\\\\Temp\\\\RtmpSMVSZz/6.png\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"C:\\\\Users\\\\jonth\\\\AppData\\\\Local\\\\Temp\\\\RtmpSMVSZz/8.png\"\n\n\n\nwalk, walk2 and pwalk all invisibly return .x the first argument. This makes them suitable for use in the middle of pipelines.\nnote: I don‚Äôt think that it is ‚Äú.x‚Äù (or ‚Äú.l‚Äù) that they are returning invisibly. But I‚Äôm not sure what it is. Hadley says:\n\n\npurrr provides the walk family of functions that ignore the return values of the .f and instead return .x invisibly.\n\nBut not in the first cat() example, it is the NULL values that get returned invisibly (those aren‚Äôt the same as .x)."
  },
  {
    "objectID": "slides/09.html#imap",
    "href": "slides/09.html#imap",
    "title": "Functionals",
    "section": "imap()",
    "text": "imap()\n\nimap() is like map2()except that .y is derived from names(.x) if named or seq_along(.x) if not.\nThese two produce the same result\n\n\nimap_chr(.x = mtcars, \n         .f = ~ paste(.y, \"has a mean of\", round(mean(.x), 1))) |&gt; \nhead()\n\n#&gt;                        mpg                        cyl \n#&gt;   \"mpg has a mean of 20.1\"    \"cyl has a mean of 6.2\" \n#&gt;                       disp                         hp \n#&gt; \"disp has a mean of 230.7\"   \"hp has a mean of 146.7\" \n#&gt;                       drat                         wt \n#&gt;   \"drat has a mean of 3.6\"     \"wt has a mean of 3.2\"\n\nmap2_chr(.x = mtcars, \n         .y = names(mtcars),\n         .f = ~ paste(.y, \"has a mean of\", round(mean(.x), 1))) |&gt; \nhead()\n\n#&gt;                        mpg                        cyl \n#&gt;   \"mpg has a mean of 20.1\"    \"cyl has a mean of 6.2\" \n#&gt;                       disp                         hp \n#&gt; \"disp has a mean of 230.7\"   \"hp has a mean of 146.7\" \n#&gt;                       drat                         wt \n#&gt;   \"drat has a mean of 3.6\"     \"wt has a mean of 3.2\""
  },
  {
    "objectID": "slides/09.html#pmap",
    "href": "slides/09.html#pmap",
    "title": "Functionals",
    "section": "pmap()",
    "text": "pmap()\n\nyou can pass a named list or dataframe as arguments to a function\nfor example runif() has the parameters n, min and max\n\n\nparams &lt;- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     1,    10,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n\n#&gt; [[1]]\n#&gt; [1] 9.52234\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 49.53679 46.47017\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 488.8100 796.6801 282.7772\n\n\n\ncould also be\n\n\nlist(\n  n = 1:3, \n  min = 10 ^ (0:2), \n  max = 10 ^ (1:3)\n) |&gt; \npmap(runif)\n\n#&gt; [[1]]\n#&gt; [1] 5.246834\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 73.39068 30.57879\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 169.6667 950.1126 820.9357\n\n\n\nI like to use expand_grid() when I want all possible parameter combinations.\n\n\nexpand_grid(n = 1:3,\n            min = 10 ^ (0:1),\n            max = 10 ^ (1:2))\n\n#&gt; # A tibble: 12 √ó 3\n#&gt;        n   min   max\n#&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1     1     1    10\n#&gt;  2     1     1   100\n#&gt;  3     1    10    10\n#&gt;  4     1    10   100\n#&gt;  5     2     1    10\n#&gt;  6     2     1   100\n#&gt;  7     2    10    10\n#&gt;  8     2    10   100\n#&gt;  9     3     1    10\n#&gt; 10     3     1   100\n#&gt; 11     3    10    10\n#&gt; 12     3    10   100\n\nexpand_grid(n = 1:3,\n            min = 10 ^ (0:1),\n            max = 10 ^ (1:2)) |&gt; \npmap(runif)\n\n#&gt; [[1]]\n#&gt; [1] 9.474848\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 10.63548\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 10\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 92.44257\n#&gt; \n#&gt; [[5]]\n#&gt; [1] 7.165047 6.201947\n#&gt; \n#&gt; [[6]]\n#&gt; [1] 64.79074 16.54110\n#&gt; \n#&gt; [[7]]\n#&gt; [1] 10 10\n#&gt; \n#&gt; [[8]]\n#&gt; [1] 62.12314 52.31713\n#&gt; \n#&gt; [[9]]\n#&gt; [1] 6.806213 5.541865 8.580469\n#&gt; \n#&gt; [[10]]\n#&gt; [1]  7.10806 51.56879 85.70133\n#&gt; \n#&gt; [[11]]\n#&gt; [1] 10 10 10\n#&gt; \n#&gt; [[12]]\n#&gt; [1] 74.48871 11.65879 58.31278"
  },
  {
    "objectID": "slides/09.html#reduce-family",
    "href": "slides/09.html#reduce-family",
    "title": "Functionals",
    "section": "reduce() family",
    "text": "reduce() family\nThe reduce() function is a powerful functional that allows you to abstract away from a sequence of functions that are applied in a fixed direction.\nreduce() takes a vector as its first argument, a function as its second argument, and an optional .init argument last. It will then apply the function repeatedly to the vector until there is only a single element left.\n(Hint: start at the top of the image and read down.)\n\nLet me really quickly demonstrate reduce() in action.\nSay you wanted to add up the numbers 1 through 5 using only the plus operator +. You could do something like:\n\n1 + 2 + 3 + 4 + 5\n\n#&gt; [1] 15\n\n\nWhich is the same as:\n\nreduce(1:5, `+`)\n\n#&gt; [1] 15\n\n\nAnd if you want the start value to be something that is not the first argument of the vector, pass that value to the .init argument:\n\nidentical(\n  0.5 + 1 + 2 + 3 + 4 + 5,\n  reduce(1:5, `+`, .init = 0.5)\n)\n\n#&gt; [1] TRUE"
  },
  {
    "objectID": "slides/09.html#ggplot2-example-with-reduce",
    "href": "slides/09.html#ggplot2-example-with-reduce",
    "title": "Functionals",
    "section": "ggplot2 example with reduce",
    "text": "ggplot2 example with reduce\n\nggplot(mtcars, aes(hp, mpg)) + \n  geom_point(size = 8, alpha = .5, color = \"yellow\") +\n  geom_point(size = 4, alpha = .5, color = \"red\") +\n  geom_point(size = 2, alpha = .5, color = \"blue\")\n\n\n\n\n\n\n\n\nLet us use the reduce() function. Note that reduce2() takes two arguments, but the first value (..1) is given by the .init value.\n\nreduce2(\n  c(8, 4, 2),\n  c(\"yellow\", \"red\", \"blue\"),\n  ~ ..1 + geom_point(size = ..2, alpha = .5, color = ..3),\n  .init = ggplot(mtcars, aes(hp, mpg))\n)\n\n\n\n\n\n\n\n\n\ndf &lt;- list(age=tibble(name='john',age=30),\n    sex=tibble(name=c('john','mary'),sex=c('M','F'),\n    trt=tibble(name='Mary',treatment='A')))\n\ndf\n\n#&gt; $age\n#&gt; # A tibble: 1 √ó 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 john     30\n#&gt; \n#&gt; $sex\n#&gt; # A tibble: 2 √ó 3\n#&gt;   name  sex   trt$name $treatment\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;     \n#&gt; 1 john  M     Mary     A         \n#&gt; 2 mary  F     Mary     A\n\ndf |&gt; reduce(.f = full_join)\n\n#&gt; Joining with `by = join_by(name)`\n\n\n#&gt; # A tibble: 2 √ó 4\n#&gt;   name    age sex   trt$name $treatment\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;     \n#&gt; 1 john     30 M     Mary     A         \n#&gt; 2 mary     NA F     Mary     A\n\nreduce(.x = df,.f = full_join)\n\n#&gt; Joining with `by = join_by(name)`\n\n\n#&gt; # A tibble: 2 √ó 4\n#&gt;   name    age sex   trt$name $treatment\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;     \n#&gt; 1 john     30 M     Mary     A         \n#&gt; 2 mary     NA F     Mary     A\n\n\n\nto see all intermediate steps, use accumulate()\n\n\nset.seed(1234)\naccumulate(1:5, `+`)\n\n#&gt; [1]  1  3  6 10 15\n\n\n\naccumulate2(\n  c(8, 4, 2),\n  c(\"yellow\", \"red\", \"blue\"),\n  ~ ..1 + geom_point(size = ..2, alpha = .5, color = ..3),\n  .init = ggplot(mtcars, aes(hp, mpg))\n)\n\n#&gt; [[1]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[2]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[3]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[4]]"
  },
  {
    "objectID": "slides/09.html#map_df-variants",
    "href": "slides/09.html#map_df-variants",
    "title": "Functionals",
    "section": "map_df*() variants",
    "text": "map_df*() variants\n\nmap_dfr() = row bind the results\nmap_dfc() = column bind the results\nNote that map_dfr() has been superseded by map() |&gt; list_rbind() and map_dfc() has been superseded by map() |&gt; list_cbind()\n\n\ncol_stats &lt;- function(n) {\n  head(mtcars, n) |&gt; \n    summarise_all(mean) |&gt; \n    mutate_all(floor) |&gt; \n    mutate(n = paste(\"N =\", n))\n}\n\nmap((1:2) * 10, col_stats)\n\n#&gt; [[1]]\n#&gt;   mpg cyl disp  hp drat wt qsec vs am gear carb      n\n#&gt; 1  20   5  208 122    3  3   18  0  0    3    2 N = 10\n#&gt; \n#&gt; [[2]]\n#&gt;   mpg cyl disp  hp drat wt qsec vs am gear carb      n\n#&gt; 1  20   6  233 136    3  3   18  0  0    3    2 N = 20\n\nmap_dfr((1:2) * 10, col_stats)\n\n#&gt;   mpg cyl disp  hp drat wt qsec vs am gear carb      n\n#&gt; 1  20   5  208 122    3  3   18  0  0    3    2 N = 10\n#&gt; 2  20   6  233 136    3  3   18  0  0    3    2 N = 20\n\nmap((1:2) * 10, col_stats) |&gt; list_rbind()\n\n#&gt;   mpg cyl disp  hp drat wt qsec vs am gear carb      n\n#&gt; 1  20   5  208 122    3  3   18  0  0    3    2 N = 10\n#&gt; 2  20   6  233 136    3  3   18  0  0    3    2 N = 20"
  },
  {
    "objectID": "slides/09.html#pluck",
    "href": "slides/09.html#pluck",
    "title": "Functionals",
    "section": "pluck()",
    "text": "pluck()\n\npluck() will pull a single element from a list\n\nI like the example from the book because the starting object is not particularly easy to work with (as many JSON objects might not be).\n\nmy_list &lt;- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\nmy_list\n\n#&gt; [[1]]\n#&gt; [[1]][[1]]\n#&gt; [1] -1\n#&gt; \n#&gt; [[1]]$x\n#&gt; [1] 1\n#&gt; \n#&gt; [[1]]$y\n#&gt; [1] 2\n#&gt; \n#&gt; [[1]]$z\n#&gt; [1] \"a\"\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; [[2]][[1]]\n#&gt; [1] -2\n#&gt; \n#&gt; [[2]]$x\n#&gt; [1] 4\n#&gt; \n#&gt; [[2]]$y\n#&gt; [1] 5 6\n#&gt; \n#&gt; [[2]]$z\n#&gt; [1] \"b\"\n#&gt; \n#&gt; \n#&gt; [[3]]\n#&gt; [[3]][[1]]\n#&gt; [1] -3\n#&gt; \n#&gt; [[3]]$x\n#&gt; [1] 8\n#&gt; \n#&gt; [[3]]$y\n#&gt; [1]  9 10 11\n\n\nNotice that the ‚Äúfirst element‚Äù means something different in standard pluck() versus mapped pluck().\n\npluck(my_list, 1)\n\n#&gt; [[1]]\n#&gt; [1] -1\n#&gt; \n#&gt; $x\n#&gt; [1] 1\n#&gt; \n#&gt; $y\n#&gt; [1] 2\n#&gt; \n#&gt; $z\n#&gt; [1] \"a\"\n\nmap(my_list, pluck, 1)\n\n#&gt; [[1]]\n#&gt; [1] -1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] -2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] -3\n\nmap_dbl(my_list, pluck, 1)\n\n#&gt; [1] -1 -2 -3\n\n\nThe map() functions also have shortcuts for extracting elements from vectors (powered by purrr::pluck()). Note that map(my_list, 3) is a shortcut for map(my_list, pluck, 3).\n\n# Select by name\nmap_dbl(my_list, \"x\")\n\n#&gt; [1] 1 4 8\n\n# Or by position\nmap_dbl(my_list, 1)\n\n#&gt; [1] -1 -2 -3\n\n# Or by both\nmap_dbl(my_list, list(\"y\", 1))\n\n#&gt; [1] 2 5 9\n\n# You'll get an error if you try to retrieve an inside item that doesn't have \n# a consistent format and you want a numeric output\nmap_dbl(my_list, list(\"y\"))\n\n#&gt; Error in `map_dbl()`:\n#&gt; ‚Ñπ In index: 2.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 2.\n\n# You'll get an error if a component doesn't exist:\nmap_chr(my_list, \"z\")\n\n#&gt; Error in `map_chr()`:\n#&gt; ‚Ñπ In index: 3.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\n#&gt; Error: Result 3 must be a single string, not NULL of length 0\n\n# Unless you supply a .default value\nmap_chr(my_list, \"z\", .default = NA)\n\n#&gt; [1] \"a\" \"b\" NA\n\n#&gt; [1] \"a\" \"b\" NA"
  },
  {
    "objectID": "slides/09.html#not-covered-flatten",
    "href": "slides/09.html#not-covered-flatten",
    "title": "Functionals",
    "section": "Not covered: flatten()",
    "text": "Not covered: flatten()\n\nflatten() will turn a list of lists into a simpler vector.\n\n\nmy_list &lt;-\n  list(\n    a = 1:3,\n    b = list(1:3)\n  )\n\nmy_list\n\n#&gt; $a\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $b\n#&gt; $b[[1]]\n#&gt; [1] 1 2 3\n\nmap_if(my_list, is.list, pluck)\n\n#&gt; $a\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $b\n#&gt; $b[[1]]\n#&gt; [1] 1 2 3\n\nmap_if(my_list, is.list, flatten_int)\n\n#&gt; $a\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $b\n#&gt; [1] 1 2 3\n\nmap_if(my_list, is.list, flatten_int) |&gt; \n  flatten_int()\n\n#&gt; [1] 1 2 3 1 2 3"
  },
  {
    "objectID": "slides/09.html#dealing-with-failures",
    "href": "slides/09.html#dealing-with-failures",
    "title": "Functionals",
    "section": "Dealing with Failures",
    "text": "Dealing with Failures"
  },
  {
    "objectID": "slides/09.html#safely",
    "href": "slides/09.html#safely",
    "title": "Functionals",
    "section": "Safely",
    "text": "Safely\nsafely() is an adverb. It takes a function (a verb) and returns a modified version. In this case, the modified function will never throw an error. Instead it always returns a list with two elements.\n\nresult is the original result. If there is an error this will be NULL\nerror is an error object. If the operation was successful the ‚Äúerror‚Äù will be NULL.\n\n\nA &lt;- list(1, 10, \"a\")\n\nmap(.x = A, .f = safely(log))\n\n#&gt; [[1]]\n#&gt; [[1]]$result\n#&gt; [1] 0\n#&gt; \n#&gt; [[1]]$error\n#&gt; NULL\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; [[2]]$result\n#&gt; [1] 2.302585\n#&gt; \n#&gt; [[2]]$error\n#&gt; NULL\n#&gt; \n#&gt; \n#&gt; [[3]]\n#&gt; [[3]]$result\n#&gt; NULL\n#&gt; \n#&gt; [[3]]$error\n#&gt; &lt;simpleError in .Primitive(\"log\")(x, base): non-numeric argument to mathematical function&gt;"
  },
  {
    "objectID": "slides/09.html#possibly",
    "href": "slides/09.html#possibly",
    "title": "Functionals",
    "section": "Possibly",
    "text": "Possibly\npossibly() always succeeds. It is simpler than safely(), because you can give it a default value to return when there is an error.\n\nA &lt;- list(1,10,\"a\")\n\nmap_dbl(.x = A, .f = possibly(log, otherwise = NA_real_) )\n\n#&gt; [1] 0.000000 2.302585       NA"
  },
  {
    "objectID": "slides/07.html#learning-objectives",
    "href": "slides/07.html#learning-objectives",
    "title": "Environments",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nTHESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY"
  },
  {
    "objectID": "slides/07.html#slide-1",
    "href": "slides/07.html#slide-1",
    "title": "Environments",
    "section": "SLIDE 1",
    "text": "SLIDE 1\n\nADD SLIDES AS SECTIONS (##).\nTRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF."
  },
  {
    "objectID": "slides/05.html#learning-objectives",
    "href": "slides/05.html#learning-objectives",
    "title": "Control flow",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nLearn the tools for controlling flow of execution.\nLearn some technical pitfalls and (perhaps lesser known) useful features."
  },
  {
    "objectID": "slides/05.html#introduction",
    "href": "slides/05.html#introduction",
    "title": "Control flow",
    "section": "Introduction",
    "text": "Introduction\nThere are two main groups of flow control tools: choices and loops:\n\nChoices (if, switch, ifelse, dplyr::if_else, dplyr::case_when) allow you to run different code depending on the input.\nLoops (for, while, repeat) allow you to repeatedly run code"
  },
  {
    "objectID": "slides/05.html#choices",
    "href": "slides/05.html#choices",
    "title": "Control flow",
    "section": "Choices",
    "text": "Choices\nif() and else\nUse if to specify a block of code to be executed, if a specified condition is true. Use else to specify a block of code to be executed, if the same condition is false.\n\nif (condition) true_action\nif (condition) true_action else false_action\n\n(Note braces are only needed for compound expressions)\n\nif (test_expression) {   \n  true_action\n} else {\n  false_action\n}\n\nCan be expanded to more alternatives:\n\nif (test_expression) {   \n  true_action\n} else if (other_test_expression) {\n  other_action\n} else {\n  false_action\n}"
  },
  {
    "objectID": "slides/05.html#exercise",
    "href": "slides/05.html#exercise",
    "title": "Control flow",
    "section": "Exercise",
    "text": "Exercise\nWhy does this work?\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"empty\"\nif returns a value which can be assigned\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n\n#&gt; [1] 1 2\n\n\nThe book recommends assigning the results of an if statement only when the entire expression fits on one line; otherwise it tends to be hard to read."
  },
  {
    "objectID": "slides/05.html#single-if-without-else",
    "href": "slides/05.html#single-if-without-else",
    "title": "Control flow",
    "section": "Single if without else",
    "text": "Single if without else\nWhen you use the single argument form without an else statement, if invisibly (Section 6.7.2) returns NULL if the condition is FALSE. Since functions like c() and paste() drop NULL inputs, this allows for a compact expression of certain idioms:\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n\nformat_lane_text &lt;- function(number){\n\n  paste0(\n    number,\n    \" lane\",\n    if (number &gt; 1) \"s\",\n    \" of sequencing\"\n  )\n}\n\nformat_lane_text(1)\n#&gt; [1] \"1 lane of sequencing\"\nformat_lane_text(4)\n#&gt; [1] \"4 lanes of sequencing\""
  },
  {
    "objectID": "slides/05.html#invalid-inputs",
    "href": "slides/05.html#invalid-inputs",
    "title": "Control flow",
    "section": "Invalid inputs",
    "text": "Invalid inputs\n\nCondition must evaluate to a single TRUE or FALSE\n\nA single number gets coerced to a logical type.\n\nif (56) 1\n#&gt; [1] 1\nif (0.3) 1\n#&gt; [1] 1\nif (0) 1\n\nIf the condition cannot evaluate to a single TRUE or FALSE, an error is (usually) produced.\n\nif (\"text\") 1\n#&gt; Error in if (\"text\") 1: argument is not interpretable as logical\nif (\"true\") 1 \n#&gt; 1\nif (numeric()) 1\n#&gt; Error in if (numeric()) 1: argument is of length zero\nif (NULL) 1\n#&gt; Error in if (NULL) 1 : argument is of length zero\nif (NA) 1\n#&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\n\nException is a logical vector of length greater than 1, which only generates a warning, unless you have _R_CHECK_LENGTH_1_CONDITION_ set to TRUE.\nThis seems to have been the default since R-4.2.0\n\nif (c(TRUE, FALSE)) 1\n#&gt;Error in if (c(TRUE, FALSE)) 1 : the condition has length &gt; 1"
  },
  {
    "objectID": "slides/05.html#vectorized-choices",
    "href": "slides/05.html#vectorized-choices",
    "title": "Control flow",
    "section": "Vectorized choices",
    "text": "Vectorized choices\n\nifelse() is a vectorized version of if:\n\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n\ndplyr::if_else()\nBook recommends only using ifelse() ‚Äúonly when the yes and no vectors are the same type as it is otherwise hard to predict the output type.‚Äù\ndplyr::if_else() enforces this recommendation.\n\nFor example:\n\nifelse(c(TRUE,TRUE,FALSE),\"a\",3)\n#&gt; [1] \"a\" \"a\" \"3\"\ndplyr::if_else(c(TRUE,TRUE,FALSE),\"a\",3)\n#&gt; Error in `dplyr::if_else()`:\n#&gt; ! `false` must be a character vector, not a double vector."
  },
  {
    "objectID": "slides/05.html#switch",
    "href": "slides/05.html#switch",
    "title": "Control flow",
    "section": "Switch",
    "text": "Switch\nRather then string together multiple if - else if chains, you can often use switch.\n\ncentre &lt;- function(x, type) {\n  switch(type,\n    mean = mean(x),\n    median = median(x),\n    trimmed = mean(x, trim = .1),\n    stop(\"Invalid `type` value\")\n  )\n}\n\nLast component should always throw an error, as unmatched inputs would otherwise invisibly return NULL. Book recommends to only use character inputs for switch().\n\nvec &lt;- c(1:20,50:55)\ncentre(vec, \"mean\")\n#&gt; [1] 20.19231\ncentre(vec, \"median\")\n#&gt; [1] 13.5\ncentre(vec, \"trimmed\")\n#&gt; [1] 18.77273\n\n\nset.seed(123)\nx &lt;- rlnorm(100)\n\ncenters &lt;- data.frame(type = c('mean', 'median', 'trimmed'))\ncenters$value = sapply(centers$type, \\(t){centre(x,t)})\n\nrequire(ggplot2)\nggplot(data = data.frame(x), aes(x))+\n  geom_density()+\n  geom_vline(data = centers, \n             mapping = aes(color = type, xintercept = value), \n             linewidth=0.5,linetype=\"dashed\") +\n  xlim(-1,10)+\n  theme_bw()\n\n\nExample from book of ‚Äúfalling through‚Äù to next value\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n\n#&gt; [1] 4\n\n#&gt; [1] 4\nlegs(\"dog\")\n\n#&gt; [1] 4\n\n#&gt; [1] 4"
  },
  {
    "objectID": "slides/05.html#using-dplyrcase_when",
    "href": "slides/05.html#using-dplyrcase_when",
    "title": "Control flow",
    "section": "Using dplyr::case_when",
    "text": "Using dplyr::case_when\n\ncase_when is a more general if_else and can be used often in place of multiple chained if_else or sapply‚Äôing switch.\nIt uses a special syntax to allow any number of condition-vector pairs:\n\n\nset.seed(123)\nx &lt;- rlnorm(100)\n\ncenters &lt;- data.frame(type = c('mean', 'median', 'trimmed'))\n\ncenters$value = dplyr::case_when(\n  centers$type == 'mean' ~ mean(x),\n  centers$type == 'median' ~ median(x),\n  centers$type == 'trimmed' ~ mean(x, trim = 0.1),\n  .default = 1000\n  )\n\ncenters\n\n#&gt;      type    value\n#&gt; 1    mean 1.652545\n#&gt; 2  median 1.063744\n#&gt; 3 trimmed 1.300568"
  },
  {
    "objectID": "slides/05.html#loops",
    "href": "slides/05.html#loops",
    "title": "Control flow",
    "section": "Loops",
    "text": "Loops\n\nIteration over a elements of a vector\n\nfor (item in vector) perform_action\nFirst example\n\nfor(i in 1:5) {\n  print(1:i)\n}\n\n#&gt; [1] 1\n#&gt; [1] 1 2\n#&gt; [1] 1 2 3\n#&gt; [1] 1 2 3 4\n#&gt; [1] 1 2 3 4 5\n\nx &lt;- numeric(length=5L)\ndf &lt;- data.frame(x=1:5)\n\nfor(i in 1:5) {\n  df$y[[i]] &lt;- i+1\n}\n\nSecond example: terminate a for loop earlier\n\nnext skips rest of current iteration\nbreak exits the loop entirely\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5"
  },
  {
    "objectID": "slides/05.html#exercise-1",
    "href": "slides/05.html#exercise-1",
    "title": "Control flow",
    "section": "Exercise",
    "text": "Exercise\nWhen the following code is evaluated, what can you say about the vector being iterated?\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n#&gt; [1] 1 2 3 2 4 6"
  },
  {
    "objectID": "slides/05.html#pitfalls",
    "href": "slides/05.html#pitfalls",
    "title": "Control flow",
    "section": "Pitfalls",
    "text": "Pitfalls\n\nPreallocate output containers to avoid slow code.\nBeware that 1:length(v) when v has length 0 results in a iterating backwards over 1:0, probably not what is intended. Use seq_along(v) instead.\nWhen iterating over S3 vectors, use [[]] yourself to avoid stripping attributes.\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#&gt; [1] 18262\n#&gt; [1] 14610\nvs.¬†\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\""
  },
  {
    "objectID": "slides/05.html#related-tools",
    "href": "slides/05.html#related-tools",
    "title": "Control flow",
    "section": "Related tools",
    "text": "Related tools\n\nwhile(condition) action: performs action while condition is TRUE.\nrepeat(action): repeats action forever (i.e.¬†until it encounters break).\nNote that for can be rewritten as while and while can be rewritten as repeat (this goes in one direction only!); however:\n\n\nGood practice is to use the least-flexible solution to a problem, so you should use for wherever possible. BUT you shouldn‚Äôt even use for loops for data analysis tasks as map() and apply() already provide less flexible solutions to most problems. (More in Chapter 9.)\n\n\nfor (i in 1:5) {\n  print(i)\n}\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\"#,\n    #stop(\"Invalid `x` value\")\n  )\n}\n\n\ni &lt;- 1\n\nwhile(i &lt;=5 ) {\n  print(i)\n  i &lt;- i+1\n}\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n\n\ni &lt;- 1\n\nrepeat {\n  print(i)\n  i &lt;- i+1\n  if (i &gt; 5) break\n}\n\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5"
  },
  {
    "objectID": "slides/03.html#learning-objectives",
    "href": "slides/03.html#learning-objectives",
    "title": "Vectors",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nLearn about different types of vectors and their attributes\nNavigate through vector types and their value types\nVenture into factors and date-time objects\nDiscuss the differences between data frames and tibbles\nDo not get absorbed by the NA and NULL black hole\n\n\n\nSession Info\n\n\n\n#&gt; R version 4.5.1 (2025-06-13 ucrt)\n#&gt; Platform: x86_64-w64-mingw32/x64\n#&gt; Running under: Windows 11 x64 (build 26100)\n#&gt; \n#&gt; Matrix products: default\n#&gt;   LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] LC_COLLATE=English_United States.utf8 \n#&gt; [2] LC_CTYPE=English_United States.utf8   \n#&gt; [3] LC_MONETARY=English_United States.utf8\n#&gt; [4] LC_NUMERIC=C                          \n#&gt; [5] LC_TIME=English_United States.utf8    \n#&gt; \n#&gt; time zone: America/Chicago\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     \n#&gt; \n#&gt; other attached packages:\n#&gt; [1] palmerpenguins_0.1.1 gt_1.0.0             dplyr_1.1.4         \n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;  [1] digest_0.6.37     R6_2.6.1          fastmap_1.2.0     tidyselect_1.2.1 \n#&gt;  [5] xfun_0.52         magrittr_2.0.3    glue_1.8.0        tibble_3.3.0     \n#&gt;  [9] knitr_1.50        pkgconfig_2.0.3   htmltools_0.5.8.1 rmarkdown_2.29   \n#&gt; [13] generics_0.1.4    lifecycle_1.0.4   xml2_1.3.8        cli_3.6.5        \n#&gt; [17] vctrs_0.6.5       compiler_4.5.1    tools_4.5.1       pillar_1.11.0    \n#&gt; [21] evaluate_1.0.4    yaml_2.3.10       rlang_1.1.6       jsonlite_2.0.0   \n#&gt; [25] keyring_1.4.1"
  },
  {
    "objectID": "slides/03.html#aperitif",
    "href": "slides/03.html#aperitif",
    "title": "Vectors",
    "section": "Aperitif",
    "text": "Aperitif\n\n\n\nPalmer Penguins\n\n\nCounting Penguins\nConsider this code to count the number of Gentoo penguins in the penguins data set. We see that there are 124 Gentoo penguins.\nIn\nOne subtle error can arise in trying out %in% here instead.\n\n\n\nWhere did the penguins go?\n\n\nFix: base R\nFix: dplyr\nMotivation\n\nWhat are the different types of vectors?\nHow does this affect accessing vectors?\n\n\n\nSide Quest: Looking up the %in% operator\n\nIf you want to look up the manual pages for the %in% operator with the ?, use backticks:\nand we find that %in% is a wrapper for the match() function."
  },
  {
    "objectID": "slides/03.html#types-of-vectors",
    "href": "slides/03.html#types-of-vectors",
    "title": "Vectors",
    "section": "Types of Vectors",
    "text": "Types of Vectors\n\nImage Credit: Advanced RTwo main types:\n\nAtomic: Elements all the same type.\nList: Elements are different Types.\n\nClosely related but not technically a vector:\n\nNULL: Null elements. Often length zero."
  },
  {
    "objectID": "slides/03.html#atomic-vectors",
    "href": "slides/03.html#atomic-vectors",
    "title": "Vectors",
    "section": "Atomic Vectors",
    "text": "Atomic Vectors\nTypes of atomic vectors\n\n\n\nImage Credit: Advanced R\n\n\n\nLogical: True/False\nInteger: Numeric (discrete, no decimals)\nDouble: Numeric (continuous, decimals)\nCharacter: String\n\nVectors of Length One\nScalars are vectors that consist of a single value.\nLogicals\nDoubles\nIntegers\nIntegers must be followed by L and cannot have fractional values\n\n\nPop Quiz: Why ‚ÄúL‚Äù for integers?\n\nWickham notes that the use of L dates back to the C programming language and its ‚Äúlong int‚Äù type for memory allocation.\n\nStrings\nStrings can use single or double quotes and special characters are escaped with\n\nLonger\nThere are several ways to make longer vectors:\n1. With single values inside c() for combine.\n\n\n\nImage Credit: Advanced R\n\n\n2. With other vectors\n\n\n#&gt; [1] 1 2 3 4\n\n\n\n\nSide Quest: rlang\n\n{rlang} has vector constructor functions too:\n\nrlang::lgl(...)\nrlang::int(...)\nrlang::dbl(...)\nrlang::chr(...)\n\nThey look to do both more and less than c().\n\nMore:\n\nEnforce type\nSplice lists\nMore types: rlang::bytes(), rlang::cpl(...)\n\nLess:\n\nStricter rules on names\n\n\nNote: currently has questioning lifecycle badge, since these constructors may get moved to vctrs\n\nType and Length\nWe can determine the type of a vector with typeof() and its length with length()\n\n\n\n\n\n\n\n\nTypes of Atomic Vectors1\n\n\nname\nvalue\ntypeof()\nlength()\n\n\n\n\nlgl_var\nTRUE, FALSE\nlogical\n2\n\n\nint_var\n1L, 6L, 10L\ninteger\n3\n\n\ndbl_var\n1, 2.5, 4.5\ndouble\n3\n\n\nchr_var\n'these are', 'some strings'\ncharacter\n2\n\n\n\n1 Source: https://adv-r.hadley.nz/index.html\n\n\n\n\n\n\n\n\n\n\nSide Quest: Penguins\n\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n\nMissing values\nContagion\nFor most computations, an operation over values that includes a missing value yields a missing value (unless you‚Äôre careful)\n\n\n#&gt; [1] NA\n\n\n#&gt; [1] NA\n\n\nExceptions\nInnoculation\nTo search for missing values use is.na()\n\n\nSide Quest: NA Types\n\nEach type has its own NA type\n\nLogical: NA\nInteger: NA_integer\nDouble: NA_double\nCharacter: NA_character\n\nThis may not matter in many contexts.\nBut this does matter for operations where types matter like dplyr::if_else().\n\nTesting\nWhat type of vector is.*() it?\nTest data type:\n\nLogical: is.logical()\nInteger: is.integer()\nDouble: is.double()\nCharacter: is.character()\n\nWhat type of object is it?\nDon‚Äôt test objects with these tools:\n\nis.vector()\nis.atomic()\nis.numeric()\n\nThey don‚Äôt test if you have a vector, atomic vector, or numeric vector; you‚Äôll need to carefully read the documentation to figure out what they actually do (preview: attributes)\n\n\nSide Quest: rlang\n\nInstead, maybe, use {rlang}\n\nrlang::is_vector\nrlang::is_atomic\n\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] FALSE\n\n\nSee more here\n\nCoercion\n\nR follows rules for coercion: character ‚Üí double ‚Üí integer ‚Üí logical\nR can coerce either automatically or explicitly\n\nAutomatic\nTwo contexts for automatic coercion:\n\nCombination\nMathematical\n\nCoercion by Combination:\n\n\n#&gt;  chr [1:2] \"TRUE\" \"TRUE\"\n\n\nCoercion by Mathematical operations:\n\n\n#&gt; [1] 3\n\n\nExplicit\n\n\n\n\n\n\n\n\n\nCoercion of Atomic Vectors1\n\n\nname\nvalue\nas.logical()\nas.integer()\nas.double()\nas.character()\n\n\n\n\nlgl_var\nTRUE, FALSE\nTRUE FALSE\n1 0\n1 0\n'TRUE' 'FALSE'\n\n\nint_var\n1L, 6L, 10L\nTRUE TRUE TRUE\n1 6 10\n1 6 10\n'1' '6' '10'\n\n\ndbl_var\n1, 2.5, 4.5\nTRUE TRUE TRUE\n1 2 4\n1.0 2.5 4.5\n'1' '2.5' '4.5'\n\n\nchr_var\n'these are', 'some strings'\nNA NA\nNA_integer\nNA_double\n'these are', 'some strings'\n\n\n\n1 Source: https://adv-r.hadley.nz/index.html\n\n\n\n\n\n\n\n\nBut note that coercion may fail in one of two ways, or both:\n\nWith warning/error\nNAs\n\n\n\n#&gt; [1]  1  2 NA\n\n\nExercises\n\nHow do you create raw and complex scalars?\n\n\n\nAnswer(s)\n\n\n\nTest your knowledge of the vector coercion rules by predicting the output of the following uses of c():\n\n\n\nAnswer(s)\n\n\n\nWhy is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\n\n\n\nAnswer(s)\n\nThese comparisons are carried out by operator-functions (==, &lt;), which coerce their arguments to a common type. In the examples above, these types will be character, double and character: 1 will be coerced to ‚Äú1‚Äù, FALSE is represented as 0 and 2 turns into ‚Äú2‚Äù (and numbers precede letters in lexicographic order (may depend on locale)).\n\n\nWhy is the default missing value, NA, a logical vector? What‚Äôs special about logical vectors?\n\n\n\nAnswer(s)\n\nThe presence of missing values shouldn‚Äôt affect the type of an object. Recall that there is a type-hierarchy for coercion from character ‚Üí double ‚Üí integer ‚Üí logical. When combining NAs with other atomic types, the NAs will be coerced to integer (NA_integer_), double (NA_real_) or character (NA_character_) and not the other way round. If NA were a character and added to a set of other values all of these would be coerced to character as well.\n\n\nPrecisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\n\n\nAnswer(s)\n\nThe documentation states that:\n\nis.atomic() tests if an object is an atomic vector (as defined in Advanced R) or is NULL (!).\nis.numeric() tests if an object has type integer or double and is not of class factor, Date, POSIXt or difftime.\nis.vector() tests if an object is a vector (as defined in Advanced R) or an expression and has no attributes, apart from names.\n\nAtomic vectors are defined in Advanced R as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists."
  },
  {
    "objectID": "slides/03.html#attributes",
    "href": "slides/03.html#attributes",
    "title": "Vectors",
    "section": "Attributes",
    "text": "Attributes\nAttributes are name-value pairs that attach metadata to an object(vector).\n\nName-value pairs: attributes have a name and a value\nMetadata: not data itself, but data about the data\n\nHow?\nGetting and Setting\nThree functions:\n\nretrieve and modify single attributes with attr()\nretrieve en masse with attributes()\nset en masse with structure()\n\nSingle attribute\nUse attr()\n\n\n#&gt; [1] \"some attribute\"\n\n\nMultiple attributes\nTo set multiple attributes, use structure() To get multiple attributes, use attributes()\n\n\n\nImage Credit: Advanced R\n\n\nWhy\nThree particularly important attributes:\n\nnames - a character vector giving each element a name\ndimension - (or dim) turns vectors into matrices and arrays\nclass - powers the S3 object system (we‚Äôll learn more about this in chapter 13)\n\nMost attributes are lost by most operations. Only two attributes are routinely preserved: names and dimension.\nNames\nThree Four ways to name:\n\n\n#&gt; A B C \n#&gt; 1 2 3\n\n\n#&gt; a b c \n#&gt; 1 2 3\n\n\n#&gt; a b c \n#&gt; 1 2 3\n\n\n\n\n\nproper diagram\n\n\n\n\n#&gt; a b c \n#&gt; 1 2 3\n\n\n\n\n\nsimplified diagram\n\n\n\nYou can remove names from a vector by using x &lt;- unname(x) or names(x) &lt;- NULL.\nThematically but not directly related: labelled class vectors with haven::labelled()\n\nDimensions\nCreate matrices and arrays with matrix() and array(), or by using the assignment form of dim():\n\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   13   15   17\n#&gt; [2,]   14   16   18\n#&gt; \n#&gt; , , 4\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   19   21   23\n#&gt; [2,]   20   22   24\n\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   13   15   17\n#&gt; [2,]   14   16   18\n#&gt; \n#&gt; , , 4\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   19   21   23\n#&gt; [2,]   20   22   24\n\n\nFunctions for working with vectors, matrices and arrays:\n\n\n\nVector\nMatrix\nArray\n\n\n\n\nnames()\nrownames(), colnames()\ndimnames()\n\n\nlength()\nnrow(), ncol()\ndim()\n\n\nc()\nrbind(), cbind()\nabind::abind()\n\n\n‚Äî\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n\nCaution: A vector without a dim attribute set is often thought of as 1-dimensional, but actually has NULL dimensions.\nOne dimension?\n\nExercises\n\nHow is setNames() implemented? How is unname() implemented? Read the source code.\n\n\n\nAnswer(s)\n\nsetNames() is implemented as:\nBecause the data argument comes first, setNames() also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):\nunname() is implemented in the following way:\nunname() removes existing names (or dimnames) by setting them to NULL.\n\n\nWhat does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\n\n\n\nAnswer(s)\n\n\ndim() will return NULL when applied to a 1d vector.\n\nOne may want to use NROW() or NCOL() to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames. For these objects nrow() and ncol() return NULL:\n\n\nHow would you describe the following three objects? What makes them different from 1:5?\n\n\n\nAnswer(s)\n\n\n\nAn early draft used this code to illustrate structure():\n\nBut when you print that object you don‚Äôt see the comment attribute. Why? Is the attribute missing, or is there something else special about it?\n\n\nAnswer(s)\n\nThe documentation states (see ?comment):\n\nContrary to other attributes, the comment is not printed (by print or print.default).\n\nAlso, from ?attributes:\n\nNote that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.\n\nWe can retrieve comment attributes by calling them explicitly:"
  },
  {
    "objectID": "slides/03.html#class---s3-atomic-vectors",
    "href": "slides/03.html#class---s3-atomic-vectors",
    "title": "Vectors",
    "section": "Class - S3 atomic vectors",
    "text": "Class - S3 atomic vectors\n\nCredit: Advanced R by Hadley Wickham\nHaving a class attribute turns an object into an S3 object.\nWhat makes S3 atomic vectors different?\n\nbehave differently from a regular vector when passed to a generic function\noften store additional information in other attributes\n\nFour important S3 vectors used in base R:\n\nFactors (categorical data)\nDates\nDate-times (POSIXct)\nDurations (difftime)\n\nFactors\nA factor is a vector used to store categorical data that can contain only predefined values.\nFactors are integer vectors with:\n\nClass: ‚Äúfactor‚Äù\nAttributes: ‚Äúlevels‚Äù, or the set of allowed values\n\n\n\n#&gt; colors\n#&gt;  blue green   red \n#&gt;     1     2     3\n\n\n#&gt; a_factor\n#&gt;    red   blue  green yellow \n#&gt;      3      1      2      0\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; $levels\n#&gt; [1] \"red\"    \"blue\"   \"green\"  \"yellow\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\nCustom Order\nFactors can be ordered. This can be useful for models or visualizations where order matters.\n\n\n#&gt; [1] high med  low  med  high low  med  high\n#&gt; Levels: low &lt; med &lt; high\n\n\n#&gt; values\n#&gt; high  low  med \n#&gt;    3    2    3\n\n\n#&gt; ordered_factor\n#&gt;  low  med high \n#&gt;    2    3    3\n\n\nDates\nDates are:\n\nDouble vectors\nWith class ‚ÄúDate‚Äù\nNo other attributes\n\n\n\n#&gt; [1] \"double\"\n\n\n#&gt; $class\n#&gt; [1] \"Date\"\n\n\nThe double component represents the number of days since since the Unix epoch 1970-01-01\n\n\n#&gt; [1] 31\n\n\nDate-times\nThere are 2 Date-time representations in base R:\n\nPOSIXct, where ‚Äúct‚Äù denotes calendar time\nPOSIXlt, where ‚Äúlt‚Äù designates local time\n\n\nWe‚Äôll focus on POSIXct because:\n\nSimplest\nBuilt on an atomic (double) vector\nMost appropriate for use in a data frame\n\nLet‚Äôs now build and deconstruct a Date-time\n\n\n#&gt; [1] \"2025-08-04 15:39:49 EDT\"\n\n\n#&gt; [1] \"double\"\n\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"America/New_York\"\n\n\n#&gt; [1] \"2025-08-04 21:39:49 CEST\"\n\n\n\n\n#&gt; [1] 1708623296\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"EST\"\n\n\nDurations\nDurations represent the amount of time between pairs of dates or date-times.\n\nDouble vectors\nClass: ‚Äúdifftime‚Äù\nAttributes: ‚Äúunits‚Äù, or the unit of duration (e.g., weeks, hours, minutes, seconds, etc.)\n\n\n\n#&gt; Time difference of 1 mins\n\n\n#&gt; [1] \"double\"\n\n\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"mins\"\n\n\n\n\n#&gt; Time difference of 20273 days\n\n\nSee also:\n\nlubridate::make_difftime()\nclock::date_time_build()\n\nExercises\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\n\n\nAnswer(s)\n\ntable() returns a contingency table of its input variables. It is implemented as an integer vector with class table and dimensions (which makes it act like an array). Its attributes are dim (dimensions) and dimnames (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.\n\n\nWhat happens to a factor when you modify its levels?\n\n\n\nAnswer(s)\n\nThe underlying integer values stay the same, but the levels are changed, making it look like the data has changed.\n\n\nWhat does this code do? How do f2 and f3 differ from f1?\n\n\n\nAnswer(s)\n\nFor f2 and f3 either the order of the factor elements or its levels are being reversed. For f1 both transformations are occurring."
  },
  {
    "objectID": "slides/03.html#lists",
    "href": "slides/03.html#lists",
    "title": "Vectors",
    "section": "Lists",
    "text": "Lists\n\nsometimes called a generic vector or recursive vector\nRecall (section 2.3.3): each element is really a reference to another object\nan be composed of elements of different types (as opposed to atomic vectors which must be of only one type)\n\nConstructing\nSimple lists:\n\n\n#&gt; [[1]]\n#&gt; [1]  TRUE FALSE\n#&gt; \n#&gt; [[2]]\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 1.2 2.3 3.4\n#&gt; \n#&gt; [[4]]\n#&gt; [1] \"primo\"   \"secundo\" \"tercio\"\n\n\n#&gt; [1] \"list\"\n\n\n#&gt; List of 4\n#&gt;  $ : logi [1:2] TRUE FALSE\n#&gt;  $ : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ : num [1:3] 1.2 2.3 3.4\n#&gt;  $ : chr [1:3] \"primo\" \"secundo\" \"tercio\"\n\n\n#&gt; [[1]]\n#&gt; [1]  TRUE FALSE\n\n\n#&gt; [[1]]\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\n\n#&gt; [[1]]\n#&gt; [1] 1.2 2.3 3.4\n\n\n#&gt; [[1]]\n#&gt; [1] \"primo\"   \"secundo\" \"tercio\"\n\n\n#&gt; [1] FALSE\n\n\n#&gt; [1] 8\n\n\n#&gt; [1] 2.3\n\n\n#&gt; [1] \"tercio\"\n\n\nEven Simpler List\n\n\n#&gt; [[1]]\n#&gt; [1] TRUE\n\n\n#&gt; [[1]]\n#&gt; [1] 3\n\n\n#&gt; [[1]]\n#&gt; [1] 2.3\n\n\n#&gt; [[1]]\n#&gt; [1] \"primo\"\n\n\nNested lists:\n\n\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ :List of 1\n#&gt;   .. .. ..$ : num 1\n\n\nLike JSON.\nCombined lists\n\n\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 3\n#&gt;   ..$ : num 4\n\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : logi FALSE\n\n\nTesting\nCheck that is a list:\n\nis.list()\n`rlang::is_list()``\n\nThe two do the same, except that the latter can check for the number of elements\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] TRUE\n\n\n#&gt; [1] TRUE\n\n\nCoercion\nUse as.list()\n\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\n\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\nMatrices and arrays\nAlthough not often used, the dimension attribute can be added to create list-matrices or list-arrays.\n\n\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\n\n#&gt; [1] 1 2 3\n\n\nExercises\n\nList all the ways that a list differs from an atomic vector.\n\n\n\nAnswer(s)\n\n\nAtomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the introduction of the vectors chapter.\nAtomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the vectors and the names and values chapters.)\n\n\nSubsetting with out-of-bounds and NA values leads to different output. For example, [ returns NA for atomics and NULL for lists. (This is described in more detail within the subsetting chapter.)\n\n\n\nWhy do you need to use unlist() to convert a list to an atomic vector? Why doesn‚Äôt as.vector() work?\n\n\n\nAnswer(s)\n\nA list is already a vector, though not an atomic one! Note that as.vector() and is.vector() use different definitions of ‚Äúvector!‚Äù\n\n\nCompare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\n\n\nAnswer(s)\n\nDate and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as ‚Äúthe Epoch‚Äù) in days, date-time-objects (POSIXct) store the time difference to this date in seconds.\nAs the c() generic only dispatches on its first argument, combining date and date-time objects via c() could lead to surprising results in older R versions (pre R 4.0.0):\nIn the first statement above c.Date() is executed, which incorrectly treats the underlying double of dttm_ct (3600) as days instead of seconds. Conversely, when c.POSIXct() is called on a date, one day is counted as one second only.\nWe can highlight these mechanics by the following code:\nAs of R 4.0.0 these issues have been resolved and both methods now convert their input first into POSIXct and Date, respectively.\nHowever, as c() strips the time zone (and other attributes) of POSIXct objects, some caution is still recommended.\nA package that deals with these kinds of problems in more depth and provides a structural solution for them is the {vctrs} package9 which is also used throughout the tidyverse.10\nLet‚Äôs look at unlist(), which operates on list input.\nWe see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.\nTo summarise: c() coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. unlist() strips attributes."
  },
  {
    "objectID": "slides/03.html#data-frames-and-tibbles",
    "href": "slides/03.html#data-frames-and-tibbles",
    "title": "Vectors",
    "section": "Data frames and tibbles",
    "text": "Data frames and tibbles\n\nCredit: Advanced R by Hadley Wickham\nData frame\nA data frame is a:\n\nNamed list of vectors (i.e., column names)\nAttributes:\n\n(column) names\nrow.names\nClass: ‚Äúdata frame‚Äù\n\n\n\n\n#&gt;   col1  col2\n#&gt; 1    1    un\n#&gt; 2    2  deux\n#&gt; 3    3 trois\n\n\n#&gt; [1] \"list\"\n\n\n#&gt; $names\n#&gt; [1] \"col1\" \"col2\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\n\n\n\n#&gt; [1] \"1\" \"2\" \"3\"\n\n\n#&gt; [1] \"col1\" \"col2\"\n\n\n#&gt; [1] \"col1\" \"col2\"\n\n\n#&gt; [1] 3\n\n\n#&gt; [1] 2\n\n\n#&gt; [1] 2\n\n\nUnlike other lists, the length of each vector must be the same (i.e.¬†as many vector elements as rows in the data frame).\nTibble\nCreated to relieve some of the frustrations and pain points created by data frames, tibbles are data frames that are:\n\nLazy (do less)\nSurly (complain more)\n\nLazy\nTibbles do not:\n\nCoerce strings\nTransform non-syntactic names\nRecycle vectors of length greater than 1\n\nCoerce strings\n\n\n#&gt;  Factor w/ 4 levels \"bro\",\"don't\",..: 2 3 4 1\n\n\n#&gt;  chr [1:4] \"don't\" \"factor\" \"me\" \"bro\"\n\n\nTransform non-syntactic names\n\n\n#&gt; [1] \"X1\"\n\n\n#&gt; [1] \"1\"\n\n\nRecycle vectors of length greater than 1\n\n\n#&gt; Error in `tibble::tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; ‚Ä¢ Size 4: Existing data.\n#&gt; ‚Ä¢ Size 2: Column `col2`.\n#&gt; ‚Ñπ Only values of size one are recycled.\n\n\nSurly\nTibbles do only what they‚Äôre asked and complain if what they‚Äôre asked doesn‚Äôt make sense:\n\nSubsetting always yields a tibble\nComplains if cannot find column\n\nSubsetting always yields a tibble\n\n\n#&gt;  num [1:4] 1 2 3 4\n\n\n#&gt; tibble [4 √ó 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ col1: num [1:4] 1 2 3 4\n\n\n#&gt;  num [1:4] 1 2 3 4\n\n\n#&gt;  num [1:4] 1 2 3 4\n\n\nComplains if cannot find column\n\n\n#&gt; [1] \"col1\"\n\n\n#&gt; [1] 1 2 3 4\n\n\n#&gt; [1] \"col1\"\n\n\n#&gt; Warning: Unknown or uninitialised column: `col`.\n\n\n#&gt; NULL\n\n\nOne more difference\ntibble() allows you to refer to variables created during construction\n\n\n#&gt; # A tibble: 3 √ó 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\n\n\n\nSide Quest: Row Names\n\n\ncharacter vector containing only unique values\nget and set with rownames()\ncan use them to subset rows\n\n\n\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\n\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\n\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\n\n#&gt; [1] \"Susan\" \"Bob\"   \"Sam\"\n\n\n#&gt;     age  hair\n#&gt; Bob  27 brown\n\n\nThere are three reasons why row names are undesirable:\n\nMetadata is data, so storing it in a different way to the rest of the data is fundamentally a bad idea.\nRow names are a poor abstraction for labelling rows because they only work when a row can be identified by a single string. This fails in many cases.\nRow names must be unique, so any duplication of rows (e.g.¬†from bootstrapping) will create new row names.\n\n\nPrinting\nData frames and tibbles print differently\n\n\n#&gt;       age  hair\n#&gt; Susan  35 blond\n#&gt; Bob    27 brown\n#&gt; Sam    18 black\n\n\n#&gt; # A tibble: 3 √ó 2\n#&gt;     age hair \n#&gt;   &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1    35 blond\n#&gt; 2    27 brown\n#&gt; 3    18 black\n\n\nSubsetting\nTwo undesirable subsetting behaviours:\n\nWhen you subset columns with df[, vars], you will get a vector if vars selects one variable, otherwise you‚Äôll get a data frame, unless you always remember to use df[, vars, drop = FALSE].\nWhen you attempt to extract a single column with df$x and there is no column x, a data frame will instead select any variable that starts with x. If no variable starts with x, df$x will return NULL.\n\nTibbles tweak these behaviours so that a [ always returns a tibble, and a $ doesn‚Äôt do partial matching and warns if it can‚Äôt find a variable (this is what makes tibbles surly).\nTesting\nWhether data frame: is.data.frame(). Note: both data frame and tibble are data frames.\nWhether tibble: tibble::is_tibble. Note: only tibbles are tibbles. Vanilla data frames are not.\nCoercion\n\nTo data frame: as.data.frame()\nTo tibble: tibble::as_tibble()\n\nList Columns\nList-columns are allowed in data frames but you have to do a little extra work by either adding the list-column after creation or wrapping the list in I()\n\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\nMatrix and data frame columns\n\nAs long as the number of rows matches the data frame, it‚Äôs also possible to have a matrix or data frame as a column of a data frame.\nsame as list-columns, must either addi the list-column after creation or wrapping the list in I()\n\n\n\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: 'AsIs' int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    4    7\n#&gt; [2,]    2    5    8\n#&gt; [3,]    3    6    9\n\n\n#&gt;   a b\n#&gt; 1 3 a\n#&gt; 2 2 b\n#&gt; 3 1 c\n\n\nExercises\n\nCan you have a data frame with zero rows? What about zero columns?\n\n\n\nAnswer(s)\n\nYes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero. Create a 0-row, 0-column, or an empty data frame directly:\nCreate similar data frames via subsetting the respective dimension with either 0, NULL, FALSE or a valid 0-length atomic (logical(0), character(0), integer(0), double(0)). Negative integer sequences would also work. The following example uses a zero:\n\n\nWhat happens if you attempt to set rownames that are not unique?\n\n\n\nAnswer(s)\n\nMatrices can have duplicated row names, so this does not cause problems.\nData frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via row.names(), you get an error:\nIf you use subsetting, [ automatically deduplicates:\n\n\nIf df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\n\n\n\nAnswer(s)\n\nBoth of t(df) and t(t(df)) will return matrices:\nThe dimensions will respect the typical transposition rules:\nBecause the output is a matrix, every column is coerced to the same type. (It is implemented within t.data.frame() via as.matrix() which is described below).\n\n\nWhat does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\n\n\n\nAnswer(s)\n\nThe type of the result of as.matrix depends on the types of the input columns (see ?as.matrix):\n\nThe method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical &lt; integer &lt; double &lt; complex) will be used, e.g.¬†all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give an integer matrix, etc.\n\nOn the other hand, data.matrix will always return a numeric matrix (see ?data.matrix()).\n\nReturn the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. [‚Ä¶] Character columns are first converted to factors and then to integers.\n\nWe can illustrate and compare the mechanics of these functions using a concrete example. as.matrix() makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from data.matrix()‚Äôs output, we would need a lookup table for each column."
  },
  {
    "objectID": "slides/03.html#null",
    "href": "slides/03.html#null",
    "title": "Vectors",
    "section": "NULL",
    "text": "NULL\nSpecial type of object that:\n\nLength 0\nCannot have attributes\n\n\n\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\n\n\n\n#&gt; [1] TRUE"
  },
  {
    "objectID": "slides/03.html#digestif",
    "href": "slides/03.html#digestif",
    "title": "Vectors",
    "section": "Digestif",
    "text": "Digestif\nLet is use some of this chapter‚Äôs skills on the penguins data.\nAttributes\n\n\n#&gt; tibble [344 √ó 17] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n#&gt;  $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" ...\n#&gt;  $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n#&gt;  $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n#&gt;  $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" ...\n#&gt;  $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n#&gt;  $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n#&gt;  $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n#&gt;  $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n#&gt;  $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n#&gt;  $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n#&gt;  $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n#&gt;  $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n#&gt;  $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n#&gt;  $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n#&gt;  $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA \"Adult not sampled.\" ...\n#&gt;  - attr(*, \"spec\")=List of 3\n#&gt;   ..$ cols   :List of 17\n#&gt;   .. ..$ studyName          : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Sample Number      : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Species            : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Region             : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Island             : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Stage              : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Individual ID      : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Clutch Completion  : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Date Egg           :List of 1\n#&gt;   .. .. ..$ format: chr \"\"\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_date\" \"collector\"\n#&gt;   .. ..$ Culmen Length (mm) : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Culmen Depth (mm)  : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Flipper Length (mm): list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Body Mass (g)      : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Sex                : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   .. ..$ Delta 15 N (o/oo)  : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Delta 13 C (o/oo)  : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_double\" \"collector\"\n#&gt;   .. ..$ Comments           : list()\n#&gt;   .. .. ..- attr(*, \"class\")= chr [1:2] \"collector_character\" \"collector\"\n#&gt;   ..$ default: list()\n#&gt;   .. ..- attr(*, \"class\")= chr [1:2] \"collector_guess\" \"collector\"\n#&gt;   ..$ skip   : num 1\n#&gt;   ..- attr(*, \"class\")= chr \"col_spec\"\n\n\n\n\n#&gt; tibble [344 √ó 17] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n#&gt;  $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie Penguin (Pygoscelis adeliae)\" ...\n#&gt;  $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n#&gt;  $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n#&gt;  $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" ...\n#&gt;  $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n#&gt;  $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n#&gt;  $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n#&gt;  $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n#&gt;  $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n#&gt;  $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n#&gt;  $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n#&gt;  $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n#&gt;  $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n#&gt;  $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n#&gt;  $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA \"Adult not sampled.\" ...\n\n\nData Frames vs Tibbles\nPrinting\n\nTip: print out these results in RStudio under different editor themes\n\n\n\n#&gt;   species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt; 1  Adelie Torgersen           39.1          18.7               181        3750\n#&gt; 2  Adelie Torgersen           39.5          17.4               186        3800\n#&gt; 3  Adelie Torgersen           40.3          18.0               195        3250\n#&gt; 4  Adelie Torgersen             NA            NA                NA          NA\n#&gt; 5  Adelie Torgersen           36.7          19.3               193        3450\n#&gt; 6  Adelie Torgersen           39.3          20.6               190        3650\n#&gt;      sex year\n#&gt; 1   male 2007\n#&gt; 2 female 2007\n#&gt; 3 female 2007\n#&gt; 4   &lt;NA&gt; 2007\n#&gt; 5 female 2007\n#&gt; 6   male 2007\n\n\n\n\n#&gt; # A tibble: 344 √ó 8\n#&gt;    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;    &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n#&gt;  1 Adelie  Torgersen           39.1          18.7               181        3750\n#&gt;  2 Adelie  Torgersen           39.5          17.4               186        3800\n#&gt;  3 Adelie  Torgersen           40.3          18                 195        3250\n#&gt;  4 Adelie  Torgersen           NA            NA                  NA          NA\n#&gt;  5 Adelie  Torgersen           36.7          19.3               193        3450\n#&gt;  6 Adelie  Torgersen           39.3          20.6               190        3650\n#&gt;  7 Adelie  Torgersen           38.9          17.8               181        3625\n#&gt;  8 Adelie  Torgersen           39.2          19.6               195        4675\n#&gt;  9 Adelie  Torgersen           34.1          18.1               193        3475\n#&gt; 10 Adelie  Torgersen           42            20.2               190        4250\n#&gt; # ‚Ñπ 334 more rows\n#&gt; # ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nAtomic Vectors\n\n\ntypeof() and class()\n\n\n\n#&gt; [1] \"list\"\n\n\n#&gt; [1] \"data.frame\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; [1] \"list\"\n\n\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n#&gt; [1] \"integer\"\n\n\n#&gt; [1] \"factor\"\n\n\n\nColumn Names\n\n\n#&gt; [1] \"species\"           \"island\"            \"bill_length_mm\"   \n#&gt; [4] \"bill_depth_mm\"     \"flipper_length_mm\" \"body_mass_g\"      \n#&gt; [7] \"sex\"               \"year\"\n\n\n\n\n#&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\n\n#&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\nWhat if we only invoke a partial name of a column of a tibble?\n\n\n\n#&gt; NULL\n\n\n\ntibbles are surly!\nWhat if we only invoke a partial name of a column of a data frame?\n\n\n\n#&gt; [1] 2007 2007 2007 2007 2007 2007\n\n\n\nIs this evaluation in alphabetical order or column order?\n\n\n\n#&gt; NULL\n\n\n\n\n#&gt; NULL"
  },
  {
    "objectID": "slides/03.html#chapter-quiz",
    "href": "slides/03.html#chapter-quiz",
    "title": "Vectors",
    "section": "Chapter Quiz",
    "text": "Chapter Quiz\n\nWhat are the four common types of atomic vectors? What are the two rare types?\n\n\n\nAnswer(s)\n\nThe four common types of atomic vector are logical, integer, double and character. The two rarer types are complex and raw.\n\n\nWhat are attributes? How do you get them and set them?\n\n\n\nAnswer(s)\n\nAttributes allow you to associate arbitrary additional metadata to any object. You can get and set individual attributes with attr(x, \"y\") and attr(x, \"y\") &lt;- value; or you can get and set all attributes at once with attributes().\n\n\nHow is a list different from an atomic vector? How is a matrix different from a data frame?\n\n\n\nAnswer(s)\n\nThe elements of a list can be any type (even a list); the elements of an atomic vector are all of the same type. Similarly, every element of a matrix must be the same type; in a data frame, different columns can have different types.\n\n\nCan you have a list that is a matrix? Can a data frame have a column that is a matrix?\n\n\n\nAnswer(s)\n\nYou can make a list-array by assigning dimensions to a list. You can make a matrix a column of a data frame with df$x &lt;- matrix(), or by using I() when creating a new data frame data.frame(x = I(matrix())).\n\n\nHow do tibbles behave differently from data frames?\n\n\n\nAnswer(s)\n\nTibbles have an enhanced print method, never coerce strings to factors, and provide stricter subsetting methods."
  },
  {
    "objectID": "slides/01.html#los-for-the-entire-book",
    "href": "slides/01.html#los-for-the-entire-book",
    "title": "Introduction",
    "section": "LOs for the entire book",
    "text": "LOs for the entire book\n\nImprove programming skills.\nDevelop a deep understanding of R language fundamentals.\nUnderstand what functional programming means.\nUnderstand object-oriented programming as applied in R.\nUnderstand metaprogramming while developing in R.\nBe able to identify what to optimize and how to optimize it."
  },
  {
    "objectID": "slides/01.html#los-for-this-chapter",
    "href": "slides/01.html#los-for-this-chapter",
    "title": "Introduction",
    "section": "LOs for this chapter",
    "text": "LOs for this chapter\n\nRecognize the differences between the 1st and 2nd edition of this book.\nDescribe the overall structure of the book.\nDecide whether this book is right for you."
  },
  {
    "objectID": "slides/01.html#hadleys-goals",
    "href": "slides/01.html#hadleys-goals",
    "title": "Introduction",
    "section": "Hadley‚Äôs goals",
    "text": "Hadley‚Äôs goals\n\nImprove coverage of concepts Hadley understood better after 1e\nReduce coverage of unimportant topics\nEasier to understand (including many more diagrams)"
  },
  {
    "objectID": "slides/01.html#base-vs-rlang",
    "href": "slides/01.html#base-vs-rlang",
    "title": "Introduction",
    "section": "Base vs rlang",
    "text": "Base vs rlang\n\n1e used base R almost exclusively\n2e uses {rlang}, {purrr}, etc"
  },
  {
    "objectID": "slides/01.html#the-5-sections",
    "href": "slides/01.html#the-5-sections",
    "title": "Introduction",
    "section": "The 5 sections",
    "text": "The 5 sections\n\nFoundations: (7 chapters) Building blocks of R\nFunctional programming: (3 chapters) Treating functions as objects (that can be args in functions)\nObject-oriented programming: (5 chapters + 1) The many object systems of R (we‚Äôll add S7)\nMetaprogramming: (5 chapters) Generating code with code\nTechniques: (4 chapters) Debugging, measuring performance, improving performance\n\n\n\nMight be useful to open TOC here."
  },
  {
    "objectID": "slides/01.html#why-r",
    "href": "slides/01.html#why-r",
    "title": "Introduction",
    "section": "Why R?",
    "text": "Why R?\n\nDiverse & welcoming community\nMany packages for stats & modeling, ML, dataviz, data wrangling\nRmarkdown / Quarto\nRStudio / Positron\nOften used in science\nFunctional programming powerful for data\nMetaprogramming\nEase of connection to C, C++, etc"
  },
  {
    "objectID": "slides/01.html#r-imperfections",
    "href": "slides/01.html#r-imperfections",
    "title": "Introduction",
    "section": "R imperfections",
    "text": "R imperfections\n\nMuch code by non-coders (messy)\nCommunity more about results than programming best practices\nMetaprogramming can lead to weird failures\nInconsistency from &gt; 30 years of evolution\nPoorly written R code runs very poorly"
  },
  {
    "objectID": "slides/01.html#who-should-read-advanced-r",
    "href": "slides/01.html#who-should-read-advanced-r",
    "title": "Introduction",
    "section": "Who should read Advanced R?",
    "text": "Who should read Advanced R?\n\nIntermediate (and up) R programmers who want to really understand R\nProgrammers from other langs who want to know why R is weird\nPrereqs:\n\nYou‚Äôve written lots of code\nYou understand basics of data analysis\nYou can install CRAN packages"
  },
  {
    "objectID": "slides/01.html#what-this-book-is-not",
    "href": "slides/01.html#what-this-book-is-not",
    "title": "Introduction",
    "section": "What this book is not",
    "text": "What this book is not\n\nR for Data Science\nR Packages"
  },
  {
    "objectID": "slides/01.html#meta-techniques",
    "href": "slides/01.html#meta-techniques",
    "title": "Introduction",
    "section": "Meta-techniques",
    "text": "Meta-techniques\n\nRead source code\n\nF2 to see code in RStudio/Positron (with RStudio bindings)\n\nAdopt a scientific mindset\n\nDon‚Äôt understand something? Hypothesize & experiment"
  },
  {
    "objectID": "slides/01.html#other-books",
    "href": "slides/01.html#other-books",
    "title": "Introduction",
    "section": "Other books",
    "text": "Other books\n\nThe Structure and Interpretation of Computer Programs (Abelson, Sussman, and Sussman, 1996) PDF\nConcepts, Techniques and Models of Computer Programming (Van Roy & Haridi, 2003) PDF\nThe Pragmatic Programmer (Hunt & Thomas, 1990) buy eBook\n\n\n\nAs far as I can tell, first 2 PDFs are legal.\nI don‚Äôt think a legal, free version of The Pragmatic Programmer is available."
  },
  {
    "objectID": "slides/00.html#book-club-meetings",
    "href": "slides/00.html#book-club-meetings",
    "title": "Club meetings",
    "section": "Book club meetings",
    "text": "Book club meetings\n\nVolunteer leads discussion of a chapter\n\nThis is the best way to learn the material.\n\nPresentations:\n\nReview of material\nQuestions you have\nMaybe live demo\n\nMore info about editing: this github repo\nIdeally convert existing Rmd to qmd as we go\nRecorded, available on the Data Science Learning Community YouTube Channel (DSLC.video)",
    "crumbs": [
      "Club meetings"
    ]
  },
  {
    "objectID": "slides/00.html#pace",
    "href": "slides/00.html#pace",
    "title": "Club meetings",
    "section": "Pace",
    "text": "Pace\n\nGoal: 1 chapter/week\nOk to split overwhelming chapters\nOk to combine short chapters\nMeet every week except holidays, etc\n\nWe will meet even if scheduled presenter unavailable\nPush to finish before Daylight Savings Madness March 8",
    "crumbs": [
      "Club meetings"
    ]
  },
  {
    "objectID": "slides/00.html#learning-objectives-los",
    "href": "slides/00.html#learning-objectives-los",
    "title": "Club meetings",
    "section": "Learning objectives (LOs)",
    "text": "Learning objectives (LOs)\n\nStudents who study with LOs in mind retain more\nTips:\n\nThink ‚ÄúAfter today‚Äôs session, you will be able to {LO}‚Äù\nVery roughly 1 per heading",
    "crumbs": [
      "Club meetings"
    ]
  },
  {
    "objectID": "slides/00.html#group-introductions",
    "href": "slides/00.html#group-introductions",
    "title": "Club meetings",
    "section": "Group introductions",
    "text": "Group introductions\n\nIf you feel comfortable sharing:\n\nWho are you?\nWhere you calling in from? (If you‚Äôre not comfortable sharing, skip)\nHow long have you been using R?\nWhat was your introduction to R?\nWhat are you most looking forward to during the club?",
    "crumbs": [
      "Club meetings"
    ]
  },
  {
    "objectID": "slides/02.html#learning-objectives",
    "href": "slides/02.html#learning-objectives",
    "title": "Names and values",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nDistinguish between an object and its name.\nIdentify when data are copied versus modified.\nTrace and identify the memory used by R.\n\nThe {lobstr} package will help us throughout the chapter\n\nlibrary(lobstr)"
  },
  {
    "objectID": "slides/02.html#syntactic-names-are-easier-to-create-and-work-with-than-non-syntactic-names",
    "href": "slides/02.html#syntactic-names-are-easier-to-create-and-work-with-than-non-syntactic-names",
    "title": "Names and values",
    "section": "Syntactic names are easier to create and work with than non-syntactic names",
    "text": "Syntactic names are easier to create and work with than non-syntactic names\n\nSyntactic names: my_variable, x, cpp11, .by.\n\nCan‚Äôt use names in ?Reserved\n\nNon-syntactic names need to be surrounded in backticks."
  },
  {
    "objectID": "slides/02.html#names-are-bound-to-values-with--",
    "href": "slides/02.html#names-are-bound-to-values-with--",
    "title": "Names and values",
    "section": "Names are bound to values with <-",
    "text": "Names are bound to values with &lt;-\n\na &lt;- c(1, 2, 3)\na\n\n#&gt; [1] 1 2 3\n\nobj_addr(a)\n\n#&gt; [1] \"0x2226bfbc968\""
  },
  {
    "objectID": "slides/02.html#many-names-can-be-bound-to-the-same-values",
    "href": "slides/02.html#many-names-can-be-bound-to-the-same-values",
    "title": "Names and values",
    "section": "Many names can be bound to the same values",
    "text": "Many names can be bound to the same values\n\nb &lt;- a\nobj_addr(a)\n\n#&gt; [1] \"0x2226bfbc968\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x2226bfbc968\""
  },
  {
    "objectID": "slides/02.html#if-shared-values-are-modified-the-object-is-copied-to-a-new-address",
    "href": "slides/02.html#if-shared-values-are-modified-the-object-is-copied-to-a-new-address",
    "title": "Names and values",
    "section": "If shared values are modified, the object is copied to a new address",
    "text": "If shared values are modified, the object is copied to a new address\n\nb[[1]] &lt;- 5\nobj_addr(a)\n\n#&gt; [1] \"0x2226bfbc968\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x2226fda7278\""
  },
  {
    "objectID": "slides/02.html#memory-addresses-can-differ-even-if-objects-seem-the-same",
    "href": "slides/02.html#memory-addresses-can-differ-even-if-objects-seem-the-same",
    "title": "Names and values",
    "section": "Memory addresses can differ even if objects seem the same",
    "text": "Memory addresses can differ even if objects seem the same\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- 1:10\n\nobj_addr(a)\n\n#&gt; [1] \"0x22271c9e7b0\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x22271c9e7b0\"\n\nobj_addr(c)\n\n#&gt; [1] \"0x22271d77708\""
  },
  {
    "objectID": "slides/02.html#functions-have-a-single-address-regardless-of-how-theyre-referenced",
    "href": "slides/02.html#functions-have-a-single-address-regardless-of-how-theyre-referenced",
    "title": "Names and values",
    "section": "Functions have a single address regardless of how they‚Äôre referenced",
    "text": "Functions have a single address regardless of how they‚Äôre referenced\n\nobj_addr(mean)\n\n#&gt; [1] \"0x2226f891738\"\n\nobj_addr(base::mean)\n\n#&gt; [1] \"0x2226f891738\"\n\nobj_addr(get(\"mean\"))\n\n#&gt; [1] \"0x2226f891738\""
  },
  {
    "objectID": "slides/02.html#unlike-most-objects-environments-keep-the-same-memory-address-on-modify",
    "href": "slides/02.html#unlike-most-objects-environments-keep-the-same-memory-address-on-modify",
    "title": "Names and values",
    "section": "Unlike most objects, environments keep the same memory address on modify",
    "text": "Unlike most objects, environments keep the same memory address on modify\n\nd &lt;- new.env()\nobj_addr(d)\n\n#&gt; [1] \"0x2226b7489d8\"\n\ne &lt;- d\ne[['a']] &lt;- 1\nobj_addr(e)\n\n#&gt; [1] \"0x2226b7489d8\"\n\nobj_addr(d)\n\n#&gt; [1] \"0x2226b7489d8\"\n\nd[['a']]\n\n#&gt; [1] 1"
  },
  {
    "objectID": "slides/02.html#use-tracemem-to-validate-if-values-are-copied-or-modified",
    "href": "slides/02.html#use-tracemem-to-validate-if-values-are-copied-or-modified",
    "title": "Names and values",
    "section": "Use tracemem to validate if values are copied or modified",
    "text": "Use tracemem to validate if values are copied or modified\n\nx &lt;- runif(10)\ntracemem(x)\n#&gt; [1] \"&lt;000001F4185B4B08&gt;\"\ny &lt;- x\nx[[1]] &lt;- 10\n#&gt; tracemem[0x000001f4185b4b08 -&gt; 0x000001f4185b4218]:\nuntracemem(x)"
  },
  {
    "objectID": "slides/02.html#tracemem-shows-internal-c-code-minimizes-copying",
    "href": "slides/02.html#tracemem-shows-internal-c-code-minimizes-copying",
    "title": "Names and values",
    "section": "tracemem shows internal C code minimizes copying",
    "text": "tracemem shows internal C code minimizes copying\n\ny &lt;- as.list(x)\ntracemem(y)\n#&gt; [1] \"&lt;000001AD67FDCD38&gt;\"\nmedians &lt;- vapply(x, median, numeric(1))\nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x000001ad67fdcd38 -&gt; 0x000001ad61982638]:\nuntracemem(y)"
  },
  {
    "objectID": "slides/02.html#a-functions-environment-follows-copy-on-modify-rules",
    "href": "slides/02.html#a-functions-environment-follows-copy-on-modify-rules",
    "title": "Names and values",
    "section": "A function‚Äôs environment follows copy-on-modify rules",
    "text": "A function‚Äôs environment follows copy-on-modify rules\n\n\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\nz &lt;- f(x) # No change in value\n\nobj_addr(x)\n\n#&gt; [1] \"0x2226bdb8738\"\n\nobj_addr(z) # No address change \n\n#&gt; [1] \"0x2226bdb8738\"\n\n\n\n\n\n\n\nDiagrams will be explained more in chapter 7.\na points to same address as x.\nIf a modified inside function, z would have new address."
  },
  {
    "objectID": "slides/02.html#ref-shows-the-memory-address-of-a-list-and-its-elements",
    "href": "slides/02.html#ref-shows-the-memory-address-of-a-list-and-its-elements",
    "title": "Names and values",
    "section": "ref() shows the memory address of a list and its elements",
    "text": "ref() shows the memory address of a list and its elements\n\n\n\nl1 &lt;- list(1, 2, 3)\nobj_addr(l1)\n\n#&gt; [1] \"0x2226c315db8\"\n\nl2 &lt;- l1\nl2[[3]] &lt;- 4\nref(l1, l2)\n\n#&gt; ‚ñà [1:0x2226c315db8] &lt;list&gt; \n#&gt; ‚îú‚îÄ[2:0x2226c730078] &lt;dbl&gt; \n#&gt; ‚îú‚îÄ[3:0x2226c75cdc8] &lt;dbl&gt; \n#&gt; ‚îî‚îÄ[4:0x2226c75cc08] &lt;dbl&gt; \n#&gt;  \n#&gt; ‚ñà [5:0x2226c36cd68] &lt;list&gt; \n#&gt; ‚îú‚îÄ[2:0x2226c730078] \n#&gt; ‚îú‚îÄ[3:0x2226c75cdc8] \n#&gt; ‚îî‚îÄ[6:0x2226c75b318] &lt;dbl&gt;"
  },
  {
    "objectID": "slides/02.html#since-dataframes-are-lists-of-column-vectors-mutating-a-column-modifies-only-that-column",
    "href": "slides/02.html#since-dataframes-are-lists-of-column-vectors-mutating-a-column-modifies-only-that-column",
    "title": "Names and values",
    "section": "Since dataframes are lists of (column) vectors, mutating a column modifies only that column",
    "text": "Since dataframes are lists of (column) vectors, mutating a column modifies only that column\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\nref(d1, d2)\n\n#&gt; ‚ñà [1:0x2226cca93c8] &lt;df[,2]&gt; \n#&gt; ‚îú‚îÄx = [2:0x22272216148] &lt;dbl&gt; \n#&gt; ‚îî‚îÄy = [3:0x222722160f8] &lt;dbl&gt; \n#&gt;  \n#&gt; ‚ñà [4:0x2226ce0cf48] &lt;df[,2]&gt; \n#&gt; ‚îú‚îÄx = [2:0x22272216148] \n#&gt; ‚îî‚îÄy = [5:0x222727b0c38] &lt;dbl&gt;"
  },
  {
    "objectID": "slides/02.html#since-dataframes-are-lists-of-column-vectors-mutating-a-row-modifies-the-value",
    "href": "slides/02.html#since-dataframes-are-lists-of-column-vectors-mutating-a-row-modifies-the-value",
    "title": "Names and values",
    "section": "Since dataframes are lists of (column) vectors, mutating a row modifies the value",
    "text": "Since dataframes are lists of (column) vectors, mutating a row modifies the value\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 &lt;- d1\nd2[1, ] &lt;- d2[1, ] * 2\nref(d1, d2)\n\n#&gt; ‚ñà [1:0x22272912588] &lt;df[,2]&gt; \n#&gt; ‚îú‚îÄx = [2:0x222730bd408] &lt;dbl&gt; \n#&gt; ‚îî‚îÄy = [3:0x222730bd3b8] &lt;dbl&gt; \n#&gt;  \n#&gt; ‚ñà [4:0x22272b0e548] &lt;df[,2]&gt; \n#&gt; ‚îú‚îÄx = [5:0x222731501d8] &lt;dbl&gt; \n#&gt; ‚îî‚îÄy = [6:0x22273150188] &lt;dbl&gt;\n\n\n\n\nHere ‚Äúmutate‚Äù means ‚Äúchange‚Äù, not dplyr::mutate()"
  },
  {
    "objectID": "slides/02.html#characters-are-unique-due-to-the-global-string-pool",
    "href": "slides/02.html#characters-are-unique-due-to-the-global-string-pool",
    "title": "Names and values",
    "section": "Characters are unique due to the global string pool",
    "text": "Characters are unique due to the global string pool\n\n\n\nx &lt;- 1:4\nref(x)\n\n#&gt; [1:0x22272f78460] &lt;int&gt;\n\ny &lt;- 1:4\nref(y)\n\n#&gt; [1:0x222730899d8] &lt;int&gt;\n\nx &lt;- c(\"a\", \"a\", \"b\")\nref(x, character = TRUE)\n\n#&gt; ‚ñà [1:0x2227394f1d8] &lt;chr&gt; \n#&gt; ‚îú‚îÄ[2:0x22267d9b118] &lt;string: \"a\"&gt; \n#&gt; ‚îú‚îÄ[2:0x22267d9b118] \n#&gt; ‚îî‚îÄ[3:0x2226e17f3b8] &lt;string: \"b\"&gt;\n\ny &lt;- c(\"a\")\nref(y, character = TRUE)\n\n#&gt; ‚ñà [1:0x2227397fce8] &lt;chr&gt; \n#&gt; ‚îî‚îÄ[2:0x22267d9b118] &lt;string: \"a\"&gt;\n\n\n\n\n\n\n\n‚Äúa‚Äù is always at the same address.\nEach member of character vector has its own address (kind of list-like)."
  },
  {
    "objectID": "slides/02.html#memory-amount-can-also-be-measured-using-lobstrobj_size",
    "href": "slides/02.html#memory-amount-can-also-be-measured-using-lobstrobj_size",
    "title": "Names and values",
    "section": "Memory amount can also be measured, using lobstr::obj_size",
    "text": "Memory amount can also be measured, using lobstr::obj_size\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_addr(banana)\n\n#&gt; [1] \"0x22271bc25b8\"\n\nobj_size(banana)\n\n#&gt; 136 B"
  },
  {
    "objectID": "slides/02.html#alternative-representation-or-altreps-represent-vector-values-efficiently",
    "href": "slides/02.html#alternative-representation-or-altreps-represent-vector-values-efficiently",
    "title": "Names and values",
    "section": "Alternative Representation or ALTREPs represent vector values efficiently",
    "text": "Alternative Representation or ALTREPs represent vector values efficiently\n\nx &lt;- 1:10\nobj_size(x)\n\n#&gt; 680 B\n\ny &lt;- 1:10000\nobj_size(y)\n\n#&gt; 680 B"
  },
  {
    "objectID": "slides/02.html#we-can-measure-memory-speed-using-benchmark",
    "href": "slides/02.html#we-can-measure-memory-speed-using-benchmark",
    "title": "Names and values",
    "section": "We can measure memory & speed using bench::mark()",
    "text": "We can measure memory & speed using bench::mark()\n\nmed &lt;- function(d, medians) {\n  for (i in seq_along(medians)) {\n    d[[i]] &lt;- d[[i]] - medians[[i]]\n  }\n}\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\ny &lt;- as.list(x)\n\nbench::mark(\n  \"data.frame\" = med(x, medians),\n  \"list\" = med(y, medians)\n)[, c(\"min\", \"median\", \"mem_alloc\")]\n\n#&gt; # A tibble: 2 √ó 3\n#&gt;        min   median mem_alloc\n#&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:byt&gt;\n#&gt; 1   52.7¬µs   66.6¬µs     491KB\n#&gt; 2   22.8¬µs   33.7¬µs     391KB\n\n\n\n\nThe thing to see: list version uses less RAM and is faster"
  },
  {
    "objectID": "slides/02.html#the-garbage-collector-gc-explicitly-clears-out-unbound-objects",
    "href": "slides/02.html#the-garbage-collector-gc-explicitly-clears-out-unbound-objects",
    "title": "Names and values",
    "section": "The garbage collector gc() explicitly clears out unbound objects",
    "text": "The garbage collector gc() explicitly clears out unbound objects\n\nx &lt;- 1:3\nx &lt;- 2:4 # \"1:3\" is orphaned\nrm(x) # \"2:4\" is orphaned\ngc()\n\n#&gt;           used (Mb) gc trigger (Mb) max used (Mb)\n#&gt; Ncells  791104 42.3    1505464 80.5  1505464 80.5\n#&gt; Vcells 1497631 11.5    8388608 64.0  8388482 64.0\n\nlobstr::mem_used() # Wrapper around gc()\n\n#&gt; 56.29 MB\n\n\n\n\n\nmem_used() multiplies Ncells ‚Äúused‚Äù by either 28 (32-bit architecture) or 56 (64-bit architecture)., and Vcells ‚Äúused‚Äù by 8, adds them, and converts to Mb.\n\n\n\n\n\ngc() runs automatically, never need to call"
  },
  {
    "objectID": "slides/04.html#learning-objectives",
    "href": "slides/04.html#learning-objectives",
    "title": "Subsetting",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nSelect multiple elements from a vector with [\nSelect single elements from a vector with [[ and $\nAssign to subsets of vectors\nUse subsetting to expand data"
  },
  {
    "objectID": "slides/04.html#positive-integers-return-elements-at-specified-positions",
    "href": "slides/04.html#positive-integers-return-elements-at-specified-positions",
    "title": "Subsetting",
    "section": "1. Positive integers return elements at specified positions",
    "text": "1. Positive integers return elements at specified positions\n\nx &lt;- c(1.1, 2.2, 3.3, 4.4) # decimal = original position\nx\n\n#&gt; [1] 1.1 2.2 3.3 4.4\n\nx[c(4, 1)]\n\n#&gt; [1] 4.4 1.1\n\nx[c(1, 1, 1)]\n\n#&gt; [1] 1.1 1.1 1.1\n\nx[c(1.9999)]\n\n#&gt; [1] 1.1\n\n\nReals truncate to integers.\n\nx[c(1.0001, 1.9999)]\n\n#&gt; [1] 1.1 1.1"
  },
  {
    "objectID": "slides/04.html#negative-integers-remove-specified-elements",
    "href": "slides/04.html#negative-integers-remove-specified-elements",
    "title": "Subsetting",
    "section": "2. Negative integers remove specified elements",
    "text": "2. Negative integers remove specified elements\n\nx[-c(1, 3)] # same as x[c(-1, -3)] or x[c(2, 4)]\n\n#&gt; [1] 2.2 4.4"
  },
  {
    "objectID": "slides/04.html#b.-mixing-negative-and-positive-integers-throws-an-error",
    "href": "slides/04.html#b.-mixing-negative-and-positive-integers-throws-an-error",
    "title": "Subsetting",
    "section": "2b. Mixing negative and positive integers throws an error",
    "text": "2b. Mixing negative and positive integers throws an error\n\nx[c(-1, 3)]\n\n#&gt; Error in x[c(-1, 3)]: only 0's may be mixed with negative subscripts"
  },
  {
    "objectID": "slides/04.html#c.-zeros-ignored-with-other-ints",
    "href": "slides/04.html#c.-zeros-ignored-with-other-ints",
    "title": "Subsetting",
    "section": "2c. Zeros ignored with other ints",
    "text": "2c. Zeros ignored with other ints\n\nx[c(-1, 0)]\n\n#&gt; [1] 2.2 3.3 4.4\n\nx[c(-1, 0, 0, 0, 0, 0 ,0 ,0)]\n\n#&gt; [1] 2.2 3.3 4.4\n\nx[c(1, 0, 2, 0, 3, 0)]\n\n#&gt; [1] 1.1 2.2 3.3"
  },
  {
    "objectID": "slides/04.html#logical-vectors-select-specified-elements",
    "href": "slides/04.html#logical-vectors-select-specified-elements",
    "title": "Subsetting",
    "section": "3. Logical vectors select specified elements",
    "text": "3. Logical vectors select specified elements\n\nx[c(TRUE, TRUE, FALSE, TRUE)]\n\n#&gt; [1] 1.1 2.2 4.4\n\nx[x &lt; 3]\n\n#&gt; [1] 1.1 2.2\n\ncond &lt;- x &gt; 2.5\nx[cond]\n\n#&gt; [1] 3.3 4.4"
  },
  {
    "objectID": "slides/04.html#b.-shorter-element-are-recycled-to-higher-length",
    "href": "slides/04.html#b.-shorter-element-are-recycled-to-higher-length",
    "title": "Subsetting",
    "section": "3b. Shorter element are recycled to higher length",
    "text": "3b. Shorter element are recycled to higher length\n\nx[FALSE]\n\n#&gt; numeric(0)\n\nx[TRUE]\n\n#&gt; [1] 1.1 2.2 3.3 4.4\n\nx[c(FALSE, TRUE)] # equivalent to: x[c(FALSE, TRUE, FALSE, TRUE)]\n\n#&gt; [1] 2.2 4.4\n\n\n\nEasy to understand if x or y is 1, best to avoid other lengths"
  },
  {
    "objectID": "slides/04.html#c.-na-index-returns-na",
    "href": "slides/04.html#c.-na-index-returns-na",
    "title": "Subsetting",
    "section": "3c. NA index returns NA",
    "text": "3c. NA index returns NA\n\nx[c(NA, TRUE, NA, TRUE)]\n\n#&gt; [1]  NA 2.2  NA 4.4"
  },
  {
    "objectID": "slides/04.html#d.-extra-true-index-returns-na",
    "href": "slides/04.html#d.-extra-true-index-returns-na",
    "title": "Subsetting",
    "section": "3d. Extra TRUE index returns NA",
    "text": "3d. Extra TRUE index returns NA\n\nx[c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE)]\n\n#&gt; [1] 2.2 3.3 4.4  NA  NA\n\nx[1:5]\n\n#&gt; [1] 1.1 2.2 3.3 4.4  NA"
  },
  {
    "objectID": "slides/04.html#indexing-with-nothing-returns-original-vector",
    "href": "slides/04.html#indexing-with-nothing-returns-original-vector",
    "title": "Subsetting",
    "section": "4. Indexing with nothing returns original vector",
    "text": "4. Indexing with nothing returns original vector\n\nx[]\n\n#&gt; [1] 1.1 2.2 3.3 4.4"
  },
  {
    "objectID": "slides/04.html#indexing-with-just-0-returns-0-length-vector-with-class",
    "href": "slides/04.html#indexing-with-just-0-returns-0-length-vector-with-class",
    "title": "Subsetting",
    "section": "5. Indexing with just 0 returns 0-length vector (with class)",
    "text": "5. Indexing with just 0 returns 0-length vector (with class)\n\nx[0]\n\n#&gt; numeric(0)\n\nletters[0]\n\n#&gt; character(0)"
  },
  {
    "objectID": "slides/04.html#indexing-with-character-vector-returns-element-of-named-vector",
    "href": "slides/04.html#indexing-with-character-vector-returns-element-of-named-vector",
    "title": "Subsetting",
    "section": "6. Indexing with character vector returns element of named vector",
    "text": "6. Indexing with character vector returns element of named vector\n\n(y &lt;- setNames(x, letters[1:4]))\n\n#&gt;   a   b   c   d \n#&gt; 1.1 2.2 3.3 4.4\n\ny[c(\"d\", \"b\", \"a\")]\n\n#&gt;   d   b   a \n#&gt; 4.4 2.2 1.1\n\ny[c(\"a\", \"a\", \"a\")]\n\n#&gt;   a   a   a \n#&gt; 1.1 1.1 1.1"
  },
  {
    "objectID": "slides/04.html#b.-names-must-be-exact-for",
    "href": "slides/04.html#b.-names-must-be-exact-for",
    "title": "Subsetting",
    "section": "6b. Names must be exact for [",
    "text": "6b. Names must be exact for [\n\nz &lt;- c(abc = 1, def = 2)\nz\n\n#&gt; abc def \n#&gt;   1   2\n\nz[c(\"a\", \"d\")]\n\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA"
  },
  {
    "objectID": "slides/04.html#subsetting-a-list-with-returns-a-list",
    "href": "slides/04.html#subsetting-a-list-with-returns-a-list",
    "title": "Subsetting",
    "section": "Subsetting a list with [ returns a list",
    "text": "Subsetting a list with [ returns a list\n\nmy_list &lt;- list(a = c(T, F), b = letters[5:15], c = 100:108)\nmy_list\n\n#&gt; $a\n#&gt; [1]  TRUE FALSE\n#&gt; \n#&gt; $b\n#&gt;  [1] \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\"\n#&gt; \n#&gt; $c\n#&gt; [1] 100 101 102 103 104 105 106 107 108\n\nmy_list[c(\"a\", \"b\")]\n\n#&gt; $a\n#&gt; [1]  TRUE FALSE\n#&gt; \n#&gt; $b\n#&gt;  [1] \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\""
  },
  {
    "objectID": "slides/04.html#lists-use-same-rules-for",
    "href": "slides/04.html#lists-use-same-rules-for",
    "title": "Subsetting",
    "section": "Lists use same rules for [",
    "text": "Lists use same rules for [\n\nmy_list[2:3]\n\n#&gt; $b\n#&gt;  [1] \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\"\n#&gt; \n#&gt; $c\n#&gt; [1] 100 101 102 103 104 105 106 107 108\n\nmy_list[c(TRUE, FALSE, TRUE)]\n\n#&gt; $a\n#&gt; [1]  TRUE FALSE\n#&gt; \n#&gt; $c\n#&gt; [1] 100 101 102 103 104 105 106 107 108"
  },
  {
    "objectID": "slides/04.html#matrices-arrays-take-multidimensional-indices",
    "href": "slides/04.html#matrices-arrays-take-multidimensional-indices",
    "title": "Subsetting",
    "section": "Matrices & arrays take multidimensional indices",
    "text": "Matrices & arrays take multidimensional indices\n\na &lt;- matrix(1:9, nrow = 3)\na\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    4    7\n#&gt; [2,]    2    5    8\n#&gt; [3,]    3    6    9\n\na[1:2, 2:3] # rows, columns\n\n#&gt;      [,1] [,2]\n#&gt; [1,]    4    7\n#&gt; [2,]    5    8"
  },
  {
    "objectID": "slides/04.html#matrices-arrays-can-accept-character-logical-etc",
    "href": "slides/04.html#matrices-arrays-can-accept-character-logical-etc",
    "title": "Subsetting",
    "section": "Matrices & arrays can accept character, logical, etc",
    "text": "Matrices & arrays can accept character, logical, etc\n\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[c(TRUE, TRUE, FALSE), c(\"B\", \"A\")] # a[1:2, 2:1]\n\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 5 2"
  },
  {
    "objectID": "slides/04.html#matrices-arrays-are-also-vectors",
    "href": "slides/04.html#matrices-arrays-are-also-vectors",
    "title": "Subsetting",
    "section": "Matrices & arrays are also vectors",
    "text": "Matrices & arrays are also vectors\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\") # All chr combos of 1:5\nvals\n\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n\n#&gt; [1] \"4,1\" \"5,3\"\n\na[a &gt; 5]\n\n#&gt; [1] 6 7 8 9"
  },
  {
    "objectID": "slides/04.html#data-frames-subset-list-like-with-single-index",
    "href": "slides/04.html#data-frames-subset-list-like-with-single-index",
    "title": "Subsetting",
    "section": "Data frames subset list-like with single index",
    "text": "Data frames subset list-like with single index\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[1:2]\n\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\ndf[c(\"x\", \"z\")]\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c"
  },
  {
    "objectID": "slides/04.html#data-frames-subset-matrix-like-with-multiple-indices",
    "href": "slides/04.html#data-frames-subset-matrix-like-with-multiple-indices",
    "title": "Subsetting",
    "section": "Data frames subset matrix-like with multiple indices",
    "text": "Data frames subset matrix-like with multiple indices\n\ndf[1:2, c(\"x\", \"z\")] # rows, columns\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n\ndf[df$x == 2, ] # matching rows, all columns\n\n#&gt;   x y z\n#&gt; 2 2 2 b\n\ndf[, c(\"x\", \"z\")] # equivalent to no ,\n\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c"
  },
  {
    "objectID": "slides/04.html#subsetting-a-tibble-with-returns-a-tibble",
    "href": "slides/04.html#subsetting-a-tibble-with-returns-a-tibble",
    "title": "Subsetting",
    "section": "Subsetting a tibble with [ returns a tibble",
    "text": "Subsetting a tibble with [ returns a tibble\n\ntbl &lt;- tibble::as_tibble(df)\ndf[, 1]\n\n#&gt; [1] 1 2 3\n\ndf[, 1, drop = FALSE] # Prevent errors\n\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3\n\ntbl[, 1]\n\n#&gt; # A tibble: 3 √ó 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3"
  },
  {
    "objectID": "slides/04.html#selects-a-single-element",
    "href": "slides/04.html#selects-a-single-element",
    "title": "Subsetting",
    "section": "[[ selects a single element",
    "text": "[[ selects a single element\n\n\n\nx &lt;- list(1:3, \"a\", 4:6)\nx[1]\n\n#&gt; [[1]]\n#&gt; [1] 1 2 3\n\nclass(x[1])\n\n#&gt; [1] \"list\"\n\nx[[1]]\n\n#&gt; [1] 1 2 3\n\nclass(x[[1]])\n\n#&gt; [1] \"integer\"\n\nx[[1]][[1]]\n\n#&gt; [1] 1"
  },
  {
    "objectID": "slides/04.html#is-shorthand-for-...-exact-false",
    "href": "slides/04.html#is-shorthand-for-...-exact-false",
    "title": "Subsetting",
    "section": "$ is shorthand for [[..., exact = FALSE]]",
    "text": "$ is shorthand for [[..., exact = FALSE]]\n\nx &lt;- list(abc = 1)\nx$abc\n\n#&gt; [1] 1\n\nx$a\n\n#&gt; [1] 1\n\nx[[\"a\"]]\n\n#&gt; NULL\n\nx[[\"a\", exact = FALSE]]\n\n#&gt; [1] 1\n\noptions(warnPartialMatchDollar = TRUE)\nx$a\n\n#&gt; Warning in x$a: partial match of 'a' to 'abc'\n\n\n#&gt; [1] 1"
  },
  {
    "objectID": "slides/04.html#behavior-for-missing-ish-indices-is-inconsistent",
    "href": "slides/04.html#behavior-for-missing-ish-indices-is-inconsistent",
    "title": "Subsetting",
    "section": "Behavior for missing-ish indices is inconsistent",
    "text": "Behavior for missing-ish indices is inconsistent\n\na &lt;- c(a = 1L, b = 2L)\nlst &lt;- list(a = 1:2)\n\n# Errors:\n# a[[NULL]]\n# lst[[NULL]]\n# a[[5]]\n# lst[[5]]\n# a[[\"c\"]]\n# a[[NA]]\n\nlst[[\"c\"]]\n\n#&gt; NULL\n\nlst[[NA]]\n\n#&gt; NULL"
  },
  {
    "objectID": "slides/04.html#purrrpluck-and-purrrchuck-provide-consistent-wrappers",
    "href": "slides/04.html#purrrpluck-and-purrrchuck-provide-consistent-wrappers",
    "title": "Subsetting",
    "section": "purrr::pluck() and purrr::chuck() provide consistent wrappers",
    "text": "purrr::pluck() and purrr::chuck() provide consistent wrappers\n\npurrr::pluck() always returns NULL or .default for (non-NULL) missing\npurrr::chuck() always throws error\n\n\npurrr::pluck(a, 5)\n\n#&gt; NULL\n\npurrr::pluck(a, \"c\")\n\n#&gt; NULL\n\npurrr::pluck(lst, 5)\n\n#&gt; NULL\n\npurrr::pluck(lst, \"c\")\n\n#&gt; NULL"
  },
  {
    "objectID": "slides/04.html#s4-has-two-additional-subsetting-operators",
    "href": "slides/04.html#s4-has-two-additional-subsetting-operators",
    "title": "Subsetting",
    "section": "S4 has two additional subsetting operators",
    "text": "S4 has two additional subsetting operators\n\n@ equivalent to $ (but error if bad)\nslot() equivalent to [[\n\nMore in Chapter 15"
  },
  {
    "objectID": "slides/04.html#can-assign-to-position-with",
    "href": "slides/04.html#can-assign-to-position-with",
    "title": "Subsetting",
    "section": "Can assign to position with [",
    "text": "Can assign to position with [\n\nx &lt;- 1:5\nx[1:2] &lt;- c(101, 102)\nx\n\n#&gt; [1] 101 102   3   4   5\n\nx[1:3] &lt;- 1:2\nx\n\n#&gt; [1] 1 2 1 4 5"
  },
  {
    "objectID": "slides/04.html#remove-list-component-with-null",
    "href": "slides/04.html#remove-list-component-with-null",
    "title": "Subsetting",
    "section": "Remove list component with NULL",
    "text": "Remove list component with NULL\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nx\n\n#&gt; $a\n#&gt; [1] 1"
  },
  {
    "objectID": "slides/04.html#use-listnull-to-add-null",
    "href": "slides/04.html#use-listnull-to-add-null",
    "title": "Subsetting",
    "section": "Use list(NULL) to add NULL",
    "text": "Use list(NULL) to add NULL\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- list(NULL)\nx\n\n#&gt; $a\n#&gt; [1] 1\n#&gt; \n#&gt; $b\n#&gt; $b[[1]]\n#&gt; NULL"
  },
  {
    "objectID": "slides/04.html#subset-with-nothing-to-retain-shape",
    "href": "slides/04.html#subset-with-nothing-to-retain-shape",
    "title": "Subsetting",
    "section": "Subset with nothing to retain shape",
    "text": "Subset with nothing to retain shape\n\ndf &lt;- data.frame(a = 1:3, b = 1:3)\ndf[] &lt;- \"a\"\ndf\n\n#&gt;   a b\n#&gt; 1 a a\n#&gt; 2 a a\n#&gt; 3 a a\n\ndf &lt;- \"a\"\ndf\n\n#&gt; [1] \"a\""
  },
  {
    "objectID": "slides/04.html#use-a-lookup-vector-and-recycling-rules-to-translate-values",
    "href": "slides/04.html#use-a-lookup-vector-and-recycling-rules-to-translate-values",
    "title": "Subsetting",
    "section": "Use a lookup vector and recycling rules to translate values",
    "text": "Use a lookup vector and recycling rules to translate values\n\nx &lt;- c(\"b\", \"g\", \"x\", \"g\", \"g\", \"b\")\nlookup &lt;- c(b = \"blue\", g = \"green\", x = NA)\nlookup[x]\n\n#&gt;       b       g       x       g       g       b \n#&gt;  \"blue\" \"green\"      NA \"green\" \"green\"  \"blue\"\n\nunname(lookup[x])\n\n#&gt; [1] \"blue\"  \"green\" NA      \"green\" \"green\" \"blue\""
  },
  {
    "objectID": "slides/04.html#use-a-lookup-table-to-generate-rows-of-data",
    "href": "slides/04.html#use-a-lookup-table-to-generate-rows-of-data",
    "title": "Subsetting",
    "section": "Use a lookup table to generate rows of data",
    "text": "Use a lookup table to generate rows of data\n\ninfo &lt;- data.frame(\n  code = c(\"b\", \"g\", \"x\"),\n  color = c(\"blue\", \"green\", NA),\n  other_thing = 3:1\n)\nmatch(x, info$code) # Indices of info$code in x\n\n#&gt; [1] 1 2 3 2 2 1\n\ninfo[match(x, info$code), ]\n\n#&gt;     code color other_thing\n#&gt; 1      b  blue           3\n#&gt; 2      g green           2\n#&gt; 3      x  &lt;NA&gt;           1\n#&gt; 2.1    g green           2\n#&gt; 2.2    g green           2\n#&gt; 1.1    b  blue           3"
  },
  {
    "objectID": "slides/04.html#sort-with-order",
    "href": "slides/04.html#sort-with-order",
    "title": "Subsetting",
    "section": "Sort with order()",
    "text": "Sort with order()\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n\n#&gt; [1] 3 1 2\n\nx[order(x)]\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\ndf &lt;- data.frame(b = 3:1, a = 1:3)\ndf[order(df$b), ]\n\n#&gt;   b a\n#&gt; 3 1 3\n#&gt; 2 2 2\n#&gt; 1 3 1\n\ndf[, order(names(df))]\n\n#&gt;   a b\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1"
  },
  {
    "objectID": "slides/04.html#expand-counts",
    "href": "slides/04.html#expand-counts",
    "title": "Subsetting",
    "section": "Expand counts",
    "text": "Expand counts\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1"
  },
  {
    "objectID": "slides/04.html#ran-out-of-time-to-make-slides-for",
    "href": "slides/04.html#ran-out-of-time-to-make-slides-for",
    "title": "Subsetting",
    "section": "Ran out of time to make slides for",
    "text": "Ran out of time to make slides for\nIdeally a future cohort should expand these:\n\nRemove df columns with setdiff()\nLogically subset rows df[df$col &gt; 5, ]\nThe next slide about which()"
  },
  {
    "objectID": "slides/04.html#boolean-algebra-versus-sets-logical-and-integer",
    "href": "slides/04.html#boolean-algebra-versus-sets-logical-and-integer",
    "title": "Subsetting",
    "section": "Boolean algebra versus sets (logical and integer)",
    "text": "Boolean algebra versus sets (logical and integer)\n\nwhich() gives the indices of a Boolean vector\n\n\n(x1 &lt;- 1:10 %% 2 == 0) # 1-10 divisible by 2\n#  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n# [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0) # 1-10 divisible by 5\n#  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n# [1]  5 10\nx1 & y1\n# [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE"
  },
  {
    "objectID": "slides/06.html#learning-objectives",
    "href": "slides/06.html#learning-objectives",
    "title": "Functions",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nHow to make functions in R\nWhat are the parts of a function\nNested functions"
  },
  {
    "objectID": "slides/06.html#how-to-make-a-simple-function-in-r",
    "href": "slides/06.html#how-to-make-a-simple-function-in-r",
    "title": "Functions",
    "section": "How to make a simple function in R",
    "text": "How to make a simple function in R\nLet‚Äôs imagine the structure of a function:\n\nThe black dot on the left is the environment. The two blocks to the right are the function arguments.Function components\nFunctions have three parts, formals(), body(), and environment().\n\n\n\n\n\n\nExample\n\ncoffee_ratings%&gt;%slice(1:3)%&gt;%select(1:5)\n\n#&gt; # A tibble: 3 √ó 5\n#&gt;   total_cup_points species owner                    country_of_origin farm_name \n#&gt;              &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;                    &lt;chr&gt;             &lt;chr&gt;     \n#&gt; 1             90.6 Arabica metad plc                Ethiopia          \"metad pl‚Ä¶\n#&gt; 2             89.9 Arabica metad plc                Ethiopia          \"metad pl‚Ä¶\n#&gt; 3             89.8 Arabica grounds for health admin Guatemala         \"san marc‚Ä¶\n\n\n\navg_points &lt;- function(species){\n  # this function is for calculating the mean\n  avg &lt;-  coffee_ratings %&gt;% \n  filter(species == species) %&gt;% \n  summarise(mean = mean(total_cup_points))\n  \n  return(avg)\n}\n\n\navg_points(\"Arabica\")\n\n#&gt; # A tibble: 1 √ó 1\n#&gt;    mean\n#&gt;   &lt;dbl&gt;\n#&gt; 1  82.1\n\n\n\nformals(avg_points)\n\n#&gt; $species\n\n\n\nbody(avg_points)\n\n#&gt; {\n#&gt;     avg &lt;- coffee_ratings %&gt;% filter(species == species) %&gt;% \n#&gt;         summarise(mean = mean(total_cup_points))\n#&gt;     return(avg)\n#&gt; }\n\n\n\nenvironment(avg_points)\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nFunctions uses attributes, one attribute used by base R is srcref, short for source reference. It points to the source code used to create the function. It contains code comments and other formatting.\n\nattr(avg_points, \"srcref\")\n\n#&gt; NULL"
  },
  {
    "objectID": "slides/06.html#primitive-functions",
    "href": "slides/06.html#primitive-functions",
    "title": "Functions",
    "section": "Primitive functions",
    "text": "Primitive functions\nAre the core function in base R, such as sum()\n\nsum\n\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n\n\nType of primitives:\n\nbuiltin\nspecial\n\n\ntypeof(sum)\n\n#&gt; [1] \"builtin\"\n\n\nThese core functions have components to NULL."
  },
  {
    "objectID": "slides/06.html#anonymous-functions",
    "href": "slides/06.html#anonymous-functions",
    "title": "Functions",
    "section": "Anonymous functions",
    "text": "Anonymous functions\nIf you don‚Äôt provide a name to a function\n\nlapply(mtcars%&gt;%select(mpg,cyl), function(x) length(unique(x)))\n\n#&gt; $mpg\n#&gt; [1] 25\n#&gt; \n#&gt; $cyl\n#&gt; [1] 3\n\n\n\nvector_len &lt;- function(x) {\n  length(unique(x))\n}\n\n\nlapply(mtcars%&gt;%select(mpg,cyl), vector_len)\n\n#&gt; $mpg\n#&gt; [1] 25\n#&gt; \n#&gt; $cyl\n#&gt; [1] 3\n\n\nInvoking a function\n\nargs &lt;- unique(coffee_ratings$species) %&gt;% \n  `[[`(1) %&gt;% \n  as.list()\n  \n  \n  \ndo.call(avg_points, args)\n\n#&gt; # A tibble: 1 √ó 1\n#&gt;    mean\n#&gt;   &lt;dbl&gt;\n#&gt; 1  82.1"
  },
  {
    "objectID": "slides/06.html#function-composition",
    "href": "slides/06.html#function-composition",
    "title": "Functions",
    "section": "Function composition",
    "text": "Function composition\n\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\nx &lt;- runif(100)\nsqrt(mean(square(deviation(x))))\n\n#&gt; [1] 0.2841442\n\n\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n\n#&gt; [1] 0.2841442\n\n\n\nx %&gt;%\n  deviation() %&gt;%\n  square() %&gt;%\n  mean() %&gt;%\n  sqrt()\n\n#&gt; [1] 0.2841442"
  },
  {
    "objectID": "slides/06.html#more-about-functions-insights",
    "href": "slides/06.html#more-about-functions-insights",
    "title": "Functions",
    "section": "More about functions insights",
    "text": "More about functions insights\nLexical scoping\nRules\n\nName masking\nFunctions versus variables\nA fresh start\nDynamic lookup\n\nDebugging\nThis function\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n\n#&gt; [1] 16\n\n\n\ncodetools::findGlobals(g12)\n\n#&gt; [1] \"+\" \"x\"\n\n\nYou can change the function‚Äôs environment to an environment which contains nothing:\n\n# environment(g12) &lt;- emptyenv()\n# g12()\n# Error in x + 1 : could not find function \"+\"\n\n‚Ä¶ (dot-dot-dot)\nExample\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\nstr(i02(x = 1, y = 2, z = 3))\n\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\nExiting a function\n\nImplicit or explicit returns\nInvisibility (&lt;- most famous function that returns an invisible value)\nstop() to stop a function with an error.\nExit handlers\n\nFunction forms\n\nEverything that exists is an object. Everything that happens is a function call. ‚Äî John Chambers"
  },
  {
    "objectID": "slides/06.html#case-study-sir-model-function",
    "href": "slides/06.html#case-study-sir-model-function",
    "title": "Functions",
    "section": "Case Study: SIR model function",
    "text": "Case Study: SIR model function\nThis is an interesting example taken from a course on Coursera: Infectious disease modelling-ICL\nThe purpose of this example is to show how to make a model passing through making a function.\nFirst we need to load some useful libraries:\n\nlibrary(deSolve)\nlibrary(reshape2)\n\nThen set the model inputs:\n\npopulation size (N)\nnumber of susceptable (S)\ninfected (I)\nrecovered (R)\n\nAnd add the model parameters:\n\ninfection rate (\\(\\beta\\))\nrecovery rate (\\(\\gamma\\))\n\n\nN&lt;- 100000                  # population\n\nstate_values&lt;- c(S = N -1,   # susceptible\n                 I = 1,      # infected\n                 R = 0)      # recovered\n\nparameters&lt;- c(beta = 1/2,  # infection rate days^-1\n               gamma = 1/4) # recovery rate days^-1\n\nThen we set the time as an important factor, which defines the length of time we are looking at this model run. It is intended as the time range in which the infections spread out, let‚Äôs say that we are aiming to investigate an infection period of 100 days.\n\ntimes&lt;- seq(0, 100, by = 1)\n\nFinally, we set up the SIR model, the susceptable, infected and recovered model. How do we do that is passing the paramenters through a function of the time, and state.\nWithin the model function we calculate one more paramenter, the force of infection: \\(\\lambda\\)\n\nsir_model&lt;- function(time, state, parameters){\n  with(as.list(c(state, parameters)),{\n    N&lt;- S + I + R\n    lambda = beta * I/N    # force of infection\n    dS&lt;- - lambda * S \n    dI&lt;- lambda * S - gamma * I\n    dR&lt;- gamma * I\n    return(list(c(dS,dI,dR)))\n  })\n}\n\nOnce we have our SIR model function ready, we can calculate the output of the model, with the help of the function ode() from {deSolve} package.\n\noutput&lt;- as.data.frame(ode(y = state_values,\n                           times = times,\n                           func = sir_model,\n                           parms = parameters))\noutput %&gt;% head\n\n#&gt;   time        S        I         R\n#&gt; 1    0 99999.00 1.000000 0.0000000\n#&gt; 2    1 99998.43 1.284018 0.2840252\n#&gt; 3    2 99997.70 1.648696 0.6487171\n#&gt; 4    3 99996.77 2.116939 1.1169863\n#&gt; 5    4 99995.56 2.718152 1.7182450\n#&gt; 6    5 99994.02 3.490086 2.4902600\n\n\nIn addition to our builtin SIR model function we can have a look at:\n\n?deSolve::ode()\n\nIt solves Ordinary Differential Equations.\n\ndeSolve:::ode\n\n#&gt; function (y, times, func, parms, method = c(\"lsoda\", \"lsode\", \n#&gt;     \"lsodes\", \"lsodar\", \"vode\", \"daspk\", \"euler\", \"rk4\", \"ode23\", \n#&gt;     \"ode45\", \"radau\", \"bdf\", \"bdf_d\", \"adams\", \"impAdams\", \"impAdams_d\", \n#&gt;     \"iteration\"), ...) \n#&gt; {\n#&gt;     if (is.null(method)) \n#&gt;         method &lt;- \"lsoda\"\n#&gt;     if (is.list(method)) {\n#&gt;         if (!inherits(method, \"rkMethod\")) \n#&gt;             stop(\"'method' should be given as string or as a list of class 'rkMethod'\")\n#&gt;         out &lt;- rk(y, times, func, parms, method = method, ...)\n#&gt;     }\n#&gt;     else if (is.function(method)) \n#&gt;         out &lt;- method(y, times, func, parms, ...)\n#&gt;     else if (is.complex(y)) \n#&gt;         out &lt;- switch(match.arg(method), vode = zvode(y, times, \n#&gt;             func, parms, ...), bdf = zvode(y, times, func, parms, \n#&gt;             mf = 22, ...), bdf_d = zvode(y, times, func, parms, \n#&gt;             mf = 23, ...), adams = zvode(y, times, func, parms, \n#&gt;             mf = 10, ...), impAdams = zvode(y, times, func, parms, \n#&gt;             mf = 12, ...), impAdams_d = zvode(y, times, func, \n#&gt;             parms, mf = 13, ...))\n#&gt;     else out &lt;- switch(match.arg(method), lsoda = lsoda(y, times, \n#&gt;         func, parms, ...), vode = vode(y, times, func, parms, \n#&gt;         ...), lsode = lsode(y, times, func, parms, ...), lsodes = lsodes(y, \n#&gt;         times, func, parms, ...), lsodar = lsodar(y, times, func, \n#&gt;         parms, ...), daspk = daspk(y, times, func, parms, ...), \n#&gt;         euler = rk(y, times, func, parms, method = \"euler\", ...), \n#&gt;         rk4 = rk(y, times, func, parms, method = \"rk4\", ...), \n#&gt;         ode23 = rk(y, times, func, parms, method = \"ode23\", ...), \n#&gt;         ode45 = rk(y, times, func, parms, method = \"ode45\", ...), \n#&gt;         radau = radau(y, times, func, parms, ...), bdf = lsode(y, \n#&gt;             times, func, parms, mf = 22, ...), bdf_d = lsode(y, \n#&gt;             times, func, parms, mf = 23, ...), adams = lsode(y, \n#&gt;             times, func, parms, mf = 10, ...), impAdams = lsode(y, \n#&gt;             times, func, parms, mf = 12, ...), impAdams_d = lsode(y, \n#&gt;             times, func, parms, mf = 13, ...), iteration = iteration(y, \n#&gt;             times, func, parms, ...))\n#&gt;     return(out)\n#&gt; }\n#&gt; &lt;bytecode: 0x0000022b02095d58&gt;\n#&gt; &lt;environment: namespace:deSolve&gt;\n\n\n\nmethods(\"ode\")\n\n#&gt; Warning in .S3methods(generic.function, class, envir, all.names = all.names, :\n#&gt; function 'ode' appears not to be S3 generic; found functions that look like S3\n#&gt; methods\n\n\n#&gt; [1] ode.1D   ode.2D   ode.3D   ode.band\n#&gt; see '?methods' for accessing help and source code"
  },
  {
    "objectID": "slides/08.html#learning-objectives",
    "href": "slides/08.html#learning-objectives",
    "title": "Conditions",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nWhat conditions are\nHow to use them"
  },
  {
    "objectID": "slides/08.html#introduction",
    "href": "slides/08.html#introduction",
    "title": "Conditions",
    "section": "Introduction",
    "text": "Introduction\nWhat are conditions? Problems that happen in functions:\n\nError\nWarning\nMessage\n\nAs a function author, one can signal them‚Äìthat is, say there‚Äôs a problem.\nAs a function consumer, one can handle them‚Äìfor example, react or ignore."
  },
  {
    "objectID": "slides/08.html#signalling-conditions",
    "href": "slides/08.html#signalling-conditions",
    "title": "Conditions",
    "section": "Signalling conditions",
    "text": "Signalling conditions\nTypes of conditions\nThree types of conditions:\n\n‚ùå Errors. Problem arose, and the function cannot continue.\n‚ö†Ô∏è Warnings. Problem arose, but the function can continue, if only partially.\nüí¨ Messages. Something happened, and the user should know.\n\n‚ùå Errors\nHow to throw errors\n\n# with base R\nstop(\"... in the name of love...\")\n\n#&gt; Error: ... in the name of love...\n\n# with rlang\nrlang::abort(\"...before you break my heart...\")\n\n#&gt; Error:\n#&gt; ! ...before you break my heart...\n\n# with base R; without call\nstop(\"... think it o-o-over...\", call. = FALSE)\n\n#&gt; Error: ... think it o-o-over...\n\n\nComposing error messages\n\nMechanics.\n\nstop() pastes together arguments\n\n\n\nsome_val &lt;- 1\nstop(\"Your value is: \", some_val, call. = FALSE)\n\n#&gt; Error: Your value is: 1\n\n\n\nabort() requires {glue}\n\n\nsome_val &lt;- 1\nrlang::abort(glue::glue(\"Your value is: {some_val}\"))\n\n#&gt; Error:\n#&gt; ! Your value is: 1\n\n\n\nStyle. See here.\n\n‚ö†Ô∏è Warnings\nMay have multiple warnings per call\n\nwarn &lt;- function() {\n  warning(\"This is your first warning\")\n  warning(\"This is your second warning\")\n  warning(\"This is your LAST warning\")\n}\n\nPrint all warnings once call is complete.\n\nwarn()\n\n#&gt; Warning in warn(): This is your first warning\n\n\n#&gt; Warning in warn(): This is your second warning\n\n\n#&gt; Warning in warn(): This is your LAST warning\n\n\nLike errors, warning() has\n\na call argument\nan {rlang} analog\n\n\n# base R\n# ... with call (implicitly .call = TRUE)\nwarning(\"Warning\")\n\n#&gt; Warning: Warning\n\n# ... with call suppressed\nwarning(\"Warning\", call. = FALSE)\n\n#&gt; Warning: Warning\n\n# rlang\n# note: call suppressed by default\nrlang::warn(\"Warning\")\n\n#&gt; Warning: Warning\n\n\n(Hadley‚Äôs) advice on usage:\n\nErr on the side of errors. In other words, error rather than warn.\nBut warnings make sense in a few cases:\n\nFunction is being deprecated. Warn that it is reaching end of life.\nFunction is reasonably sure to recover from issue.\n\n\nüí¨ Messages\nMechanics:\n\nIssued immediately\nDo not have a call argument\n\nStyle:\nMessages are best when they inform about:\n\nDefault arguments\nStatus updates of for functions used primarily for side-effects (e.g., interaction with web API, file downloaded, etc.)\nProgress of long-running process (in the absence of a status bar).\nPackage loading message (e.g., attaching package, objects masked)"
  },
  {
    "objectID": "slides/08.html#ignoring-conditions",
    "href": "slides/08.html#ignoring-conditions",
    "title": "Conditions",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nA few ways:\n\ntry()\nsuppressWarnings()\nsuppressMessages()\n\ntry()\nWhat it does:\n\nDisplays error\nBut continues execution after error\n\n\nbad_log &lt;- function(x) {\n  try(log(x))\n  10\n}\n\nbad_log(\"bad\")\n\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n\n\n#&gt; [1] 10\n\n\nBetter ways to react to/recover from errors:\n\nUse tryCatch() to ‚Äúcatch‚Äù the error and perform a different action in the event of an error.\nSet a default value inside the call. See below.\n\n\ndefault &lt;- NULL\ntry(default &lt;- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n\n#&gt; Warning in file(file, \"rt\"): cannot open file 'possibly-bad-input.csv': No such\n#&gt; file or directory\n\n\nsuppressWarnings(), suppressMessages()\nWhat it does:\n\nSupresses all warnings (messages)\n\n\n# suppress warnings (from our `warn()` function above)\nsuppressWarnings(warn())\n\n# suppress messages\nmany_messages &lt;- function() {\n  message(\"Message 1\")\n  message(\"Message 2\")\n  message(\"Message 3\")\n}\n\nsuppressMessages(many_messages())"
  },
  {
    "objectID": "slides/08.html#handling-conditions",
    "href": "slides/08.html#handling-conditions",
    "title": "Conditions",
    "section": "Handling conditions",
    "text": "Handling conditions\nEvery condition has a default behavior:\n\n‚ùå Errors halt execution\n‚ö†Ô∏è Warnings are collected during execution and displayed in bulk after execution\nüí¨ Messages are displayed immediately\n\nCondition handlers allow one to change that behavior (within the scope of a function).\nTwo handler functions:\n\ntryCatch()\nwithCallingHandlers()\n\n\n# try to run `code_to_try_to_run`\n# if (error) condition is signalled, fun some other code\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_try_to_run\n)\n\n# try to `code_to_try_to_run`\n# if condition is signalled, run code corresponding to condition type\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_try_to_run\n)\n\nCondition objects\n\n# catch a condition\ncnd &lt;- rlang::catch_cnd(stop(\"An error\"))\n# inspect it\nstr(cnd)\n\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n\nThe standard components\n\nmessage. The error message. To extract it, use conditionMessage(cnd).\ncall. The function call that triggered the condition. To extract it, use conditionCall(cnd).\n\nBut custom conditions may contain other components.\nExiting handlers\nIf a condition is signalled, this type of handler controls what code to run before exiting the function call.\n\nf3 &lt;- function(x) {\n  tryCatch(\n    # if error signalled, return NA\n    error = function(cnd) NA,\n    # try to run log\n    log(x)\n  )\n}\n\nf3(\"x\")\n\n#&gt; [1] NA\n\n\nWhen a condition is signalled, control moves to the handler and never returns to the original code.\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n\n#&gt; [1] \"There\"\n\n\nThe tryCatch() exit handler has one final argument: finally. This is run regardless of the condition of the original code. This is often used for clean-up.\n\n# try to write text to disk\n# if an error is signalled--for example, `path` does not exist\n# or if no condition is signalled\n# that is in both cases, the code block in `finally` is executed\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\nCalling handlers\nDefinition by verbal comparison:\n\nWith exit handlers, code exits the normal flow once a condition is signalled\nWith calling handlers, code continues in the normal flow once control is returned by the handler.\n\nDefinition by code comparison:\n\n# with an exit handler, control moves to the handler once condition signalled and does not move back\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\n#&gt; Caught a message!\n\n# with a calling handler, control moves first to the handler and the moves back to the main code\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\n#&gt; Caught a message!\n\n\n#&gt; Someone there?\n\n\n#&gt; Caught a message!\n\n\n#&gt; Why, yes!\n\n\nBy default, conditions propagate\nLet‚Äôs suppose that there are nested handlers. If a condition is signalled in the child, it propagates to its parent handler(s).\n\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\n#&gt; Level 1\n#&gt; Level 2\n\n\n#&gt; Hello\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\n#&gt; Level 1\n#&gt; Level 2\n\n\nBut conditions can be muffled\nIf one wants to ‚Äúmuffle‚Äù the siginal, one needs to use rlang::cnd_muffle()\n\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    rlang::cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n\n#&gt; Level 1\n#&gt; Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      rlang::cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n\n#&gt; Level 1\n\n\nCall stacks\nCall stacks of exiting and calling handlers differ.\nWhy?\n\nCalling handlers are called in the context of the call that signalled the condition exiting handlers are called in the context of the call to tryCatch()\n\nTo see this, consider how the call stacks differ for a toy example.\n\n# create a function\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message\n\n# call stack of calling handlers\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  rlang::cnd_muffle(cnd)\n})\n\n#&gt; function (..., domain = NULL, appendLF = TRUE) \n#&gt; {\n#&gt;     cond &lt;- if (...length() == 1L && inherits(..1, \"condition\")) {\n#&gt;         if (nargs() &gt; 1L) \n#&gt;             warning(\"additional arguments ignored in message()\")\n#&gt;         ..1\n#&gt;     }\n#&gt;     else {\n#&gt;         msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF)\n#&gt;         call &lt;- sys.call()\n#&gt;         simpleMessage(msg, call)\n#&gt;     }\n#&gt;     defaultHandler &lt;- function(c) {\n#&gt;         cat(conditionMessage(c), file = stderr(), sep = \"\")\n#&gt;     }\n#&gt;     withRestarts({\n#&gt;         signalCondition(cond)\n#&gt;         defaultHandler(cond)\n#&gt;     }, muffleMessage = function() NULL)\n#&gt;     invisible()\n#&gt; }\n#&gt; &lt;bytecode: 0x000002ba6a952b98&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n# call stack of exit handlers\ntryCatch(f(), message = function(cnd) lobstr::cst())\n\n#&gt; function (..., domain = NULL, appendLF = TRUE) \n#&gt; {\n#&gt;     cond &lt;- if (...length() == 1L && inherits(..1, \"condition\")) {\n#&gt;         if (nargs() &gt; 1L) \n#&gt;             warning(\"additional arguments ignored in message()\")\n#&gt;         ..1\n#&gt;     }\n#&gt;     else {\n#&gt;         msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF)\n#&gt;         call &lt;- sys.call()\n#&gt;         simpleMessage(msg, call)\n#&gt;     }\n#&gt;     defaultHandler &lt;- function(c) {\n#&gt;         cat(conditionMessage(c), file = stderr(), sep = \"\")\n#&gt;     }\n#&gt;     withRestarts({\n#&gt;         signalCondition(cond)\n#&gt;         defaultHandler(cond)\n#&gt;     }, muffleMessage = function() NULL)\n#&gt;     invisible()\n#&gt; }\n#&gt; &lt;bytecode: 0x000002ba6a952b98&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\ntryCatch(f(), message = function(cnd) lobstr::cst())\n\n#&gt; function (..., domain = NULL, appendLF = TRUE) \n#&gt; {\n#&gt;     cond &lt;- if (...length() == 1L && inherits(..1, \"condition\")) {\n#&gt;         if (nargs() &gt; 1L) \n#&gt;             warning(\"additional arguments ignored in message()\")\n#&gt;         ..1\n#&gt;     }\n#&gt;     else {\n#&gt;         msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF)\n#&gt;         call &lt;- sys.call()\n#&gt;         simpleMessage(msg, call)\n#&gt;     }\n#&gt;     defaultHandler &lt;- function(c) {\n#&gt;         cat(conditionMessage(c), file = stderr(), sep = \"\")\n#&gt;     }\n#&gt;     withRestarts({\n#&gt;         signalCondition(cond)\n#&gt;         defaultHandler(cond)\n#&gt;     }, muffleMessage = function() NULL)\n#&gt;     invisible()\n#&gt; }\n#&gt; &lt;bytecode: 0x000002ba6a952b98&gt;\n#&gt; &lt;environment: namespace:base&gt;"
  },
  {
    "objectID": "slides/08.html#custom-conditions",
    "href": "slides/08.html#custom-conditions",
    "title": "Conditions",
    "section": "Custom conditions",
    "text": "Custom conditions\nMotivation\nThe base::log() function provides a minimal error message.\n\nlog(letters)\n\n#&gt; Error in log(letters): non-numeric argument to mathematical function\n\nlog(1:10, base = letters)\n\n#&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical function\n\n\nOne could make a more informative error message about which argument is problematic.\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    rlang::abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    rlang::abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\nConsider the difference:\n\nmy_log(letters)\n\n#&gt; Error in `my_log()`:\n#&gt; ! `x` must be a numeric vector; not character.\n\nmy_log(1:10, base = letters)\n\n#&gt; Error in `my_log()`:\n#&gt; ! `base` must be a numeric vector; not character.\n\n\nSignalling\nCreate a helper function to describe errors:\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  rlang::abort(\n    \"error_bad_argument\", # &lt;- this is the (error) class, I believe\n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\n\nRewrite the log function to use this helper function:\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\nSee the result for the end user:\n\nmy_log(letters)\n\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `x` must be numeric; not character.\n\nmy_log(1:10, base = letters)\n\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `base` must be numeric; not character.\n\n\nHandling\nUse class of condition object to allow for different handling of different types of errors\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n\n#&gt; [1] \"bad_argument\"\n\n\nBut note that the first handler that matches any of the signal‚Äôs class, potentially in a vector of signal classes, will get control. So put the most specific handlers first."
  },
  {
    "objectID": "slides/08.html#applications",
    "href": "slides/08.html#applications",
    "title": "Conditions",
    "section": "Applications",
    "text": "Applications\nSee the sub-section in the book for excellent examples."
  },
  {
    "objectID": "slides/08.html#resources",
    "href": "slides/08.html#resources",
    "title": "Conditions",
    "section": "Resources",
    "text": "Resources\n\nConditions articles in rlang vignettes:\n\nIncluding function calls in error messages\nIncluding contextual information with error chains\nFormatting messages with cli\n\nOther resources from error message segment of rstudio::conf(2022) workshop ‚ÄúPackage Development Masterclass‚Äù"
  },
  {
    "objectID": "slides/10.html#learning-objectives",
    "href": "slides/10.html#learning-objectives",
    "title": "Function factories",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nUnderstand what a function factory is\nRecognise how function factories work\nLearn about non-obvious combination of function features\nGenerate a family of functions from data\n\n\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)"
  },
  {
    "objectID": "slides/10.html#what-is-a-function-factory",
    "href": "slides/10.html#what-is-a-function-factory",
    "title": "Function factories",
    "section": "What is a function factory?",
    "text": "What is a function factory?\nA function factory is a function that makes (returns) functions\nFactory made function are manufactured functions.\n\nFunction factory | Credits: epsis.com"
  },
  {
    "objectID": "slides/10.html#how-does-a-function-factory-work",
    "href": "slides/10.html#how-does-a-function-factory-work",
    "title": "Function factories",
    "section": "How does a function factory work?",
    "text": "How does a function factory work?\n\nHow does it work? | Credits: kakaakigas.com/how-it-works/\npower1 &lt;- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare &lt;- power1(2)\ncube &lt;- power1(3)\n\npower1() is the function factory and square() and cube() are manufactured functions."
  },
  {
    "objectID": "slides/10.html#important-to-remember",
    "href": "slides/10.html#important-to-remember",
    "title": "Function factories",
    "section": "Important to remember",
    "text": "Important to remember\n\nR has First-class functions (can be created with function() and &lt;-)\n\n\nR functions are objects in their own right, a language property often called ‚Äúfirst-class functions‚Äù\n‚Äì Section 6.2.3\n\n\nFunctions capture (enclose) environment in which they are created\n\n\nf &lt;- function(x) function(y) x + y\nfn_env(f)    # The function f()\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nfn_env(f())  # The function created by f()\n\n#&gt; &lt;environment: 0x0000029fbf09a6d0&gt;\n\n\n\nFunctions create a new environment on each run\n\n\nf &lt;- function(x) {\n  function() x + 1\n}\nff &lt;- f(1)\nff()\n\n#&gt; [1] 2\n\nff()\n\n#&gt; [1] 2"
  },
  {
    "objectID": "slides/10.html#fundamentals---environment",
    "href": "slides/10.html#fundamentals---environment",
    "title": "Function factories",
    "section": "Fundamentals - Environment",
    "text": "Fundamentals - Environment\n\nEnvironment when function is created defines arguments in the function\nUse env_print(fun) and fn_env() to explore\n\n\nenv_print(square)\n\n#&gt; &lt;environment: 0x0000029fc0169900&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; ‚Ä¢ exp: &lt;lazy&gt;\n\nfn_env(square)$exp\n\n#&gt; [1] 2\n\n\n\nBlue indicates environment, arrows bindings"
  },
  {
    "objectID": "slides/10.html#fundamentals---forcing",
    "href": "slides/10.html#fundamentals---forcing",
    "title": "Function factories",
    "section": "Fundamentals - Forcing",
    "text": "Fundamentals - Forcing\n\nLazy evaluation means arguments only evaluated when used\n‚Äú[can] lead to a real head-scratcher of a bug‚Äù\n\n\nx &lt;- 2\nsquare &lt;- power1(x)\nx &lt;- 3\nsquare(4)\n\n#&gt; [1] 64\n\n\n\nOnly applies if passing object as argument\nHere argument 2 evaluated when function called\n\n\nsquare &lt;- power1(2)\nx &lt;- 3\nsquare(4)\n\n#&gt; [1] 16\n\n\nSo use force()! (Unless you want it to change with the x in the parent environment)"
  },
  {
    "objectID": "slides/10.html#forcing---reiterated",
    "href": "slides/10.html#forcing---reiterated",
    "title": "Function factories",
    "section": "Forcing - Reiterated",
    "text": "Forcing - Reiterated\nOnly required if the argument is not evaluated before the new function is created:\n\npower1 &lt;- function(exp) {\n  stopifnot(is.numeric(exp))\n  function(x) x ^ exp\n}\n\nx &lt;- 2\nsquare &lt;- power1(x)\nx &lt;- 3\nsquare(4)\n\n#&gt; [1] 16"
  },
  {
    "objectID": "slides/10.html#fundamentals---stateful-functions",
    "href": "slides/10.html#fundamentals---stateful-functions",
    "title": "Function factories",
    "section": "Fundamentals - Stateful functions",
    "text": "Fundamentals - Stateful functions\nBecause\n\nThe enclosing environment is unique and constant, and\nWe have &lt;&lt;- (super assignment)\n\nWe can change that enclosing environment and keep track of that state across iterations (!)\n\n&lt;- Assignment in current environment\n&lt;&lt;- Assignment in parent environment\n\n\nnew_counter &lt;- function() {\n  i &lt;- 0        \n  function() {\n    i &lt;&lt;- i + 1 # second assignment (super assignment)\n    i\n  }\n}\n\ncounter_one &lt;- new_counter()\ncounter_two &lt;- new_counter()\nc(counter_one(), counter_one(), counter_one())\n\n#&gt; [1] 1 2 3\n\nc(counter_two(), counter_two(), counter_two())\n\n#&gt; [1] 1 2 3\n\n\n\n‚ÄúAs soon as your function starts managing the state of multiple variables, it‚Äôs better to switch to R6‚Äù"
  },
  {
    "objectID": "slides/10.html#fundamentals---garbage-collection",
    "href": "slides/10.html#fundamentals---garbage-collection",
    "title": "Function factories",
    "section": "Fundamentals - Garbage collection",
    "text": "Fundamentals - Garbage collection\n\nBecause environment is attached to (enclosed by) function, temporary objects don‚Äôt go away.\n\nCleaning up using rm() inside a function:\n\nf_dirty &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  function() m\n}\n\nf_clean &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  rm(x)            # &lt;---- Important part!\n  function() m\n}\n\nlobstr::obj_size(f_dirty(1e6))\n\n#&gt; 8.00 MB\n\nlobstr::obj_size(f_clean(1e6))\n\n#&gt; 504 B"
  },
  {
    "objectID": "slides/10.html#useful-examples---histograms-and-binwidth",
    "href": "slides/10.html#useful-examples---histograms-and-binwidth",
    "title": "Function factories",
    "section": "Useful Examples - Histograms and binwidth",
    "text": "Useful Examples - Histograms and binwidth\nUseful when‚Ä¶\n\nYou need to pass a function\n\nYou don‚Äôt want to have to re-write the function every time (the default behaviour of the function should be flexible)\n\nFor example, these bins are not appropriate\n\nsd &lt;- c(1, 5, 15)\nn &lt;- 100\ndf &lt;- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\n\n\n\n\n\n\n\n\nWe could just make a function‚Ä¶\n\nbinwidth_bins &lt;- function(x) (max(x) - min(x)) / 20\n\nggplot(df, aes(x = x)) + \n  geom_histogram(binwidth = binwidth_bins) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\n\n\n\n\n\n\n\n\nBut if we want to change the number of bins (20) we‚Äôd have to re-write the function each time.\nIf we use a factory, we don‚Äôt have to do that.\n\nbinwidth_bins &lt;- function(n) {\n  force(n)\n  function(x) (max(x) - min(x)) / n\n}\n\nggplot(df, aes(x = x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL, title = \"20 bins\")\n\n\n\n\n\n\n\nggplot(df, aes(x = x)) + \n  geom_histogram(binwidth = binwidth_bins(5)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL, title = \"5 bins\")\n\n\n\n\n\n\n\n\n\nSimilar benefit in Box-cox example"
  },
  {
    "objectID": "slides/10.html#useful-examples---wrapper",
    "href": "slides/10.html#useful-examples---wrapper",
    "title": "Function factories",
    "section": "Useful Examples - Wrapper",
    "text": "Useful Examples - Wrapper\nUseful when‚Ä¶\n\nYou want to create a function that wraps a bunch of other functions\n\nFor example, ggsave() wraps a bunch of different graphics device functions:\n\n# (Even more simplified)\nplot_dev &lt;- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(\n    ext,\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nThen ggsave() uses\nggsave &lt;- function(...) {\n  dev &lt;- plot_dev(device, filename, dpi = dpi)\n  ...\n  dev(filename = filename, width = dim[1], height = dim[2], bg = bg, ...)\n  ...\n}\nOtherwise, would have to do something like like a bunch of if/else statements."
  },
  {
    "objectID": "slides/10.html#useful-examples---optimizing",
    "href": "slides/10.html#useful-examples---optimizing",
    "title": "Function factories",
    "section": "Useful Examples - Optimizing",
    "text": "Useful Examples - Optimizing\nUseful when‚Ä¶\n\nWant to pass function on to optimise()/optimize()\nWant to perform pre-computations to speed things up\nWant to re-use this for other datasets\n\n(Skipping to final results from section)\nHere, using MLE want to to find the most likely value of lambda for a Poisson distribution and this data.\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nWe‚Äôll create a function that creates a lambda assessment function for a given data set.\n\nll_poisson &lt;- function(x) {\n  n &lt;- length(x)\n  sum_x &lt;- sum(x)\n  c &lt;- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nWe can use this on different data sets, but here use ours x1\n\nll &lt;- ll_poisson(x1)\nll(10)  # Log-probility of a lambda = 10\n\n#&gt; [1] -183.6405\n\n\nUse optimise() rather than trial and error\n\noptimise(ll, c(0, 100), maximum = TRUE)\n\n#&gt; $maximum\n#&gt; [1] 32.09999\n#&gt; \n#&gt; $objective\n#&gt; [1] -30.26755\n\n\nResult: Highest log-probability is -30.3, best lambda is 32.1"
  },
  {
    "objectID": "slides/10.html#function-factories-functionals",
    "href": "slides/10.html#function-factories-functionals",
    "title": "Function factories",
    "section": "Function factories + functionals",
    "text": "Function factories + functionals\nCombine functionals and function factories to turn data into many functions.\n\nnames &lt;- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns &lt;- purrr::map(names, power1)\nnames(funs)\n\n#&gt; [1] \"square\"     \"cube\"       \"root\"       \"cuberoot\"   \"reciprocal\"\n\nfuns$root(64)\n\n#&gt; [1] 8\n\nfuns$square(3)\n\n#&gt; [1] 9\n\n\nAvoid the prefix with\n\nwith() - with(funs, root(100))\n\nTemporary, clear, short-term\n\nattach() - attach(funs) / detach(funs)\n\nAdded to search path (like package function), cannot be overwritten, but can be attached multiple times!\n\nrlang::env_bind - env_bind(globalenv(), !!!funs) / env_unbind(gloablenv(), names(funs))\n\nAdded to global env (like created function), can be overwritten"
  },
  {
    "objectID": "slides/12.html#learning-objectives",
    "href": "slides/12.html#learning-objectives",
    "title": "Base types",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nUnderstand what OOP means‚Äìat the very least for R\nKnow how to discern an object‚Äôs nature‚Äìbase or OO‚Äìand type\n\n\nJohn Chambers, creator of S programming language\n\nSession Info\n\n\nlibrary(\"DiagrammeR\")\n\n\nutils::sessionInfo()\n\n#&gt; R version 4.5.1 (2025-06-13 ucrt)\n#&gt; Platform: x86_64-w64-mingw32/x64\n#&gt; Running under: Windows 11 x64 (build 26100)\n#&gt; \n#&gt; Matrix products: default\n#&gt;   LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] LC_COLLATE=English_United States.utf8 \n#&gt; [2] LC_CTYPE=English_United States.utf8   \n#&gt; [3] LC_MONETARY=English_United States.utf8\n#&gt; [4] LC_NUMERIC=C                          \n#&gt; [5] LC_TIME=English_United States.utf8    \n#&gt; \n#&gt; time zone: America/Chicago\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     \n#&gt; \n#&gt; other attached packages:\n#&gt; [1] DiagrammeR_1.0.11\n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;  [1] digest_0.6.37      RColorBrewer_1.1-3 R6_2.6.1           fastmap_1.2.0     \n#&gt;  [5] xfun_0.52          magrittr_2.0.3     glue_1.8.0         knitr_1.50        \n#&gt;  [9] htmltools_0.5.8.1  rmarkdown_2.29     cli_3.6.5          visNetwork_2.1.2  \n#&gt; [13] compiler_4.5.1     tools_4.5.1        evaluate_1.0.4     yaml_2.3.10       \n#&gt; [17] rlang_1.1.6        jsonlite_2.0.0     htmlwidgets_1.6.4  keyring_1.4.1"
  },
  {
    "objectID": "slides/12.html#why-oop-is-hard-in-r",
    "href": "slides/12.html#why-oop-is-hard-in-r",
    "title": "Base types",
    "section": "Why OOP is hard in R",
    "text": "Why OOP is hard in R\n\nMultiple OOP systems exist: S3, R6, S4, and (now/soon) S7.\nMultiple preferences: some users prefer one system; others, another.\nR‚Äôs OOP systems are different enough that prior OOP experience may not transfer well.\n\n\n\n\nXKCD 927"
  },
  {
    "objectID": "slides/12.html#oop-big-ideas",
    "href": "slides/12.html#oop-big-ideas",
    "title": "Base types",
    "section": "OOP: Big Ideas",
    "text": "OOP: Big Ideas\n\nPolymorphism. Function has a single interface (outside), but contains (inside) several class-specific implementations.\n\n\n# imagine a function with object x as an argument\n# from the outside, users interact with the same function\n# but inside the function, there are provisions to deal with objects of different classes\nsome_function &lt;- function(x) {\n  if is.numeric(x) {\n    # implementation for numeric x\n  } else if is.character(x) {\n    # implementation for character x\n  } ...\n}\n\n\n\nExample of polymorphism\n\n\n# data frame\nsummary(mtcars[,1:4])\n\n#&gt;       mpg             cyl             disp             hp       \n#&gt;  Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n#&gt;  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n#&gt;  Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n#&gt;  Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n#&gt;  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n#&gt;  Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0\n\n# statistical model\nlin_fit &lt;- lm(mpg ~ hp, data = mtcars)\nsummary(lin_fit)\n\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ hp, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;     Min      1Q  Median      3Q     Max \n#&gt; -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\n#&gt; hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.863 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n#&gt; F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n\n\n\nEncapsulation. Function ‚Äúencapsulates‚Äù‚Äìthat is, encloses in an inviolate capsule‚Äìboth data and how it acts on data. Think of a REST API: a client interacts with with an API only through a set of discrete endpoints (i.e., things to get or set), but the server does not otherwise give access to its internal workings or state. Like with an API, this creates a separation of concerns: OOP functions take inputs and yield results; users only consume those results."
  },
  {
    "objectID": "slides/12.html#oop-properties",
    "href": "slides/12.html#oop-properties",
    "title": "Base types",
    "section": "OOP: Properties",
    "text": "OOP: Properties\nObjects have class\n\nClass defines:\n\nMethod (i.e., what can be done with object)\nFields (i.e., data that defines an instance of the class)\n\nObjects are an instance of a class\n\nClass is inherited\n\nClass is defined:\n\nBy an object‚Äôs class (e.g., ordered factor)\nBy the parent of the object‚Äôs class (e.g., factor)\n\nInheritance matters for method dispatch\n\nIf a method is defined for an object‚Äôs class, use that method\nIf an object doesn‚Äôt have a method, use the method of the parent class\nThe process of finding a method, is called dispatch"
  },
  {
    "objectID": "slides/12.html#oop-in-r-two-paradigms",
    "href": "slides/12.html#oop-in-r-two-paradigms",
    "title": "Base types",
    "section": "OOP in R: Two Paradigms",
    "text": "OOP in R: Two Paradigms\n1. Encapsulated OOP\n\nObjects ‚Äúencapsulate‚Äù\n\nMethods (i.e., what can be done)\nFields (i.e., data on which things are done)\n\nCalls communicate this encapsulation, since form follows function\n\nForm: object.method(arg1, arg2)\nFunction: for object, apply method for object‚Äôs class with arguments arg1 and arg2\n\n\n2. Functional OOP\n\nMethods belong to ‚Äúgeneric‚Äù functions\nFrom the outside, look like regular functions: generic(object, arg2, arg3)\nFrom the inside, components are also functions\n\nConcept Map\n\n\n\n\n\n\n\n\nMermaid code\n\n\nDiagrammeR::mermaid(\"\ngraph LR\n\nOOP --&gt; encapsulated_OOP\nOOP --&gt; functional_OOP\n\nfunctional_OOP --&gt; S3\nfunctional_OOP --&gt; S4\n\nencapsulated_OOP --&gt; R6\nencapsulated_OOP --&gt; RC\n\")"
  },
  {
    "objectID": "slides/12.html#oop-in-base-r",
    "href": "slides/12.html#oop-in-base-r",
    "title": "Base types",
    "section": "OOP in base R",
    "text": "OOP in base R\n\nS3\n\nParadigm: functional OOP\nNoteworthy: R‚Äôs first OOP system\nUse case: low-cost solution for common problems\nDownsides: no guarantees\n\nS4\n\nParadigm: functional OOP\nNoteworthy: rewrite of S3, used by Bioconductor\nUse case: ‚Äúmore guarantees and greater encapsulation‚Äù than S3\nDownsides: higher setup cost than S3\n\nRC\n\nParadigm: encapsulated OOP\nNoteworthy: special type of S4 object is mutable‚Äìin other words, that can be modified in place (instead of R‚Äôs usual copy-on-modify behavior)\nUse cases: problems that are hard to tackle with functional OOP (in S3 and S4)\nDownsides: harder to reason about (because of modify-in-place logic)"
  },
  {
    "objectID": "slides/12.html#oop-in-packages",
    "href": "slides/12.html#oop-in-packages",
    "title": "Base types",
    "section": "OOP in packages",
    "text": "OOP in packages\n\nR6\n\nParadigm: encapsulated OOP\nNoteworthy: resolves issues with RC\n\nR7\n\nParadigm: functional OOP\nNoteworthy:\n\nbest parts of S3 and S4\nease of S3\npower of S4\nSee more in rstudio::conf(2022) talk\n\n\nR.oo\n\nParadigm: hybrid functional and encapsulated (?)\n\nproto\n\nParadigm: prototype OOP\nNoteworthy: OOP style used in ggplot2"
  },
  {
    "objectID": "slides/12.html#how-can-you-tell-if-an-object-is-base-or-oop",
    "href": "slides/12.html#how-can-you-tell-if-an-object-is-base-or-oop",
    "title": "Base types",
    "section": "How can you tell if an object is base or OOP?",
    "text": "How can you tell if an object is base or OOP?\nFunctions\nTwo functions:\n\nbase::is.object(), which yields TRUE/FALSE about whether is OOP object\nsloop::otype(), which says what type of object type: \"base\", \"S3\", etc.\n\nAn few examples:\n\n# Example 1: a base object\nis.object(1:10)\n\n#&gt; [1] FALSE\n\nsloop::otype(1:10)\n\n#&gt; [1] \"base\"\n\n# Example 2: an OO object\nis.object(mtcars)\n\n#&gt; [1] TRUE\n\nsloop::otype(mtcars)\n\n#&gt; [1] \"S3\"\n\n\nsloop\n\nS Language Object-Oriented Programming\n\n\n\n\nXKCD 927\n\n\nClass\nOO objects have a ‚Äúclass‚Äù attribute:\n\n# base object has no class\nattr(1:10, \"class\")\n\n#&gt; NULL\n\n# OO object has one or more classes\nattr(mtcars, \"class\")\n\n#&gt; [1] \"data.frame\""
  },
  {
    "objectID": "slides/12.html#what-about-types",
    "href": "slides/12.html#what-about-types",
    "title": "Base types",
    "section": "What about types?",
    "text": "What about types?\nOnly OO objects have a ‚Äúclass‚Äù attribute, but every object‚Äìwhether base or OO‚Äìhas class\nVectors\n\ntypeof(NULL)\n\n#&gt; [1] \"NULL\"\n\ntypeof(c(\"a\", \"b\", \"c\"))\n\n#&gt; [1] \"character\"\n\ntypeof(1L)\n\n#&gt; [1] \"integer\"\n\ntypeof(1i)\n\n#&gt; [1] \"complex\"\n\n\nFunctions\n\n# \"normal\" function\nmy_fun &lt;- function(x) { x + 1 }\ntypeof(my_fun)\n\n#&gt; [1] \"closure\"\n\n# internal function\ntypeof(`[`)\n\n#&gt; [1] \"special\"\n\n# primitive function\ntypeof(sum)    \n\n#&gt; [1] \"builtin\"\n\n\nEnvironments\n\ntypeof(globalenv())\n\n#&gt; [1] \"environment\"\n\n\nS4\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2) ^ 2)\ntypeof(mle_obj)\n\n#&gt; [1] \"S4\"\n\n\nLanguage components\n\ntypeof(quote(a))\n\n#&gt; [1] \"symbol\"\n\ntypeof(quote(a + 1))\n\n#&gt; [1] \"language\"\n\ntypeof(formals(my_fun))\n\n#&gt; [1] \"pairlist\"\n\n\nConcept Map\n\nBase types in R\n\nSankey graph code\n\nThe graph above was made with SankeyMATIC\n// toggle \"Show Values\"\n// set Default Flow Colors from \"each flow's Source\"\n\nbase\\ntypes [8] vectors\nbase\\ntypes [3] functions\nbase\\ntypes [1] environments\nbase\\ntypes [1] S4 OOP\nbase\\ntypes [3] language\\ncomponents\nbase\\ntypes [6] C components\n\nvectors [1] NULL\nvectors [1] logical\nvectors [1] integer\nvectors [1] double\nvectors [1] complex\nvectors [1] character\nvectors [1] list\nvectors [1] raw\n\nfunctions [1] closure\nfunctions [1] special\nfunctions [1] builtin\n\nenvironments [1] environment\n\nS4 OOP [1] S4\n\nlanguage\\ncomponents [1] symbol\nlanguage\\ncomponents [1] language\nlanguage\\ncomponents [1] pairlist\n\nC components [1] externalptr\nC components [1] weakref\nC components [1] bytecode\nC components [1] promise\nC components [1] ...\nC components [1] any"
  },
  {
    "objectID": "slides/12.html#be-careful-about-the-numeric-type",
    "href": "slides/12.html#be-careful-about-the-numeric-type",
    "title": "Base types",
    "section": "Be careful about the numeric type",
    "text": "Be careful about the numeric type\n\nOften ‚Äúnumeric‚Äù is treated as synonymous for double:\n\n\n# create a double and integeger objects\none &lt;- 1\noneL &lt;- 1L\ntypeof(one)\n\n#&gt; [1] \"double\"\n\ntypeof(oneL)\n\n#&gt; [1] \"integer\"\n\n# check their type after as.numeric()\none |&gt; as.numeric() |&gt; typeof()\n\n#&gt; [1] \"double\"\n\noneL |&gt; as.numeric() |&gt; typeof()\n\n#&gt; [1] \"double\"\n\n\n\nIn S3 and S4, ‚Äúnumeric‚Äù is taken as either integer or double, when choosing methods:\n\n\nsloop::s3_class(1)\n\n#&gt; [1] \"double\"  \"numeric\"\n\nsloop::s3_class(1L)\n\n#&gt; [1] \"integer\" \"numeric\"\n\n\n\nis.numeric() tests whether an object behaves like a number\n\n\ntypeof(factor(\"x\"))\n\n#&gt; [1] \"integer\"\n\nis.numeric(factor(\"x\"))\n\n#&gt; [1] FALSE\n\n\nBut Advanced R consistently uses numeric to mean integer or double type."
  },
  {
    "objectID": "slides/14.html#learning-objectives",
    "href": "slides/14.html#learning-objectives",
    "title": "R6",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nDiscuss how to construct a R6 class.\nOverview the different mechanisms of a R6 class (e.g.¬†initialization, print, public, private, and active fields and methods).\nObserve various examples using R6‚Äôs mechanisms to create R6 classes, objects, fields, and methods.\nObserve the consequences of R6‚Äôs reference semantics.\nReview the book‚Äôs arguments on the use of R6 over reference classes."
  },
  {
    "objectID": "slides/14.html#a-review-of-oop",
    "href": "slides/14.html#a-review-of-oop",
    "title": "R6",
    "section": "A review of OOP",
    "text": "A review of OOP\n\n\nA PIE"
  },
  {
    "objectID": "slides/14.html#introducing-r6",
    "href": "slides/14.html#introducing-r6",
    "title": "R6",
    "section": "Introducing R6",
    "text": "Introducing R6\n\n\nR6 classes are not built into base.\n\nIt is a separate package.\nYou have to install and attach to use.\nIf R6 objects are used in a package, it needs to be specified as a dependency in the DESCRIPTION file.\n\n\n\ninstall.packages(\"R6\")\n\n\nlibrary(R6)\n\n\nR6 classes have two special properties:\n\nUses an encapsulated OOP paradigm.\n\nMethods belong to objects, not generics.\nThey follow the form object$method() for calling fields and methods.\n\nR6 objects are mutable.\n\nModified in place.\nThey follow reference semantics.\n\n\nR6 is similar to OOP in other languages.\nHowever, its use can lead ton non-idiomatic R code.\n\nTradeoffs - follows an OOP paradigm but sacrafice what users are use to.\nMicrosoft365R."
  },
  {
    "objectID": "slides/14.html#constructing-an-r6-class-the-basics",
    "href": "slides/14.html#constructing-an-r6-class-the-basics",
    "title": "R6",
    "section": "Constructing an R6 class, the basics",
    "text": "Constructing an R6 class, the basics\n\nReally simple to do, just use the R6::R6Class() function.\n\n\nAccumulator &lt;- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum &lt;- self$sum + x\n    invisible(self)\n  }\n))\n\n\nTwo important arguments:\n\nclassname - A string used to name the class (not needed but suggested)\npublic - A list of methods (functions) and fields (anything else)\n\nSuggested style conventions to follow:\n\nClass name should follow UpperCamelCase.\nMethods and fields should use snake_case.\nAlways assign the result of a R6Class() into a variable with the same name as the class.\n\nYou can use self$ to access methods and fields of the current object."
  },
  {
    "objectID": "slides/14.html#constructing-an-r6-object",
    "href": "slides/14.html#constructing-an-r6-object",
    "title": "R6",
    "section": "Constructing an R6 object",
    "text": "Constructing an R6 object\n\nJust use $new()\n\n\nx &lt;- Accumulator$new()\n\n\nx$add(4)\nx$sum\n\n#&gt; [1] 4"
  },
  {
    "objectID": "slides/14.html#r6-objects-and-method-chaining",
    "href": "slides/14.html#r6-objects-and-method-chaining",
    "title": "R6",
    "section": "R6 objects and method chaining",
    "text": "R6 objects and method chaining\n\nAll side-effect R6 methods should return self invisibly.\nThis allows for method chaining.\n\n\nx$add(10)$add(10)$sum\n# [1] 24\n\n\nTo improve readability:\n\n\n# Method chaining\nx$\n  add(10)$\n  add(10)$\n  sum\n# [1] 44"
  },
  {
    "objectID": "slides/14.html#r6-useful-methods",
    "href": "slides/14.html#r6-useful-methods",
    "title": "R6",
    "section": "R6 useful methods",
    "text": "R6 useful methods\n\n$print() - Modifies the default printing method.\n\n$print() should always return invisible(self).\n\n$initialize() - Overides the default behaviour of $new().\n\nAlso provides a space to validate inputs."
  },
  {
    "objectID": "slides/14.html#constructing-a-bank-account-class",
    "href": "slides/14.html#constructing-a-bank-account-class",
    "title": "R6",
    "section": "Constructing a bank account class",
    "text": "Constructing a bank account class\n\nBankAccount &lt;- R6Class(\"BankAccount\", list(\n  owner = NULL,\n  type = NULL,\n  balance = 0,\n  initialize = function(owner, type) {\n    stopifnot(is.character(owner), length(owner) == 1)\n    stopifnot(is.character(type), length(type) == 1)\n  },\n  deposit = function(amount) {\n    self$balance &lt;- self$balance + amount\n    invisible(self)\n  },\n  withdraw = function(amount) {\n    self$balance &lt;- self$balance - amount\n    invisible(self)\n  }\n))"
  },
  {
    "objectID": "slides/14.html#simple-transactions",
    "href": "slides/14.html#simple-transactions",
    "title": "R6",
    "section": "Simple transactions",
    "text": "Simple transactions\n\ncollinsavings &lt;- BankAccount$new(\"Collin\", type = \"Savings\")\ncollinsavings$deposit(10)\ncollinsavings\n\n#&gt; &lt;BankAccount&gt;\n#&gt;   Public:\n#&gt;     balance: 10\n#&gt;     clone: function (deep = FALSE) \n#&gt;     deposit: function (amount) \n#&gt;     initialize: function (owner, type) \n#&gt;     owner: NULL\n#&gt;     type: NULL\n#&gt;     withdraw: function (amount)\n\n\n\ncollinsavings$withdraw(10)\ncollinsavings\n\n#&gt; &lt;BankAccount&gt;\n#&gt;   Public:\n#&gt;     balance: 0\n#&gt;     clone: function (deep = FALSE) \n#&gt;     deposit: function (amount) \n#&gt;     initialize: function (owner, type) \n#&gt;     owner: NULL\n#&gt;     type: NULL\n#&gt;     withdraw: function (amount)"
  },
  {
    "objectID": "slides/14.html#modifying-the-print-method",
    "href": "slides/14.html#modifying-the-print-method",
    "title": "R6",
    "section": "Modifying the $print() method",
    "text": "Modifying the $print() method\n\nBankAccount &lt;- R6Class(\"BankAccount\", list(\n  owner = NULL,\n  type = NULL,\n  balance = 0,\n  initialize = function(owner, type) {\n    stopifnot(is.character(owner), length(owner) == 1)\n    stopifnot(is.character(type), length(type) == 1)\n\n    self$owner &lt;- owner\n    self$type &lt;- type\n  },\n  deposit = function(amount) {\n    self$balance &lt;- self$balance + amount\n    invisible(self)\n  },\n  withdraw = function(amount) {\n    self$balance &lt;- self$balance - amount\n    invisible(self)\n  },\n  print = function(...) {\n    cat(\"Account owner: \", self$owner, \"\\n\", sep = \"\")\n    cat(\"Account type: \", self$type, \"\\n\", sep = \"\")\n    cat(\"  Balance: \", self$balance, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\n\nImportant point: Methods are bound to individual objects.\n\nReference semantics vs.¬†copy-on-modify.\n\n\n\ncollinsavings\n\nhadleychecking &lt;- BankAccount$new(\"Hadley\", type = \"Checking\")\n\nhadleychecking"
  },
  {
    "objectID": "slides/14.html#how-does-this-work",
    "href": "slides/14.html#how-does-this-work",
    "title": "R6",
    "section": "How does this work?",
    "text": "How does this work?\n\nWinston Chang‚Äôs 2017 useR talk\nR6 objects are just environments with a particular structure."
  },
  {
    "objectID": "slides/14.html#adding-methods-after-class-creation",
    "href": "slides/14.html#adding-methods-after-class-creation",
    "title": "R6",
    "section": "Adding methods after class creation",
    "text": "Adding methods after class creation\n\nUse $set() to add methods after creation.\nKeep in mind methods added with $set() are only available with new objects.\n\n\nAccumulator &lt;- R6Class(\"Accumulator\")\nAccumlator$set(\"public\", \"sum\", 0)\nAccumulator$set(\"public\", \"add\", function(x = 1) {\n  self$sum &lt;- self$sum + x\n  invisible(self)\n})"
  },
  {
    "objectID": "slides/14.html#inheritance",
    "href": "slides/14.html#inheritance",
    "title": "R6",
    "section": "Inheritance",
    "text": "Inheritance\n\nTo inherit behaviour from an existing class, provide the class object via the inherit argument.\nThis example also provides a good example on how to debug an R6 class.\n\n\nBankAccountOverDraft &lt;- R6Class(\"BankAccountOverDraft\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(amount) {\n      if ((self$balance - amount) &lt; 0) {\n        stop(\"Overdraft\")\n      }\n      # self$balance() &lt;- self$withdraw()\n      self$balance &lt;- self$balance - amount\n      invisible(self)\n    }\n  )\n)\n\nFuture instances debugging\n\nBankAccountOverDraft$debug(\"withdraw\")\nx &lt;- BankAccountOverDraft$new(\"x\", type = \"Savings\")\nx$withdraw(20)\n\n# Turn debugging off\nBankAccountOverDraft$undebug(\"withdraw\")\n\nIndividual object debugging\n\nUse the debug() function.\n\n\nx &lt;- BankAccountOverDraft$new(\"x\", type = \"Savings\")\n# Turn on debugging\ndebug(x$withdraw)\nx$withdraw(10)\n\n# Turn off debugging\nundebug(x$withdraw)\nx$withdraw(5)\n\nTest out our debugged class\n\ncollinsavings &lt;- BankAccountOverDraft$new(\"Collin\", type = \"Savings\")\ncollinsavings\ncollinsavings$withdraw(10)\ncollinsavings\ncollinsavings$deposit(5)\ncollinsavings\ncollinsavings$withdraw(5)"
  },
  {
    "objectID": "slides/14.html#introspection",
    "href": "slides/14.html#introspection",
    "title": "R6",
    "section": "Introspection",
    "text": "Introspection\n\nEvery R6 object has an S3 class that reflects its hierarchy of R6 classes.\nUse the class() function to determine class (and all classes it inherits from).\n\n\nclass(collinsavings)\n\n\nYou can also list all methods and fields of an R6 object with names().\n\n\nnames(collinsavings)"
  },
  {
    "objectID": "slides/14.html#controlling-access",
    "href": "slides/14.html#controlling-access",
    "title": "R6",
    "section": "Controlling access",
    "text": "Controlling access\n\nR6 provides two other arguments:\n\nprivate - create fields and methods only available from within the class.\nactive - allows you to use accessor functions to define dynamic or active fields."
  },
  {
    "objectID": "slides/14.html#privacy",
    "href": "slides/14.html#privacy",
    "title": "R6",
    "section": "Privacy",
    "text": "Privacy\n\nPrivate fields and methods - elements that can only be accessed from within the class, not from the outside.\nWe need to know two things to use private elements:\n\nprivate‚Äôs interface is just like public‚Äôs interface.\n\nList of methods (functions) and fields (everything else).\n\nYou use private$ instead of self$\n\nYou cannot access private fields or methods outside of the class.\n\n\nWhy might you want to keep your methods and fields private?\n\nYou‚Äôll want to be clear what is ok for others to access, especially if you have a complex system of classes.\nIt‚Äôs easier to refactor private fields and methods, as you know others are not relying on it."
  },
  {
    "objectID": "slides/14.html#active-fields",
    "href": "slides/14.html#active-fields",
    "title": "R6",
    "section": "Active fields",
    "text": "Active fields\n\nActive fields allow you to define components that look like fields from the outside, but are defined with functions, like methods.\nImplemented using active bindings.\nEach active binding is a function that takes a single argument value.\nGreat when used in conjunction with private fields.\n\nThis allows for additional checks.\nFor example, we can use them to make a read-only field and to validate inputs."
  },
  {
    "objectID": "slides/14.html#adding-a-read-only-bank-account-number",
    "href": "slides/14.html#adding-a-read-only-bank-account-number",
    "title": "R6",
    "section": "Adding a read-only bank account number",
    "text": "Adding a read-only bank account number\n\nBankAccount &lt;- R6Class(\"BankAccount\", public = list(\n  owner = NULL,\n  type = NULL,\n  balance = 0,\n  initialize = function(owner, type, acct_num = NULL) {\n    private$acct_num &lt;- acct_num\n    self$owner &lt;- owner\n    self$type &lt;- type\n  },\n  deposit = function(amount) {\n    self$balance &lt;- self$balance + amount\n    invisible(self)\n  },\n  withdraw = function(amount) {\n    self$balance &lt;- self$balance - amount\n    invisible(self)\n  },\n  print = function(...) {\n    cat(\"Account owner: \", self$owner, \"\\n\", sep = \"\")\n    cat(\"Account type: \", self$type, \"\\n\", sep = \"\")\n    cat(\"Account #: \", private$acct_num, \"\\n\", sep = \"\")\n    cat(\"  Balance: \", self$balance, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n  ),\n  private = list(\n    acct_num = NULL\n  ),\n  active = list(\n    create_acct_num = function(value) {\n      if (is.null(private$acct_num)) {\n        private$acct_num &lt;- ids::uuid()\n      } else {\n        stop(\"`$acct_num` already assigned\")\n      }\n    }\n  )\n)\n\n\ncollinsavings &lt;- BankAccount$new(\"Collin\", type = \"Savings\")\ncollinsavings$create_acct_num\n# Stops because account number is assigned\ncollinsavings$create_acct_num()\ncollinsavings$print()"
  },
  {
    "objectID": "slides/14.html#how-does-an-active-field-work",
    "href": "slides/14.html#how-does-an-active-field-work",
    "title": "R6",
    "section": "How does an active field work?",
    "text": "How does an active field work?\n\nNot sold on this, as I don‚Äôt know if active gets its own environment.\n\nAny ideas?"
  },
  {
    "objectID": "slides/14.html#reference-semantics",
    "href": "slides/14.html#reference-semantics",
    "title": "R6",
    "section": "Reference semantics",
    "text": "Reference semantics\n\nBig difference to note about R6 objects in relation to other objects:\n\nR6 objects have reference semantics.\n\nThe primary consequence of reference semantics is that objects are not copied when modified.\nIf you want to copy an R6 object, you need to use $clone.\nThere are some other less obvious consequences:\n\nIt‚Äôs harder to reason about code that uses R6 objects, as you need more context.\nThink about when an R6 object is deleted, you can use $finalize() to clean up after yourself.\nIf one of the fields is an R6 object, you must create it inside $initialize(), not R6Class()"
  },
  {
    "objectID": "slides/14.html#r6-makes-it-harder-to-reason-about-code",
    "href": "slides/14.html#r6-makes-it-harder-to-reason-about-code",
    "title": "R6",
    "section": "R6 makes it harder to reason about code",
    "text": "R6 makes it harder to reason about code\n\nReference semantics makes code harder to reason about.\n\n\nx &lt;- list(a = 1)\ny &lt;- list(b = 2)\n\n# Here we know the final line only modifies z\nz &lt;- f(x, y)\n\n# vs.\n\nx &lt;- List$new(a = 1)\ny &lt;- List$new(b = 2)\n\n# If x or y is a method, we don't know if it modifies\n# something other than z. Is this a limitation of\n# abstraction?\nz &lt;- f(x, y)\n\n\nI understand the basics, but not necessarily the tradeoffs.\n\nAnyone care to fill me in?\nIs this a limitation of abstraction?"
  },
  {
    "objectID": "slides/14.html#better-sense-of-whats-going-on-by-looking-at-a-finalizer",
    "href": "slides/14.html#better-sense-of-whats-going-on-by-looking-at-a-finalizer",
    "title": "R6",
    "section": "Better sense of what‚Äôs going on by looking at a finalizer",
    "text": "Better sense of what‚Äôs going on by looking at a finalizer\n\nSince R6 objects are not copied-on-modified, so they are only deleted once.\nWe can use this characteristic to complement our $initialize() with a $finalize() method.\n\ni.e., to clean up after we delete an R6 object.\nThis could be a way to close a database connection.\n\n\n\nTemporaryFile &lt;- R6Class(\"TemporaryFile\", list(\n  path = NULL,\n  initialize = function() {\n    self$path &lt;- tempfile()\n  },\n  finalize = function() {\n    message(\"Cleaning up \", self$path)\n    unlink(self$path)\n  }\n))\n\n\ntf &lt;- TemporaryFile$new()\n# The finalizer will clean up, once the R6 object is deleted.\nrm(tf)"
  },
  {
    "objectID": "slides/14.html#consequences-of-r6-fields",
    "href": "slides/14.html#consequences-of-r6-fields",
    "title": "R6",
    "section": "Consequences of R6 fields",
    "text": "Consequences of R6 fields\n\nIf you use an R6 class as the default value of a field, it will be shared across all instances of the object.\n\n\nTemporaryDatabase &lt;- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = TemporaryFile$new(),\n  initialize = function() {\n    self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] TRUE\n\n\nTo fix this, we need to move the class method call to $intialize()\n\n\nTemporaryDatabase &lt;- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = NULL,\n  initialize = function() {\n    self$file &lt;- TemporaryFile$new()\n    self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] FALSE"
  },
  {
    "objectID": "slides/14.html#why-use-r6",
    "href": "slides/14.html#why-use-r6",
    "title": "R6",
    "section": "Why use R6?",
    "text": "Why use R6?\n\nBook mentions R6 is similar to the built-in reference classes.\nThen why use R6?\nR6 is simpler.\n\nRC requires you to understand S4.\n\nComprehensive documentation.\nSimpler mechanisms for cross-package subclassing, which just works.\nR6 separates public and private fields in separate environments, RC stacks everything in the same environment.\nR6 is faster.\nRC is tied to R, so any bug fixes need a newer version of R.\n\nThis is especially important if you‚Äôre writing packages that need to work with multiple R versions.\n\nR6 and RC are similar, so if you need RC, it will only require a small amount of additional effort to learn RC."
  },
  {
    "objectID": "slides/16.html#learning-objectives",
    "href": "slides/16.html#learning-objectives",
    "title": "Trade-offs",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nUnderstand the Trade-offs between S3, R6 and S4\nBrief intro to S7 (the object system formerly known as R7)"
  },
  {
    "objectID": "slides/16.html#introduction",
    "href": "slides/16.html#introduction",
    "title": "Trade-offs",
    "section": "Introduction",
    "text": "Introduction\n\nWe have three OOP systems introduced so far (S3, S4, R6)\nAt the current time (pre - S7?) Hadley recommends use S3 by default: It‚Äôs simple and widely used throughout base R and CRAN.\nIf you have experience in other languages, Resist the temptation to use R6 even though it will feel more familiar!"
  },
  {
    "objectID": "slides/16.html#s4-versus-s3",
    "href": "slides/16.html#s4-versus-s3",
    "title": "Trade-offs",
    "section": "S4 versus S3",
    "text": "S4 versus S3\nWhich functional object system to use, S3 or S4? \n\nS3 is a simple and flexible system.\n\nGood for small teams who need flexibility and immediate payoffs.\nCommonly used throughout base R and CRAN\nFlexibility can cause problems, more complex systems might require formal conventions\n\nS4 is a more formal, strict system.\n\nGood for large projects and large teams\nUsed by Bioconductor project\nRequires significant up front investment in design, but payoff is a robust system that enforces conventions.\nS4 documentation is challenging to use."
  },
  {
    "objectID": "slides/16.html#r6-versus-s3",
    "href": "slides/16.html#r6-versus-s3",
    "title": "Trade-offs",
    "section": "R6 versus S3",
    "text": "R6 versus S3\nR6 is built on encapsulated objects, rather than generic functions.\nBig differences: general trade-offs\n\nA generic is a regular function so it lives in the global namespace. An R6 method belongs to an object so it lives in a local namespace. This influences how we think about naming.\nR6‚Äôs reference semantics allow methods to simultaneously return a value and modify an object. This solves a painful problem called ‚Äúthreading state‚Äù.\nYou invoke an R6 method using $, which is an infix operator. If you set up your methods correctly you can use chains of method calls as an alternative to the pipe."
  },
  {
    "objectID": "slides/16.html#namespacing",
    "href": "slides/16.html#namespacing",
    "title": "Trade-offs",
    "section": "Namespacing",
    "text": "Namespacing\nWhere methods are found?\n\nin S3, Generic functions are global and live in the global namespace\n\nAdvantage: Uniform API: summary, print, predict etc.\nDisadvantage: Must be careful about creating new methods! Homonyms must be avoided, don‚Äôt define plot(bank_heist)\n\nin R6, Encapsulated methods are local: objects with a scope\n\nAdvantage: No problems with homonyms: meaning of bank_heist$plot() is clear and unambiguous.\nDisadvantage: Lack of a uniform API, except by convention."
  },
  {
    "objectID": "slides/16.html#threading-state",
    "href": "slides/16.html#threading-state",
    "title": "Trade-offs",
    "section": "Threading state",
    "text": "Threading state\nIn S3 the challenge is to return a value and modify the object.\n\nnew_stack &lt;- function(items = list()) {\n  structure(list(items = items), class = \"stack\")\n}\n\npush &lt;- function(x, y) {\n  x$items &lt;- c(x$items, list(y))\n  x\n}\n\nNo problem with that, but what about when we want to pop a value? We need to return two things.\n\npop &lt;- function(x) {\n  n &lt;- length(x$items)\n  \n  item &lt;- x$items[[n]]\n  x$items &lt;- x$items[-n]\n  \n  list(item = item, x = x)\n}\n\nThe usage is a bit awkward:\n\ns &lt;- new_stack()\ns &lt;- push(s, 10)\ns &lt;- push(s, 20)\n\nout &lt;- pop(s)\n# Update state:\ns &lt;- out$x\n\nprint(out$item)\n\n#&gt; [1] 20\n\n\nIn python and other languages we have structured binding to make this less awkward. R has the {zeallot} package. For more, see this vignette:\n\nvignette('unpacking-assignment')\n\nHowever, this is all easier in R6 due to the reference semantics!\n\nStack &lt;- R6::R6Class(\"Stack\", list(\n  items = list(),\n  push = function(x) {\n    self$items &lt;- c(self$items, x)\n    invisible(self)\n  },\n  pop = function() {\n    item &lt;- self$items[[self$length()]]\n    self$items &lt;- self$items[-self$length()]\n    item\n  },\n  length = function() {\n    length(self$items)\n  }\n))\n\ns &lt;- Stack$new()\ns$push(10)\ns$push(20)\ns$pop()\n\n#&gt; [1] 20"
  },
  {
    "objectID": "slides/16.html#method-chaining",
    "href": "slides/16.html#method-chaining",
    "title": "Trade-offs",
    "section": "Method chaining",
    "text": "Method chaining\nUseful to compose functions from left-to-right.\nUse of the operators:\n\nS3: |&gt; or %&gt;%\nR6: $\n\n\ns$push(44)$push(32)$pop()\n\n#&gt; [1] 32"
  },
  {
    "objectID": "slides/16.html#umm-what-about-s7",
    "href": "slides/16.html#umm-what-about-s7",
    "title": "Trade-offs",
    "section": "Umm‚Ä¶ what about S7 ?",
    "text": "Umm‚Ä¶ what about S7 ?\n\nhttps://xkcd.com/927/Primary references:\n\nDocs: https://rconsortium.github.io/S7/\nTalk by Hadley Wickham https://www.youtube.com/watch?v=P3FxCvSueag"
  },
  {
    "objectID": "slides/16.html#s7-briefly",
    "href": "slides/16.html#s7-briefly",
    "title": "Trade-offs",
    "section": "S7 briefly",
    "text": "S7 briefly\n\nS7 is a ‚Äòbetter‚Äô version of S3 with some of the ‚Äòstrictness‚Äô of S4.\n\n\"A little bit more complex then S3, with almost all of the features, \nall of the payoff of S4\" - rstudio conf 2022, Hadley Wickham\n\nS3 + S4 = S7\nCompatible with S3: S7 objects are S3 objects! Can even extend an S3 object with S7\nSomewhat compatible with S4, see compatability vignette for details.\nHelpful error messages!\nNote that it was previously called R7, but it was changed to ‚ÄúS7‚Äù to better reflect that it is functional not encapsulated!"
  },
  {
    "objectID": "slides/16.html#abbreviated-introduction-based-on-the-vignette",
    "href": "slides/16.html#abbreviated-introduction-based-on-the-vignette",
    "title": "Trade-offs",
    "section": "Abbreviated introduction based on the vignette",
    "text": "Abbreviated introduction based on the vignette\nTo install (it‚Äôs now on CRAN):\n\ninstall.packages(\"S7\")\n\n\nlibrary(S7)\ndog &lt;- new_class(\"dog\", properties = list(\n  name = class_character,\n  age = class_numeric\n))\ndog\n\n\n#&gt; &lt;S7_class&gt;\n#&gt; @ name  :  dog\n#&gt; @ parent: &lt;S7_object&gt;\n#&gt; @ properties:\n#&gt;  $ name: &lt;character&gt;          \n#&gt;  $ age : &lt;integer&gt; or &lt;double&gt;\n\nNote the class_character, these are S7 classes corresponding to the base classes.\nNow to use it to create an object of class dog:\n\nlola &lt;- dog(name = \"Lola\", age = 11)\nlola\n\n#&gt; &lt;dog&gt;\n#&gt;  @ name: chr \"Lola\"\n#&gt;  @ age : num 11\n\nProperties can be set/read with @, with automatic validation (‚Äòsafety rails‚Äô) based on the type!\n\nlola@age &lt;- 12\nlola@age\n\n#&gt; 12\n\nlola@age &lt;- \"twelve\"\n\n#&gt; Error: &lt;dog&gt;@age must be &lt;integer&gt; or &lt;double&gt;, not &lt;character&gt;\n\nNote the helpful error message!\nLike S3 (and S4) S7 has generics, implemented with new_generic and method for particular methods:\n\nspeak &lt;- new_generic(\"speak\", \"x\")\n\nmethod(speak, dog) &lt;- function(x) {\n  \"Woof\"\n}\n  \nspeak(lola)\n\n#&gt; [1] \"Woof\"\n\nIf we have another class, we can implement the generic for that too:\n\ncat &lt;- new_class(\"cat\", properties = list(\n  name = class_character,\n  age = class_double\n))\nmethod(speak, cat) &lt;- function(x) {\n  \"Meow\"\n}\n\nfluffy &lt;- cat(name = \"Fluffy\", age = 5)\nspeak(fluffy)\n\n#&gt; [1] \"Meow\"\n\nHelpful messages:\n\nspeak\n\n#&gt; &lt;S7_generic&gt; speak(x, ...) with 2 methods:\n#&gt; 1: method(speak, cat)\n#&gt; 2: method(speak, dog)\n\n‚Äúmost usage of S7 with S3 will just work‚Äù\n\nmethod(print, cat) &lt;- function(...) {\n  print(\"I am a cat.\")\n}\n\nprint(fluffy)\n#&gt; \"I am a cat\"\n\nFor validators, inheritance, dynamic properties and more, see the vignette!"
  },
  {
    "objectID": "slides/16.html#so-switch-to-s7",
    "href": "slides/16.html#so-switch-to-s7",
    "title": "Trade-offs",
    "section": "So‚Ä¶ switch to S7 ?",
    "text": "So‚Ä¶ switch to S7 ?\n\\[\n\\huge\n\\textbf{Soon}^{tm}\n\\]\n\nNot yet‚Ä¶ still in development! \nBut consider trying it out:\n\nTo stay ahead of the curve‚Ä¶ S7 will be integrated into base R someday!\nTo contribute feedback to the S7 team!\nTo get ‚Äúalmost all‚Äù of the benefits of S4 without the complexity !\n\nIn particular, if you have a new project that might require the complexity of S4, consider S7 instead!"
  },
  {
    "objectID": "slides/16.html#oop-system-comparison",
    "href": "slides/16.html#oop-system-comparison",
    "title": "Trade-offs",
    "section": "OOP system comparison",
    "text": "OOP system comparison\n\n\n\nCharacteristic\nS3\nS4\nS7\nR6\n\n\n\n\nPackage\nbase R\nbase R\nS7\nR6\n\n\nProgramming type\nFunctional\nFunctional\nFunctional\nEncapulated\n\n\nComplexity\nLow\nHigh\nMedium\nHigh\n\n\nPayoff\nLow\nHigh\nHigh\nHigh\n\n\nTeam size\nSmall\nSmall-large\nLarge\n?\n\n\nNamespace\nGlobal\nGlobal?\nGlobal?\nLocal\n\n\nModify in place\nNo\nNo\nNo\nYes\n\n\nMethod chaining\n|&gt;\n|&gt;?\n|&gt;?\n$\n\n\nGet/set component\n$\n@\n@\n$\n\n\nCreate class\nclass() or structure() with class argument\nsetClass()\nnew_class()\nR6Class()\n\n\nCreate validator\nfunction()\nsetValidity() or validator argument in setClass()\nvalidator argument in new_class()\n$validate()\n\n\nCreate generic\nUseMethod()\nsetGeneric()\nnew_generic()\nNA\n\n\nCreate method\nfunction() assigned to generic.method\nsetMethod()\nmethod()\nR6Class()\n\n\nCreate object\nclass() or structure() with class argument or constructor function\nnew()\nUse registered method function\n$new()\n\n\nAdditional components\nattributes\nslots\nproperties"
  },
  {
    "objectID": "slides/18.html#learning-objectives",
    "href": "slides/18.html#learning-objectives",
    "title": "Expressions",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nUnderstand the idea of the abstract syntax tree (AST).\nDiscuss the data structures that underlie the AST:\n\nConstants\nSymbols\nCalls\n\nExplore the idea behind parsing.\nExplore some details of R‚Äôs grammar.\nDiscuss the use or recursive functions to compute on the language.\nWork with three other more specialized data structures:\n\nPairlists\nMissing arguments\nExpression vectors\n\n\n\nlibrary(rlang)\nlibrary(lobstr)"
  },
  {
    "objectID": "slides/18.html#introduction",
    "href": "slides/18.html#introduction",
    "title": "Expressions",
    "section": "Introduction",
    "text": "Introduction\n\nTo compute on the language, we first need to understand its structure.\n\n\nThis requires a few things:\n\nNew vocabulary.\nNew tools to inspect and modify expressions.\nApproach the use of the language with new ways of thinking.\n\nOne of the first new ways of thinking is the distinction between an operation and its result.\n\n\ny &lt;- x * 10\n\n#&gt; Error: object 'x' not found\n\n\n\nWe can capture the intent of the code without executing it using the rlang package.\n\n\nz &lt;- rlang::expr(y &lt;- x * 10)\n\nz\n\n#&gt; y &lt;- x * 10\n\n\n\nWe can then evaluate the expression using the base::eval function.\n\n\nx &lt;- 4\n\nbase::eval(expr(y &lt;- x * 10))\n\ny\n\n#&gt; [1] 40\n\n\nEvaluating multiple expressions\n\nThe function expression() allows for multiple expressions, and in some ways it acts similarly to the way files are source()d in. That is, we eval()uate all of the expressions at once.\nexpression() returns a vector and can be passed to eval().\n\n\nz &lt;- expression(x &lt;- 4, x * 10)\n\neval(z)\n\n#&gt; [1] 40\n\nis.atomic(z)\n\n#&gt; [1] FALSE\n\nis.vector(z)\n\n#&gt; [1] TRUE\n\n\n\nexprs() does not evaluate everything at once. To evaluate each expression, the individual expressions must be evaluated in a loop.\n\n\nfor (i in exprs(x &lt;- 4, x * 10)) {\nprint(i)\nprint(eval(i))\n}\n\n#&gt; x &lt;- 4\n#&gt; [1] 4\n#&gt; x * 10\n#&gt; [1] 40"
  },
  {
    "objectID": "slides/18.html#abstract-syntax-tree-ast",
    "href": "slides/18.html#abstract-syntax-tree-ast",
    "title": "Expressions",
    "section": "Abstract Syntax Tree (AST)",
    "text": "Abstract Syntax Tree (AST)\n\nExpressions are objects that capture the structure of code without evaluating it.\nExpressions are also called abstract syntax trees (ASTs) because the structure of code is hierarchical and can be naturally represented as a tree.\nUnderstanding this tree structure is crucial for inspecting and modifying expressions.\n\nBranches = Calls\nLeaves = Symbols and constants\n\n\n\nf(x, \"y\", 1)\n\n\nWith lobstr::ast():\n\nlobstr::ast(f(x, \"y\", 1))\n\n#&gt; ‚ñà‚îÄf \n#&gt; ‚îú‚îÄx \n#&gt; ‚îú‚îÄ\"y\" \n#&gt; ‚îî‚îÄ1\n\n\n\nSome functions might also contain more calls like the example below:\n\n\nf(g(1, 2), h(3, 4, i())):\n\n\n\nlobstr::ast(f(g(1, 2), h(3, 4, i())))\n\n#&gt; ‚ñà‚îÄf \n#&gt; ‚îú‚îÄ‚ñà‚îÄg \n#&gt; ‚îÇ ‚îú‚îÄ1 \n#&gt; ‚îÇ ‚îî‚îÄ2 \n#&gt; ‚îî‚îÄ‚ñà‚îÄh \n#&gt;   ‚îú‚îÄ3 \n#&gt;   ‚îú‚îÄ4 \n#&gt;   ‚îî‚îÄ‚ñà‚îÄi\n\n\n\nRead the hand-drawn diagrams from left-to-right (ignoring vertical position)\nRead the lobstr-drawn diagrams from top-to-bottom (ignoring horizontal position).\nThe depth within the tree is determined by the nesting of function calls.\nDepth also determines evaluation order, as evaluation generally proceeds from deepest-to-shallowest, but this is not guaranteed because of lazy evaluation.\n\nInfix calls\n\nEvery call in R can be written in tree form because any call can be written in prefix form.\n\nAn infix operator is a function where the function name is placed between its arguments. Prefix form is when then function name comes before the arguments, which are enclosed in parentheses. [Note that the name infix comes from the words prefix and suffix.]\n\ny &lt;- x * 10\n`&lt;-`(y, `*`(x, 10))\n\n\nA characteristic of the language is that infix functions can always be written as prefix functions; therefore, all function calls can be represented using an AST.\n\n\n\nlobstr::ast(y &lt;- x * 10)\n\n#&gt; ‚ñà‚îÄ`&lt;-` \n#&gt; ‚îú‚îÄy \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`*` \n#&gt;   ‚îú‚îÄx \n#&gt;   ‚îî‚îÄ10\n\n\n\nlobstr::ast(`&lt;-`(y, `*`(x, 10)))\n\n#&gt; ‚ñà‚îÄ`&lt;-` \n#&gt; ‚îú‚îÄy \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`*` \n#&gt;   ‚îú‚îÄx \n#&gt;   ‚îî‚îÄ10\n\n\n\nThere is no difference between the ASTs for the infix version vs the prefix version, and if you generate an expression with prefix calls, R will still print it in infix form:\n\n\nrlang::expr(`&lt;-`(y, `*`(x, 10)))\n\n#&gt; y &lt;- x * 10"
  },
  {
    "objectID": "slides/18.html#expression",
    "href": "slides/18.html#expression",
    "title": "Expressions",
    "section": "Expression",
    "text": "Expression\n\nCollectively, the data structures present in the AST are called expressions.\nThese include:\n\nConstants\nSymbols\nCalls\nPairlists\n\n\nConstants\n\nScalar constants are the simplest component of the AST.\nA constant is either NULL or a length-1 atomic vector (or scalar)\n\ne.g., TRUE, 1L, 2.5, \"x\", or \"hello\".\n\nWe can test for a constant with rlang::is_syntactic_literal().\nConstants are self-quoting in the sense that the expression used to represent a constant is the same constant:\n\n\nidentical(expr(TRUE), TRUE)\n\n#&gt; [1] TRUE\n\nidentical(expr(1), 1)\n\n#&gt; [1] TRUE\n\nidentical(expr(2L), 2L)\n\n#&gt; [1] TRUE\n\nidentical(expr(\"x\"), \"x\")\n\n#&gt; [1] TRUE\n\nidentical(expr(\"hello\"), \"hello\")\n\n#&gt; [1] TRUE\n\n\nSymbols\n\nA symbol represents the name of an object.\n\nx\nmtcars\nmean\n\nIn base R, the terms symbol and name are used interchangeably (i.e., is.name() is identical to is.symbol()), but this book used symbol consistently because ‚Äúname‚Äù has many other meanings.\nYou can create a symbol in two ways:\n\nby capturing code that references an object with expr().\nturning a string into a symbol with rlang::sym().\n\n\n\nexpr(x)\n\n#&gt; x\n\n\n\nsym(\"x\")\n\n#&gt; x\n\n\n\nA symbol can be turned back into a string with as.character() or rlang::as_string().\nas_string() has the advantage of clearly signalling that you‚Äôll get a character vector of length 1.\n\n\nas_string(expr(x))\n\n#&gt; [1] \"x\"\n\n\n\nWe can recognize a symbol because it is printed without quotes\n\n\nexpr(x)\n\n#&gt; x\n\n\n\nstr() tells you that it is a symbol, and is.symbol() is TRUE:\n\n\nstr(expr(x))\n\n#&gt;  symbol x\n\n\n\nis.symbol(expr(x))\n\n#&gt; [1] TRUE\n\n\n\nThe symbol type is not vectorised, i.e., a symbol is always length 1.\nIf you want multiple symbols, you‚Äôll need to put them in a list, using rlang::syms().\n\nNote that as_string() will not work on expressions which are not symbols.\n\nas_string(expr(x+y))\n\n#&gt; Error in `as_string()`:\n#&gt; ! Can't convert a call to a string.\n\n\nCalls\n\nA call object represents a captured function call.\nCall objects are a special type of list.\n\nThe first component specifies the function to call (usually a symbol, i.e., the name fo the function).\nThe remaining elements are the arguments for that call.\n\nCall objects create branches in the AST, because calls can be nested inside other calls.\nYou can identify a call object when printed because it looks just like a function call.\nConfusingly typeof() and str() print language for call objects (where we might expect it to return that it is a ‚Äúcall‚Äù object), but is.call() returns TRUE:\n\n\nlobstr::ast(read.table(\"important.csv\", row.names = FALSE))\n\n#&gt; ‚ñà‚îÄread.table \n#&gt; ‚îú‚îÄ\"important.csv\" \n#&gt; ‚îî‚îÄrow.names = FALSE\n\n\n\nx &lt;- expr(read.table(\"important.csv\", row.names = FALSE))\n\n\ntypeof(x)\n\n#&gt; [1] \"language\"\n\n\n\nis.call(x)\n\n#&gt; [1] TRUE\n\n\nSubsetting\n\nCalls generally behave like lists.\nSince they are list-like, you can use standard subsetting tools.\nThe first element of the call object is the function to call, which is usually a symbol:\n\n\nx[[1]]\n\n#&gt; read.table\n\n\n\nis.symbol(x[[1]])\n\n#&gt; [1] TRUE\n\n\n\nThe remainder of the elements are the arguments:\n\n\nis.symbol(x[-1])\n\n#&gt; [1] FALSE\n\nas.list(x[-1])\n\n#&gt; [[1]]\n#&gt; [1] \"important.csv\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] FALSE\n\n\n\nWe can extract individual arguments with [[ or, if named, $:\n\n\nx[[2]]\n\n#&gt; [1] \"important.csv\"\n\n\n\nx$row.names\n\n#&gt; [1] FALSE\n\n\n\nWe can determine the number of arguments in a call object by subtracting 1 from its length:\n\n\nlength(x) - 1\n\n#&gt; [1] 2\n\n\n\nExtracting specific arguments from calls is challenging because of R‚Äôs flexible rules for argument matching:\n\nIt could potentially be in any location, with the full name, with an abbreviated name, or with no name.\n\nTo work around this problem, you can use rlang::call_standardise() which standardizes all arguments to use the full name:\n\n\nrlang::call_standardise(x)\n\n#&gt; Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#&gt; This warning is displayed once every 8 hours.\n\n\n#&gt; read.table(file = \"important.csv\", row.names = FALSE)\n\n\n\nBut If the function uses ‚Ä¶ it‚Äôs not possible to standardise all arguments.\nCalls can be modified in the same way as lists:\n\n\nx$header &lt;- TRUE\nx\n\n#&gt; read.table(\"important.csv\", row.names = FALSE, header = TRUE)\n\n\nFunction position\n\nThe first element of the call object is the function position. This contains the function that will be called when the object is evaluated, and is usually a symbol.\n\n\nlobstr::ast(foo())\n\n#&gt; ‚ñà‚îÄfoo\n\n\n\nWhile R allows you to surround the name of the function with quotes, the parser converts it to a symbol:\n\n\nlobstr::ast(\"foo\"())\n\n#&gt; ‚ñà‚îÄfoo\n\n\n\nHowever, sometimes the function doesn‚Äôt exist in the current environment and you need to do some computation to retrieve it:\n\nFor example, if the function is in another package, is a method of an R6 object, or is created by a function factory. In this case, the function position will be occupied by another call:\n\n\n\nlobstr::ast(pkg::foo(1))\n\n#&gt; ‚ñà‚îÄ‚ñà‚îÄ`::` \n#&gt; ‚îÇ ‚îú‚îÄpkg \n#&gt; ‚îÇ ‚îî‚îÄfoo \n#&gt; ‚îî‚îÄ1\n\n\n\nlobstr::ast(obj$foo(1))\n\n#&gt; ‚ñà‚îÄ‚ñà‚îÄ`$` \n#&gt; ‚îÇ ‚îú‚îÄobj \n#&gt; ‚îÇ ‚îî‚îÄfoo \n#&gt; ‚îî‚îÄ1\n\n\n\nlobstr::ast(foo(1)(2))\n\n#&gt; ‚ñà‚îÄ‚ñà‚îÄfoo \n#&gt; ‚îÇ ‚îî‚îÄ1 \n#&gt; ‚îî‚îÄ2\n\n\n\nConstructing\n\nYou can construct a call object from its components using rlang::call2().\nThe first argument is the name of the function to call (either as a string, a symbol, or another call).\nThe remaining arguments will be passed along to the call:\n\n\ncall2(\"mean\", x = expr(x), na.rm = TRUE)\n\n#&gt; mean(x = x, na.rm = TRUE)\n\n\n\ncall2(expr(base::mean), x = expr(x), na.rm = TRUE)\n\n#&gt; base::mean(x = x, na.rm = TRUE)\n\n\n\nInfix calls created in this way still print as usual.\n\n\ncall2(\"&lt;-\", expr(x), 10)\n\n#&gt; x &lt;- 10"
  },
  {
    "objectID": "slides/18.html#parsing-and-grammar",
    "href": "slides/18.html#parsing-and-grammar",
    "title": "Expressions",
    "section": "Parsing and grammar",
    "text": "Parsing and grammar\n\nParsing - The process by which a computer language takes a string and constructs an expression. Parsing is governed by a set of rules known as a grammar.\nWe are going to use lobstr::ast() to explore some of the details of R‚Äôs grammar, and then show how you can transform back and forth between expressions and strings.\nOperator precedence - Conventions used by the programming language to resolve ambiguity.\nInfix functions introduce two sources of ambiguity.\nThe first source of ambiguity arises from infix functions: what does 1 + 2 * 3 yield? Do you get 9 (i.e., (1 + 2) * 3), or 7 (i.e., 1 + (2 * 3))? In other words, which of the two possible parse trees below does R use?\n\n\n\nProgramming languages use conventions called operator precedence to resolve this ambiguity. We can use ast() to see what R does:\n\n\nlobstr::ast(1 + 2 * 3)\n\n#&gt; ‚ñà‚îÄ`+` \n#&gt; ‚îú‚îÄ1 \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`*` \n#&gt;   ‚îú‚îÄ2 \n#&gt;   ‚îî‚îÄ3\n\n\n\nPEMDAS (or BEDMAS or BODMAS, depending on where in the world you grew up) is pretty clear on what to do. Other operator precedence isn‚Äôt as clear.\nThere‚Äôs one particularly surprising case in R:\n\n! has a much lower precedence (i.e., it binds less tightly) than you might expect.\nThis allows you to write useful operations like:\n\n\n\nlobstr::ast(!x %in% y)\n\n#&gt; ‚ñà‚îÄ`!` \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`%in%` \n#&gt;   ‚îú‚îÄx \n#&gt;   ‚îî‚îÄy\n\n\n\nR has over 30 infix operators divided into 18 precedence groups.\nWhile the details are described in ?Syntax, very few people have memorized the complete ordering.\nIf there‚Äôs any confusion, use parentheses!\n\n\n# override PEMDAS\nlobstr::ast((1 + 2) * 3)\n\n#&gt; ‚ñà‚îÄ`*` \n#&gt; ‚îú‚îÄ‚ñà‚îÄ`(` \n#&gt; ‚îÇ ‚îî‚îÄ‚ñà‚îÄ`+` \n#&gt; ‚îÇ   ‚îú‚îÄ1 \n#&gt; ‚îÇ   ‚îî‚îÄ2 \n#&gt; ‚îî‚îÄ3\n\n\nAssociativity\n\nThe second source of ambiguity is introduced by repeated usage of the same infix function.\n\n\n1 + 2 + 3\n\n#&gt; [1] 6\n\n# What does R do first?\n(1 + 2) + 3\n\n#&gt; [1] 6\n\n# or\n1 + (2 + 3)\n\n#&gt; [1] 6\n\n\n\nIn this case it doesn‚Äôt matter. Other places it might, like in ggplot2.\nIn R, most operators are left-associative, i.e., the operations on the left are evaluated first:\n\n\nlobstr::ast(1 + 2 + 3)\n\n#&gt; ‚ñà‚îÄ`+` \n#&gt; ‚îú‚îÄ‚ñà‚îÄ`+` \n#&gt; ‚îÇ ‚îú‚îÄ1 \n#&gt; ‚îÇ ‚îî‚îÄ2 \n#&gt; ‚îî‚îÄ3\n\n\n\nThere are two exceptions to the left-associative rule:\n\nexponentiation\nassignment\n\n\n\nlobstr::ast(2 ^ 2 ^ 3)\n\n#&gt; ‚ñà‚îÄ`^` \n#&gt; ‚îú‚îÄ2 \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`^` \n#&gt;   ‚îú‚îÄ2 \n#&gt;   ‚îî‚îÄ3\n\n\n\nlobstr::ast(x &lt;- y &lt;- z)\n\n#&gt; ‚ñà‚îÄ`&lt;-` \n#&gt; ‚îú‚îÄx \n#&gt; ‚îî‚îÄ‚ñà‚îÄ`&lt;-` \n#&gt;   ‚îú‚îÄy \n#&gt;   ‚îî‚îÄz\n\n\nParsing and deparsing\n\nParsing - turning characters you‚Äôve typed into an AST (i.e., from strings to expressions).\nR usually takes care of parsing code for us.\nBut occasionally you have code stored as a string, and you want to parse it yourself.\nYou can do so using rlang::parse_expr():\n\n\nx1 &lt;- \"y &lt;- x + 10\"\nx1\n\n#&gt; [1] \"y &lt;- x + 10\"\n\nis.call(x1)\n\n#&gt; [1] FALSE\n\n\n\nx2 &lt;- rlang::parse_expr(x1)\nx2\n\n#&gt; y &lt;- x + 10\n\nis.call(x2)\n\n#&gt; [1] TRUE\n\n\n\nparse_expr() always returns a single expression.\nIf you have multiple expression separated by ; or ,, you‚Äôll need to use rlang::parse_exprs() which is the plural version of rlang::parse_expr(). It returns a list of expressions:\n\n\nx3 &lt;- \"a &lt;- 1; a + 1\"\n\n\nrlang::parse_exprs(x3)\n\n#&gt; [[1]]\n#&gt; a &lt;- 1\n#&gt; \n#&gt; [[2]]\n#&gt; a + 1\n\n\n\nIf you find yourself parsing strings into expressions often, quasiquotation may be a safer approach.\n\nMore about quasiquaotation in Chapter 19.\n\nThe inverse of parsing is deparsing.\nDeparsing - given an expression, you want the string that would generate it.\nDeparsing happens automatically when you print an expression.\nYou can get the string with rlang::expr_text():\nParsing and deparsing are not symmetric.\n\nParsing creates the AST which means that we lose backticks around ordinary names, comments, and whitespace.\n\n\n\ncat(expr_text(expr({\n  # This is a comment\n  x &lt;-             `x` + 1\n})))\n\n#&gt; {\n#&gt;     x &lt;- x + 1\n#&gt; }"
  },
  {
    "objectID": "slides/18.html#using-the-ast-to-solve-more-complicated-problems",
    "href": "slides/18.html#using-the-ast-to-solve-more-complicated-problems",
    "title": "Expressions",
    "section": "Using the AST to solve more complicated problems",
    "text": "Using the AST to solve more complicated problems\n\nHere we focus on what we learned to perform recursion on the AST.\nTwo parts of a recursive function:\n\nRecursive case: handles the nodes in the tree. Typically, you‚Äôll do something to each child of a node, usually calling the recursive function again, and then combine the results back together again. For expressions, you‚Äôll need to handle calls and pairlists (function arguments).\nBase case: handles the leaves of the tree. The base cases ensure that the function eventually terminates, by solving the simplest cases directly. For expressions, you need to handle symbols and constants in the base case.\n\n\nTwo helper functions\n\nFirst, we need an epxr_type() function to return the type of expression element as a string.\n\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\n\nexpr_type(expr(\"a\"))\n\n#&gt; [1] \"constant\"\n\nexpr_type(expr(x))\n\n#&gt; [1] \"symbol\"\n\nexpr_type(expr(f(1, 2)))\n\n#&gt; [1] \"call\"\n\n\n\nSecond, we need a wrapper function to handle exceptions.\n\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\n\nLastly, we can write a basic template that walks the AST using the switch() statement.\n\n\nrecurse_call &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    symbol = ,\n    constant = ,\n\n    # Recursive cases\n    call = ,\n    pairlist =\n  )\n}\n\nSpecific use cases for recurse_call()\nExample 1: Finding F and T\n\nUsing F and T in our code rather than FALSE and TRUE is bad practice.\nSay we want to walk the AST to find times when we use F and T.\nStart off by finding the type of T vs TRUE.\n\n\nexpr_type(expr(TRUE))\n\n#&gt; [1] \"constant\"\n\nexpr_type(expr(T))\n\n#&gt; [1] \"symbol\"\n\n\n\nWith this knowledge, we can now write the base cases of our recursive function.\nThe logic is as follows:\n\nA constant is never a logical abbreviation and a symbol is an abbreviation if it is ‚ÄúF‚Äù or ‚ÄúT‚Äù:\n\n\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\")\n  )\n}\n\n\nlogical_abbr_rec(expr(TRUE))\n\n#&gt; [1] FALSE\n\nlogical_abbr_rec(expr(T))\n\n#&gt; [1] TRUE\n\n\n\nIt‚Äôs best practice to write another wrapper, assuming every input you receive will be an expression.\n\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nlogical_abbr(T)\n\n#&gt; [1] TRUE\n\nlogical_abbr(FALSE)\n\n#&gt; [1] FALSE\n\n\nNext step: code for the recursive cases\n\nHere we want to do the same thing for calls and for pairlists.\nHere‚Äôs the logic: recursively apply the function to each subcomponent, and return TRUE if any subcomponent contains a logical abbreviation.\nThis is simplified by using the purrr::some() function, which iterates over a list and returns TRUE if the predicate function is true for any element.\n\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(x,\n  # Base cases\n  constant = FALSE,\n  symbol = as_string(x) %in% c(\"F\", \"T\"),\n  # Recursive cases\n  call = ,\n  # Are we sure this is the correct function to use?\n  # Why not logical_abbr_rec?\n  pairlist = purrr::some(x, logical_abbr_rec)\n  )\n}\n\nlogical_abbr(mean(x, na.rm = T))\n\n#&gt; [1] TRUE\n\nlogical_abbr(function(x, na.rm = T) FALSE)\n\n#&gt; [1] TRUE\n\n\nExample 2: Finding all variables created by assignment\n\nListing all the variables is a little more complicated.\nFigure out what assignment looks like based on the AST.\n\n\nast(x &lt;- 10)\n\n#&gt; ‚ñà‚îÄ`&lt;-` \n#&gt; ‚îú‚îÄx \n#&gt; ‚îî‚îÄ10\n\n\n\nNow we need to decide what data structure we‚Äôre going to use for the results.\n\nEasiest thing will be to return a character vector.\nWe would need to use a list if we wanted to return symbols.\n\n\nDealing with the base cases\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol = character()\n  )\n}\nfind_assign &lt;- function(x) find_assign_rec(enexpr(x))\n\nfind_assign(\"x\")\n\n#&gt; character(0)\n\nfind_assign(x)\n\n#&gt; character(0)\n\n\nDealing with the recursive cases\n\nHere is the function to flatten pairlists.\n\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nflat_map_chr(letters[1:3], ~ rep(., sample(3, 1)))\n\n#&gt; [1] \"a\" \"a\" \"b\" \"b\" \"c\" \"c\"\n\n\n\nHere is the code needed to identify calls.\n\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(as.list(x), find_assign_rec),\n    call = {\n      if (is_call(x, \"&lt;-\")) {\n        as_string(x[[2]])\n      } else {\n        flat_map_chr(as.list(x), find_assign_rec)\n      }\n    }\n  )\n}\n\nfind_assign(a &lt;- 1)\n\n#&gt; [1] \"a\"\n\nfind_assign({\n  a &lt;- 1\n  {\n    b &lt;- 2\n  }\n})\n\n#&gt; [1] \"a\" \"b\"\n\n\nMake the function more robust\n\nThrow cases at it that we think might break the function.\nWrite a function to handle these cases.\n\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nfind_assign(system.time(x &lt;- print(y &lt;- 5)))\n\n#&gt; [1] \"x\" \"y\"\n\n\n\nThis approach certainly is more complicated, but it‚Äôs important to start simple and move up."
  },
  {
    "objectID": "slides/18.html#specialised-data-structures",
    "href": "slides/18.html#specialised-data-structures",
    "title": "Expressions",
    "section": "Specialised data structures",
    "text": "Specialised data structures\n\nPairlists\nMissing arguments\nExpression vectors\n\nPairlists\n\nPairlists are a remnant of R‚Äôs past and have been replaced by lists almost everywhere.\nThe only place you are likely to see pairlists in R is when working with calls to the function, as the formal arguments to a function are stored in a pairlist:\n\n\nf &lt;- expr(function(x, y = 10) x + y)\n\n\nargs &lt;- f[[2]]\nargs\n\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n#&gt; [1] 10\n\n\n\ntypeof(args)\n\n#&gt; [1] \"pairlist\"\n\n\n\nFortunately, whenever you encounter a pairlist, you can treat it just like a regular list:\n\n\npl &lt;- pairlist(x = 1, y = 2)\n\n\nlength(pl)\n\n#&gt; [1] 2\n\n\n\npl$x\n\n#&gt; [1] 1\n\n\nMissing arguments\n\nEmpty symbols\nTo create an empty symbol, you need to use missing_arg() or expr().\n\n\nmissing_arg()\ntypeof(missing_arg())\n\n#&gt; [1] \"symbol\"\n\n\n\nEmpty symbols don‚Äôt print anything.\n\nTo check, we need to use rlang::is_missing()\n\n\n\nis_missing(missing_arg())\n\n#&gt; [1] TRUE\n\n\n\nThese are usually present in function formals:\n\n\nf &lt;- expr(function(x, y = 10) x + y)\n\nargs &lt;- f[[2]]\n\n\nis_missing(args[[1]])\n\n#&gt; [1] TRUE\n\n\nExpression vectors\n\nAn expression vector is just a list of expressions.\n\nThe only difference is that calling eval() on an expression evaluates each individual expression.\nInstead, it might be more advantageous to use a list of expressions.\n\nExpression vectors are only produced by two base functions: expression() and parse():\n\n\nexp1 &lt;- parse(text = c(\" \nx &lt;- 4\nx\n\"))\nexp1\n\n#&gt; expression(x &lt;- 4, x)\n\n\n\nexp2 &lt;- expression(x &lt;- 4, x)\nexp2\n\n#&gt; expression(x &lt;- 4, x)\n\n\n\ntypeof(exp1)\n\n#&gt; [1] \"expression\"\n\ntypeof(exp2)\n\n#&gt; [1] \"expression\"\n\n\n\nLike calls and pairlists, expression vectors behave like lists:\n\n\nlength(exp1)\n\n#&gt; [1] 2\n\nexp1[[1]]\n\n#&gt; x &lt;- 4"
  },
  {
    "objectID": "slides/20.html#learning-objectives",
    "href": "slides/20.html#learning-objectives",
    "title": "Evaluation",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nLearn evaluation basics\nLearn about quosures and data mask\nUnderstand tidy evaluation\n\n\nlibrary(rlang)\nlibrary(purrr)"
  },
  {
    "objectID": "slides/20.html#a-bit-of-a-recap",
    "href": "slides/20.html#a-bit-of-a-recap",
    "title": "Evaluation",
    "section": "A bit of a recap",
    "text": "A bit of a recap\n\nMetaprogramming: To separate our description of the action from the action itself - Separate the code from its evaluation.\nQuasiquotation: combine code written by the function‚Äôs author with code written by the function‚Äôs user.\n\nUnquotation: it gives the user the ability to evaluate parts of a quoted argument.\nEvaluation: it gives the developer the ability to evluated quoted expression in custom environments.\n\n\nTidy evaluation: quasiquotation, quosures and data masks"
  },
  {
    "objectID": "slides/20.html#evaluation-basics",
    "href": "slides/20.html#evaluation-basics",
    "title": "Evaluation",
    "section": "Evaluation basics",
    "text": "Evaluation basics\nWe use eval() to evaluate, run, or execute expressions. It requires two arguments:\n\nexpr: the object to evaluate, either an expression or a symbol.\nenv: the environment in which to evaluate the expression or where to look for the values. Defaults to current env.\n\n\nsumexpr &lt;- expr(x + y)\nx &lt;- 10\ny &lt;- 40\neval(sumexpr)\n\n#&gt; [1] 50\n\n\n\neval(sumexpr, envir = env(x = 1000, y = 10))\n\n#&gt; [1] 1010"
  },
  {
    "objectID": "slides/20.html#application-reimplementing-source",
    "href": "slides/20.html#application-reimplementing-source",
    "title": "Evaluation",
    "section": "Application: reimplementing source()",
    "text": "Application: reimplementing source()\nWhat do we need?\n\nRead the file being sourced.\nParse its expressions (quote them?)\nEvaluate each expression saving the results\nReturn the results\n\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- NULL\n  for (i in seq_along(exprs)) {\n    res &lt;- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n\nThe real source is much more complex."
  },
  {
    "objectID": "slides/20.html#quosures",
    "href": "slides/20.html#quosures",
    "title": "Evaluation",
    "section": "Quosures",
    "text": "Quosures\nquosures are a data structure from rlang containing both and expression and an environment\nQuoting + closure because it quotes the expression and encloses the environment.\nThree ways to create them:\n\nUsed mostly for learning: new_quosure(), creates a quosure from its components.\n\n\nq1 &lt;- rlang::new_quosure(expr(x + y), \n                         env(x = 1, y = 10))\n\nWith a quosure, we can use eval_tidy() directly.\n\nrlang::eval_tidy(q1)\n\n#&gt; [1] 11\n\n\nAnd get its components\n\nrlang::get_expr(q1)\n\n#&gt; x + y\n\nrlang::get_env(q1)\n\n#&gt; &lt;environment: 0x000001f161f6d698&gt;\n\n\nOr set them\n\nq1 &lt;- set_env(q1, env(x = 3, y = 4))\neval_tidy(q1)\n\n#&gt; [1] 7\n\n\n\nUsed in the real world: enquo() o enquos(), to capture user supplied expressions. They take the environment from where they‚Äôre created.\n\n\nfoo &lt;- function(x) enquo(x)\nquo_foo &lt;- foo(a + b)\n\n\nget_expr(quo_foo)\n\n#&gt; a + b\n\nget_env(quo_foo)\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n\nAlmost never used: quo() and quos(), to match to expr() and exprs()."
  },
  {
    "objectID": "slides/20.html#quosures-and-...",
    "href": "slides/20.html#quosures-and-...",
    "title": "Evaluation",
    "section": "Quosures and ...",
    "text": "Quosures and ...\nQuosures are just a convenience, but they are essential when it comes to working with ..., because you can have each argument from ... associated with a different environment.\n\ng &lt;- function(...) {\n  ## Creating our quosures from ...\n  enquos(...)\n}\n\ncreateQuos &lt;- function(...) {\n  ## symbol from the function environment\n  x &lt;- 1\n  g(..., f = x)\n}\n\n\n## symbol from the global environment\nx &lt;- 0\nqs &lt;- createQuos(global = x)\nqs\n\n#&gt; &lt;list_of&lt;quosure&gt;&gt;\n#&gt; \n#&gt; $global\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  global\n#&gt; \n#&gt; $f\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  0x000001f15fc6f2e0"
  },
  {
    "objectID": "slides/20.html#other-facts-about-quosures",
    "href": "slides/20.html#other-facts-about-quosures",
    "title": "Evaluation",
    "section": "Other facts about quosures",
    "text": "Other facts about quosures\nFormulas were the inspiration for closures because they also capture an expression and an environment\n\nf &lt;- ~runif(3)\nstr(f)\n\n#&gt; Class 'formula'  language ~runif(3)\n#&gt;   ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt;\n\n\nThere was an early version of tidy evaluation with formulas, but there‚Äôs no easy way to implement quasiquotation with them.\nThey are actually call objects\n\nq4 &lt;- new_quosure(expr(x + y + z))\nclass(q4)\n\n#&gt; [1] \"quosure\" \"formula\"\n\nis.call(q4)\n\n#&gt; [1] TRUE\n\n\nwith an attribute to store the environment\n\nattr(q4, \".Environment\")\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nNested quosures\nWith quosiquotation we can embed quosures in expressions.\n\nq2 &lt;- new_quosure(expr(x), env(x = 1))\nq3 &lt;- new_quosure(expr(x), env(x = 100))\n\nnq &lt;- expr(!!q2 + !!q3)\n\nAnd evaluate them\n\neval_tidy(nq)\n\n#&gt; [1] 101\n\n\nBut for printing it‚Äôs better to use expr_print(x)\n\nexpr_print(nq)\n\n#&gt; (^x) + (^x)\n\nnq\n\n#&gt; (~x) + ~x"
  },
  {
    "objectID": "slides/20.html#data-mask",
    "href": "slides/20.html#data-mask",
    "title": "Evaluation",
    "section": "Data mask",
    "text": "Data mask\nA data frame where the evaluated code will look first for its variable definitions.\nUsed in packages like dplyr and ggplot.\nTo use it we need to supply the data mask as a second argument to eval_tidy()\n\nq1 &lt;- new_quosure(expr(x * y), env(x = 100))\ndf &lt;- data.frame(y = 1:10)\n\neval_tidy(q1, df)\n\n#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000\n\n\nEverything together, in one function.\n\nwith2 &lt;- function(data, expr) {\n  expr &lt;- enquo(expr)\n  eval_tidy(expr, data)\n}\n\nBut we need to create the objects that are not part of our data mask\n\nx &lt;- 100\nwith2(df, x * y)\n\n#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000\n\n\nAlso doable with base::eval() instead of rlang::eval_tidy() but we have to use base::substitute() instead of enquo() (like we did for enexpr()) and we need to specify the environment.\n\nwith3 &lt;- function(data, expr) {\n  expr &lt;- substitute(expr)\n  eval(expr, data, caller_env())\n}\n\n\nwith3(df, x*y)\n\n#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000"
  },
  {
    "objectID": "slides/20.html#pronouns-.data-and-.env",
    "href": "slides/20.html#pronouns-.data-and-.env",
    "title": "Evaluation",
    "section": "Pronouns: .data$ and .env$",
    "text": "Pronouns: .data$ and .env$\nAmbiguity!!\nAn object value can come from the env or from the data mask\n\nq1 &lt;- new_quosure(expr(x * y + x), env = env(x = 1))\ndf &lt;- data.frame(y = 1:5, \n                 x = 10)\n\neval_tidy(q1, df)\n\n#&gt; [1] 20 30 40 50 60\n\n\nWe use pronouns:\n\n.data$x: x from the data mask\n.env$x: x from the environment\n\n\nq1 &lt;- new_quosure(expr(.data$x * y + .env$x), env = env(x = 1))\neval_tidy(q1, df)\n\n#&gt; [1] 11 21 31 41 51"
  },
  {
    "objectID": "slides/20.html#application-reimplementing-basesubset",
    "href": "slides/20.html#application-reimplementing-basesubset",
    "title": "Evaluation",
    "section": "Application: reimplementing base::subset()",
    "text": "Application: reimplementing base::subset()\nbase::subset() works like dplyr::filter(): it selects rows of a data frame given an expression.\nWhat do we need?\n\nQuote the expression to filter\nFigure out which rows in the data frame pass the filter\nSubset the data frame\n\n\nsubset2 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\n\nsample_df &lt;- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 2, 4, 1))\n\n# Shorthand for sample_df[sample_df$b == sample_df$c, ]\nsubset2(sample_df, b == c)\n\n#&gt;   a b c\n#&gt; 1 1 5 5\n#&gt; 5 5 1 1"
  },
  {
    "objectID": "slides/20.html#using-tidy-evaluation",
    "href": "slides/20.html#using-tidy-evaluation",
    "title": "Evaluation",
    "section": "Using tidy evaluation",
    "text": "Using tidy evaluation\nMost of the time we might not call it directly, but call a function that uses eval_tidy() (becoming developer AND user)\nUse case: resample and subset\nWe have a function that resamples a dataset:\n\nresample &lt;- function(df, n) {\n  idx &lt;- sample(nrow(df), n, replace = TRUE)\n  df[idx, , drop = FALSE]\n}\n\n\nresample(sample_df, 10)\n\n#&gt;     a b c\n#&gt; 4   4 2 4\n#&gt; 3   3 3 2\n#&gt; 1   1 5 5\n#&gt; 1.1 1 5 5\n#&gt; 3.1 3 3 2\n#&gt; 5   5 1 1\n#&gt; 5.1 5 1 1\n#&gt; 3.2 3 3 2\n#&gt; 5.2 5 1 1\n#&gt; 4.1 4 2 4\n\n\nBut we also want to use subset and we want to create a function that allow us to resample and subset (with subset2()) in a single step.\nFirst attempt:\n\nsubsample &lt;- function(df, cond, n = nrow(df)) {\n  df &lt;- subset2(df, cond)\n  resample(df, n)\n}\n\n\nsubsample(sample_df, b == c, 10)\n\n#&gt; Error: object 'b' not found\n\n\nWhat happened?\nsubsample() doesn‚Äôt quote any arguments and cond is evaluated normally\nSo we have to quote cond and unquote it when we pass it to subset2()\n\nsubsample &lt;- function(df, cond, n = nrow(df)) {\n  cond &lt;- enquo(cond)\n\n  df &lt;- subset2(df, !!cond)\n  resample(df, n)\n}\n\n\nsubsample(sample_df, b == c, 10)\n\n#&gt;     a b c\n#&gt; 5   5 1 1\n#&gt; 5.1 5 1 1\n#&gt; 5.2 5 1 1\n#&gt; 1   1 5 5\n#&gt; 5.3 5 1 1\n#&gt; 1.1 1 5 5\n#&gt; 5.4 5 1 1\n#&gt; 5.5 5 1 1\n#&gt; 1.2 1 5 5\n#&gt; 1.3 1 5 5\n\n\nBe careful!, potential ambiguity:\n\nthreshold_x &lt;- function(df, val) {\n  subset2(df, x &gt;= val)\n}\n\nWhat would happen if x exists in the calling environment but doesn‚Äôt exist in df? Or if val also exists in df?\nSo, as developers of threshold_x() and users of subset2(), we have to add some pronouns:\n\nthreshold_x &lt;- function(df, val) {\n  subset2(df, .data$x &gt;= .env$val)\n}\n\nJust remember:\n\nAs a general rule of thumb, as a function author it‚Äôs your responsibility to avoid ambiguity with any expressions that you create; it‚Äôs the user‚Äôs responsibility to avoid ambiguity in expressions that they create."
  },
  {
    "objectID": "slides/20.html#base-evaluation",
    "href": "slides/20.html#base-evaluation",
    "title": "Evaluation",
    "section": "Base evaluation",
    "text": "Base evaluation\nCheck 20.6 in the book!"
  },
  {
    "objectID": "slides/22.html#learning-objectives",
    "href": "slides/22.html#learning-objectives",
    "title": "Debugging",
    "section": "Learning objectives:",
    "text": "Learning objectives:\n\nGeneral strategy for finding and fixing errors.\nExplore the traceback() function to locate exactly where an error occurred\nExplore how to pause the execution of a function and launch environment where we can interactively explore what‚Äôs happening\nExplore debugging when you‚Äôre running code non-interactively\nExplore non-error problems that occasionally also need debugging"
  },
  {
    "objectID": "slides/22.html#introduction",
    "href": "slides/22.html#introduction",
    "title": "Debugging",
    "section": "Introduction",
    "text": "Introduction\n\nFinding bug in code, is a process of confirming the many things that we believe are true ‚Äî until we find one which is not true.\n\n‚ÄîNorm Matloff\n\nDebugging is like being the detective in a crime movie where you‚Äôre also the murderer.\n\n-Filipe Fortes\nStrategies for finding and fixing errors\nGoogle!\nWhenever you see an error message, start by googling it. We can automate this process with the {errorist} and {searcher} packages.\nMake it repeatable\nTo find the root cause of an error, you‚Äôre going to need to execute the code many times as you consider and reject hypotheses. It‚Äôs worth some upfront investment to make the problem both easy and fast to reproduce.\nFigure out where it is\nTo find the bug, adopt the scientific method: generate hypotheses, design experiments to test them, and record your results. This may seem like a lot of work, but a systematic approach will end up saving you time.\nFix it and test it\nOnce you‚Äôve found the bug, you need to figure out how to fix it and to check that the fix actually worked. It‚Äôs very useful to have automated tests in place."
  },
  {
    "objectID": "slides/22.html#locating-errors",
    "href": "slides/22.html#locating-errors",
    "title": "Debugging",
    "section": "Locating errors",
    "text": "Locating errors\nThe most important tool for finding errors is traceback(), which shows you the sequence of calls (also known as the call stack) that lead to the error.\n\nHere‚Äôs a simple example where f() calls g() calls h() calls i(), which checks if its argument is numeric:\n\n When we run f(\"a\") code in RStudio we see:\n\nIf you click ‚ÄúShow traceback‚Äù you see: \nYou read the traceback() output from bottom to top: the initial call is f(), which calls g(), then h(), then i(), which triggers the error."
  },
  {
    "objectID": "slides/22.html#lazy-evaluation",
    "href": "slides/22.html#lazy-evaluation",
    "title": "Debugging",
    "section": "Lazy evaluation",
    "text": "Lazy evaluation\nOne drawback to traceback() is that it always linearises the call tree, which can be confusing if there is much lazy evaluation involved. For example, take the following example where the error happens when evaluating the first argument to f():\n\n\nNote: rlang::with_abort() is no longer an exported object from ‚Äònamespace:rlang‚Äô. There is an open issue about a fix for the chapter but no drop-in replacement."
  },
  {
    "objectID": "slides/22.html#interactive-debugger",
    "href": "slides/22.html#interactive-debugger",
    "title": "Debugging",
    "section": "Interactive debugger",
    "text": "Interactive debugger\nEnter the interactive debugger is wwith RStudio‚Äôs ‚ÄúRerun with Debug‚Äù tool. This reruns the command that created the error, pausing execution where the error occurred. Otherwise, you can insert a call to browser() where you want to pause, and re-run the function.\n\nbrowser() is just a regular function call which means that you can run it conditionally by wrapping it in an if statement:"
  },
  {
    "objectID": "slides/22.html#browser-commands",
    "href": "slides/22.html#browser-commands",
    "title": "Debugging",
    "section": "browser() commands",
    "text": "browser() commands\nbrowser() provides a few special commands.\n\n\nNext, n: executes the next step in the function.\nStep into, or s: works like next, but if the next step is a function, it will step into that function so you can explore it interactively.\nFinish, or f: finishes execution of the current loop or function.\nContinue, c: leaves interactive debugging and continues regular execution of the function.\nStop, Q: stops debugging, terminates the function, and returns to the global workspace."
  },
  {
    "objectID": "slides/22.html#alternatives",
    "href": "slides/22.html#alternatives",
    "title": "Debugging",
    "section": "Alternatives",
    "text": "Alternatives\nThere are three alternatives to using browser(): setting breakpoints in RStudio, options(error = recover), and debug() and other related functions."
  },
  {
    "objectID": "slides/22.html#breakpoints",
    "href": "slides/22.html#breakpoints",
    "title": "Debugging",
    "section": "Breakpoints",
    "text": "Breakpoints\nIn RStudio, you can set a breakpoint by clicking to the left of the line number, or pressing Shift + F9. There are two small downsides to breakpoints:\n\nThere are a few unusual situations in which breakpoints will not work. Read breakpoint troubleshooting for more details\nRStudio currently does not support conditional breakpoints."
  },
  {
    "objectID": "slides/22.html#recover",
    "href": "slides/22.html#recover",
    "title": "Debugging",
    "section": "recover()",
    "text": "recover()\nWhen you set options(error = recover), when you get an error, you‚Äôll get an interactive prompt that displays the traceback and gives you the ability to interactively debug inside any of the frames:\n You can return to default error handling with options(error = NULL)."
  },
  {
    "objectID": "slides/22.html#debug",
    "href": "slides/22.html#debug",
    "title": "Debugging",
    "section": "debug()",
    "text": "debug()\nAnother approach is to call a function that inserts the browser() call:\n\ndebug() inserts a browser statement in the first line of the specified function. undebug() removes it.\nutils::setBreakpoint() works similarly, but instead of taking a function name, it takes a file name and line number and finds the appropriate function for you."
  },
  {
    "objectID": "slides/22.html#call-stack",
    "href": "slides/22.html#call-stack",
    "title": "Debugging",
    "section": "Call stack",
    "text": "Call stack\nThe call stacks printed by traceback(), browser() & where, and recover() are not consistent.\n\nRStudio displays calls in the same order as traceback(). rlang functions use the same ordering and numbering as recover(), but also use indenting to reinforce the hierarchy of calls."
  },
  {
    "objectID": "slides/22.html#non-interactive-debugging",
    "href": "slides/22.html#non-interactive-debugging",
    "title": "Debugging",
    "section": "Non-interactive debugging",
    "text": "Non-interactive debugging\nWhen you can‚Äôt explore interactively‚Ä¶\ncallr::r()\ncallr::r(f, list(1, 2)) calls f(1, 2) in a fresh session to help diagnose:\n\nIs the global environment different? Have you loaded different packages? Are objects left from previous sessions causing differences?\nIs the working directory different?\nIs the PATH environment variable different?\nIs the R_LIBS environment variable different?\n\ndump.frames()\ndump.frames() is the equivalent to recover() for non-interactive code.\n\nPrint debugging\nInsert numerous print statements to precisely locate the problem, and see the values of important variables. Print debugging is particularly useful for compiled code.\n\nRMarkdown\n\nIf you‚Äôre knitting the file using RStudio, switch to calling rmarkdown::render(\"path/to/file.Rmd\") instead to run the code in the current session.\nFor interactive debugging, you‚Äôll need to call sink() in the error handler. For example, to use recover() with RMarkdown, you‚Äôd put the following code in your setup block:"
  },
  {
    "objectID": "slides/22.html#non-error-failures",
    "href": "slides/22.html#non-error-failures",
    "title": "Debugging",
    "section": "Non-error failures",
    "text": "Non-error failures\nThere are other ways for a function to fail apart from throwing an error:\n\nA function may generate an unexpected warning. Convert warnings into errors with options(warn = 2) and use the the call stack.\nA function may generate an unexpected message. The removal of with_abort() from {rlang} breaks this solution.\nA function might never return.\nThe worst scenario is that your code might crash R completely, leaving you with no way to interactively debug your code. This indicates a bug in compiled (C or C++) code."
  },
  {
    "objectID": "slides/22.html#link-to-some-useful-resources-on-debugging",
    "href": "slides/22.html#link-to-some-useful-resources-on-debugging",
    "title": "Debugging",
    "section": "Link to some useful resources on debugging",
    "text": "Link to some useful resources on debugging\n\nJenny Bryan‚Äôs ‚ÄúObject of type closure is not subsettable‚Äù talk from rstudio::conf 2020\nJenny Bryan and Jim Hester‚Äôs book: ‚ÄúWhat They Forgot to Teach You About R‚Äù Ch12\nHadley‚Äôs video on a minimal reprex for a shiny app"
  },
  {
    "objectID": "slides/24.html#overview",
    "href": "slides/24.html#overview",
    "title": "Improving performance",
    "section": "Overview",
    "text": "Overview\n\nCode organization\nCheck for existing solutions\nDo as little as possible\nVectorise\nAvoid Copies"
  },
  {
    "objectID": "slides/24.html#organizing-code",
    "href": "slides/24.html#organizing-code",
    "title": "Improving performance",
    "section": "Organizing code",
    "text": "Organizing code\n\nWrite a function for each approach\n\n\nmean1 &lt;- function(x) mean(x)\nmean2 &lt;- function(x) sum(x) / length(x)\n\n\nKeep old functions that you‚Äôve tried, even the failures\nGenerate a representative test case\n\n\nx &lt;- runif(1e5)\n\n\nUse bench::mark to compare the different versions (and include unit tests)\n\n\nbench::mark(\n  mean1(x),\n  mean2(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 2 √ó 4\n#&gt;   expression      min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean1(x)    146.4¬µs  166.8¬µs     5839.\n#&gt; 2 mean2(x)     67.1¬µs   75.7¬µs    12950."
  },
  {
    "objectID": "slides/24.html#check-for-existing-solution",
    "href": "slides/24.html#check-for-existing-solution",
    "title": "Improving performance",
    "section": "Check for Existing Solution",
    "text": "Check for Existing Solution\n\nCRAN task views (http://cran.rstudio.com/web/views/)\nReverse dependencies of Rcpp (https://cran.r-project.org/web/packages/Rcpp/)\nTalk to others!\n\nGoogle (rseek)\nStackoverflow ([R])\nhttps://community.rstudio.com/\nDSLC community"
  },
  {
    "objectID": "slides/24.html#do-as-little-as-possible",
    "href": "slides/24.html#do-as-little-as-possible",
    "title": "Improving performance",
    "section": "Do as little as possible",
    "text": "Do as little as possible\n\nuse a function tailored to a more specific type of input or output, or to a more specific problem\n\nrowSums(), colSums(), rowMeans(), and colMeans() are faster than equivalent invocations that use apply() because they are vectorised\nvapply() is faster than sapply() because it pre-specifies the output type\nany(x == 10) is much faster than 10 %in% x because testing equality is simpler than testing set inclusion\n\nSome functions coerce their inputs into a specific type. If your input is not the right type, the function has to do extra work\n\ne.g.¬†apply() will always turn a dataframe into a matrix\n\nOther examples\n\nread.csv(): specify known column types with colClasses. (Also consider switching to readr::read_csv() or data.table::fread() which are considerably faster than read.csv().)\nfactor(): specify known levels with levels.\ncut(): don‚Äôt generate labels with labels = FALSE if you don‚Äôt need them, or, even better, use findInterval() as mentioned in the ‚Äúsee also‚Äù section of the documentation.\nunlist(x, use.names = FALSE) is much faster than unlist(x).\ninteraction(): if you only need combinations that exist in the data, use drop = TRUE."
  },
  {
    "objectID": "slides/24.html#avoiding-method-dispatch",
    "href": "slides/24.html#avoiding-method-dispatch",
    "title": "Improving performance",
    "section": "Avoiding Method Dispatch",
    "text": "Avoiding Method Dispatch\n\nx &lt;- runif(1e2)\nbench::mark(\n  mean(x),\n  mean.default(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 2 √ó 4\n#&gt;   expression           min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)            2.8¬µs    3.1¬µs   295383.\n#&gt; 2 mean.default(x)    900ns    1.1¬µs   839532.\n\n\n\nx &lt;- runif(1e2)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 3 √ó 4\n#&gt;   expression              min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)               2.7¬µs    2.9¬µs   310733.\n#&gt; 2 mean.default(x)       900ns    1.1¬µs   849192.\n#&gt; 3 .Internal(mean(x))    100ns    200ns  4495392.\n\n\n\nx &lt;- runif(1e4)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 3 √ó 4\n#&gt;   expression              min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)              16.6¬µs   17.3¬µs    55604.\n#&gt; 2 mean.default(x)      14.4¬µs   14.9¬µs    64958.\n#&gt; 3 .Internal(mean(x))   13.6¬µs   13.7¬µs    70368."
  },
  {
    "objectID": "slides/24.html#avoiding-input-coercion",
    "href": "slides/24.html#avoiding-input-coercion",
    "title": "Improving performance",
    "section": "Avoiding Input Coercion",
    "text": "Avoiding Input Coercion\n\nas.data.frame() is quite slow because it coerces each element into a data frame and then rbind()s them together\ninstead, if you have a named list with vectors of equal length, you can directly transform it into a data frame\n\n\nquickdf &lt;- function(l) {\n  class(l) &lt;- \"data.frame\"\n  attr(l, \"row.names\") &lt;- .set_row_names(length(l[[1]]))\n  l\n}\nl &lt;- lapply(1:26, function(i) runif(1e3))\nnames(l) &lt;- letters\nbench::mark(\n  as.data.frame = as.data.frame(l),\n  quick_df      = quickdf(l)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 2 √ó 4\n#&gt;   expression         min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 as.data.frame  589.5¬µs  656.2¬µs     1447.\n#&gt; 2 quick_df         3.7¬µs    4.3¬µs   207929.\n\n\nCaveat! This method is fast because it‚Äôs dangerous!"
  },
  {
    "objectID": "slides/24.html#vectorise",
    "href": "slides/24.html#vectorise",
    "title": "Improving performance",
    "section": "Vectorise",
    "text": "Vectorise\n\nvectorisation means finding the existing R function that is implemented in C and most closely applies to your problem\nVectorised functions that apply to many scenarios\n\nrowSums(), colSums(), rowMeans(), and colMeans()\nVectorised subsetting can lead to big improvements in speed\ncut() and findInterval() for converting continuous variables to categorical\nBe aware of vectorised functions like cumsum() and diff()\nMatrix algebra is a general example of vectorisation"
  },
  {
    "objectID": "slides/24.html#avoiding-copies",
    "href": "slides/24.html#avoiding-copies",
    "title": "Improving performance",
    "section": "Avoiding copies",
    "text": "Avoiding copies\n\nWhenever you use c(), append(), cbind(), rbind(), or paste() to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home.\n\n\nrandom_string &lt;- function() {\n  paste(sample(letters, 50, replace = TRUE), collapse = \"\")\n}\nstrings10 &lt;- replicate(10, random_string())\nstrings100 &lt;- replicate(100, random_string())\ncollapse &lt;- function(xs) {\n  out &lt;- \"\"\n  for (x in xs) {\n    out &lt;- paste0(out, x)\n  }\n  out\n}\nbench::mark(\n  loop10  = collapse(strings10),\n  loop100 = collapse(strings100),\n  vec10   = paste(strings10, collapse = \"\"),\n  vec100  = paste(strings100, collapse = \"\"),\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n\n#&gt; # A tibble: 4 √ó 4\n#&gt;   expression      min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 loop10       17.1¬µs     18¬µs    52743.\n#&gt; 2 loop100     460.3¬µs  491.5¬µs     1959.\n#&gt; 3 vec10         2.7¬µs    2.9¬µs   317912.\n#&gt; 4 vec100       16.3¬µs   18.5¬µs    51297."
  },
  {
    "objectID": "slides/24.html#case-study-t-test",
    "href": "slides/24.html#case-study-t-test",
    "title": "Improving performance",
    "section": "Case study: t-test",
    "text": "Case study: t-test\n\nm &lt;- 1000\nn &lt;- 50\nX &lt;- matrix(rnorm(m * n, mean = 10, sd = 3), nrow = m)\ngrp &lt;- rep(1:2, each = n / 2)\n\n\n# formula interface\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, ] ~ grp)$statistic\n  }\n)\n\n#&gt;    user  system elapsed \n#&gt;    0.28    0.00    0.33\n\n# provide two vectors\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n  }\n)\n\n#&gt;    user  system elapsed \n#&gt;    0.08    0.00    0.08\n\n\nAdd functionality to save values\n\ncompT &lt;- function(i){\n  t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n}\nsystem.time(t1 &lt;- purrr::map_dbl(1:m, compT))\n\n#&gt;    user  system elapsed \n#&gt;    0.09    0.00    0.09\n\n\nIf you look at the source code of stats:::t.test.default(), you‚Äôll see that it does a lot more than just compute the t-statistic.\n\n# Do less work\nmy_t &lt;- function(x, grp) {\n  t_stat &lt;- function(x) {\n    m &lt;- mean(x)\n    n &lt;- length(x)\n    var &lt;- sum((x - m) ^ 2) / (n - 1)\n    list(m = m, n = n, var = var)\n  }\n  g1 &lt;- t_stat(x[grp == 1])\n  g2 &lt;- t_stat(x[grp == 2])\n  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\nsystem.time(t2 &lt;- purrr::map_dbl(1:m, ~ my_t(X[.,], grp)))\n\n#&gt;    user  system elapsed \n#&gt;    0.02    0.00    0.01\n\nstopifnot(all.equal(t1, t2))\n\nThis gives us a six-fold speed improvement!\n\n# Vectorise it\nrowtstat &lt;- function(X, grp){\n  t_stat &lt;- function(X) {\n    m &lt;- rowMeans(X)\n    n &lt;- ncol(X)\n    var &lt;- rowSums((X - m) ^ 2) / (n - 1)\n    list(m = m, n = n, var = var)\n  }\n  g1 &lt;- t_stat(X[, grp == 1])\n  g2 &lt;- t_stat(X[, grp == 2])\n  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\nsystem.time(t3 &lt;- rowtstat(X, grp))\n\n#&gt;    user  system elapsed \n#&gt;    0.02    0.00    0.02\n\nstopifnot(all.equal(t1, t3))\n\n1000 times faster than when we started!"
  },
  {
    "objectID": "slides/24.html#other-techniques",
    "href": "slides/24.html#other-techniques",
    "title": "Improving performance",
    "section": "Other techniques",
    "text": "Other techniques\n\nRead R blogs to see what performance problems other people have struggled with, and how they have made their code faster.\nRead other R programming books, like The Art of R Programming or Patrick Burns‚Äô R Inferno to learn about common traps.\nTake an algorithms and data structure course to learn some well known ways of tackling certain classes of problems. I have heard good things about Princeton‚Äôs Algorithms course offered on Coursera.\nLearn how to parallelise your code. Two places to start are Parallel R and Parallel Computing for Data Science\nRead general books about optimisation like Mature optimisation or the Pragmatic Programmer\nRead more R code. StackOverflow, R Mailing List, DSLC, GitHub, etc."
  },
  {
    "objectID": "videos/01/06.html",
    "href": "videos/01/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:14:40    SriRam: From Toronto, Civil Engineer. I use R for infrastructure planning/ GIS. Here coz of the ping üòÑ , was not ready with a good computer with mic/audio !\n00:15:20    SriRam: I was with Ryan, Federica on other courses\n00:23:21    SriRam: I think the only caution is about Copyright issues\n00:31:32    Ryan Metcalf:   Citation, giving credit back to source. Great comment SriRam.\n00:34:33    SriRam: one = one, in my opinion\n00:41:53    Ryan Metcalf:   https://docs.google.com/spreadsheets/d/1_WFY82UxAdvP4GUdZ2luh15quwdO1n0Km3Q0tfYuqvc/edit#gid=0\n00:48:35    Arthur Shaw:    The README has a nice step-by-step process at the bottom: https://github.com/r4ds/bookclub-advr#how-to-present. I've not done this myself yet, but it looks fairly straightforward.\n00:54:13    lucus w:    Thanks Ryan. Probably {usethis} will be easier. It looks straight forward\n01:00:02    Moria W.:   Thank you for sharing that. This has been good!\n01:00:08    Vaibhav Janve:  Thank you\n01:00:44    Federica Gazzelloni:    hi SriRam we are going.."
  },
  {
    "objectID": "videos/02/06.html",
    "href": "videos/02/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:16:57    Federica Gazzelloni:    cohort 2 video: https://www.youtube.com/watch?v=pCiNj2JRK50\n00:18:39    Federica Gazzelloni:    cohort 2 presentation: https://r4ds.github.io/bookclub-Advanced_R/Presentations/Week02/Cohort2_America/Chapter2Slides.html#1\n00:40:24    Arthur Shaw:    Just the opposite, Ryan. Very clear presentation!\n00:51:54    Trevin: parquet?\n00:53:00    Arthur Shaw:    We may all be right. {arrow} looks to deal with feather and parquet files: https://arrow.apache.org/docs/r/\n01:00:04    Arthur Shaw:    Some questions for future meetings. (1) I find Ryan's use of slides hugely effective in conveying information. Would it be OK if future sessions (optionally) used slides? If so, should/could we commit slides to some folder on the repo? (2) I think reusing the images from Hadley's books really helps understanding and discussion. Is that OK to do? Here I'm thinking about copyright concerns. (If possible, I would rather not redraw variants of Hadley's images.)\n01:01:35    Federica Gazzelloni:    It's all ok, you can use past presentation, you don't need to push them to the repo, you can use the images from the book\n01:07:19    Federica Gazzelloni:    Can I use: gc(reset = TRUE) safely?"
  },
  {
    "objectID": "videos/03/06.html",
    "href": "videos/03/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:10:18    Oluwafemi Oyedele:  Hi, good evening\n00:23:31    Federica Gazzelloni:    Hi Kiante!\n00:24:21    Federica Gazzelloni:    Thanks Arthur\n00:25:46    Trevin: Welcome Matt!\n00:26:02    Matt Dupree:    hello! thank you!\n00:30:34    Federica Gazzelloni:    Hello Matt!\n00:30:46    Matt Dupree:    hello!\n00:38:24    Ryan Metcalf:   `rlang::cpl()` = ‚Äúcomplex‚Äù. For example `0+1i`\n00:55:37    Trevin: &gt; two &lt;- c(1,2,3)\n&gt; names(two) &lt;- c(\"one\", \"two\")\n&gt; two\n one  two &lt;NA&gt; \n   1    2    3\n00:57:25    Ryan Metcalf:   Excellent Trevin. You beat me to the output! Assuming we didn't supply the string, `NA` is entered instead.\n01:08:50    Ryan Metcalf:   Without further research, this is the \"Unix Epoch‚Äù. However, varying operating systems use different Epochs."
  },
  {
    "objectID": "videos/04/07.html",
    "href": "videos/04/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:40:18    Ryan Honomichl: What type of vector does each of the following calls to ifelse() return?\n* \"ifelse returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is TRUE or FALSE.\"\n00:42:11    Ryan Honomichl: \"I recommend assigning the results of an if statement only when the entire expression fits on one line; otherwise it tends to be hard to read\"\n00:42:46    Ryan Honomichl: * When you use the single argument form without an `else` statement, `if` invisibly returns NULL if the condition is FALSE. \n-   Since functions like c() and paste() drop NULL inputs, this allows for a compact expression of certain idioms\n00:54:15    collinberke:    https://docs.google.com/spreadsheets/d/1ScrbEw_-vB9DruaJhjtVY8HLQmuNPqyWeOOjmG6OY1M/edit?usp=sharing\n00:58:46    collinberke:    https://www.youtube.com/@safe4democracy/videos"
  },
  {
    "objectID": "videos/05/06.html",
    "href": "videos/05/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:16:34    Federica Gazzelloni:    https://github.com/r4ds/bookclub-Advanced_R\n00:22:28    Federica Gazzelloni:    https://stackoverflow.com/questions/50646133/dplyr-if-else-vs-base-r-ifelse\n00:26:20    Trevin: case_when() is great, makes it easy to read\n00:54:01    Trevin: out[I, ]\n00:54:14    Trevin: out[i, ]\n00:55:03    Trevin: I think you have to specify number of rows and columns before..\n00:55:30    Trevin: iterations = 10\n variables = 2\n output &lt;- matrix(ncol=variables, nrow=iterations)\n00:55:43    Trevin: https://stackoverflow.com/questions/13442461/populating-a-data-frame-in-r-in-a-loop"
  },
  {
    "objectID": "videos/06/07.html",
    "href": "videos/06/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:31:54    Ronald Legere:  https://en.wikipedia.org/wiki/First-class_function\n00:42:55    Ronald Legere:  https://en.wikipedia.org/wiki/Immediately_invoked_function_expression\n\n\n\nMeeting chat log\n\n00:54:02    Ron:    Book gives this simple example of when you might want to use prefix form of an infix operator: lapply(list(1:3, 4:5), `+`, 3)\n00:56:49    collinberke:    https://colinfay.me/playing-r-infix-functions/#:~:text=What%20are%20infix%20functions%3F,%2C%20%2B%20%2C%20and%20so%20on.\n01:07:36    Ron:    x[3] &lt;- 33\n01:07:51    Ron:    `[&lt;-`(x,3,value =33)"
  },
  {
    "objectID": "videos/07/06.html",
    "href": "videos/07/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:08:41    Arthur Shaw:    Hello, everyone!\n00:21:31    Federica Gazzelloni:    ?walk: Apply a function to each element of a list or atomic vector\n00:23:15    Federica Gazzelloni:    ?caller_env: Get properties of the current or caller frame\n00:24:56    Trevin: purrr::walk(x, function(x, ce, ace = rlang::caller_env()) {\n  .ce &lt;- rlang::caller_env()\n  message(\"Internal: \")\n  print(.ce)\n  message(\"Argument: \")\n  print(ace)\n  message(\"External: \")\n  print(ce)\n  message(\"Internal: \",paste0(ls(.ce), collapse = \"\\n\"))\n  message(\"Argument: \",paste0(ls(ace), collapse = \"\\n\"))\n  message(\"External: \",paste0(ls(ce), collapse = \"\\n\"))\n}, ce = rlang::caller_env())\n00:29:39    Federica Gazzelloni:    ??iwalk: Apply a function to each element of a vector, and its index\n00:35:30    Arthur Shaw:    https://magrittr.tidyverse.org/reference/tee.html\n00:36:05    Federica Gazzelloni:    ?`%T&gt;%`\n00:46:59    Trevin: ?eval\n01:06:03    Federica Gazzelloni:    https://cran.r-project.org/web/packages/withr/index.html\n01:09:21    Federica Gazzelloni:    https://github.com/r-lib/withr\n01:10:38    Trevin: I'm okay if we meet next week\n01:10:53    Oluwafemi Oyedele:  I am ok with next week"
  },
  {
    "objectID": "videos/08/07.html",
    "href": "videos/08/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:34:09    Ron:    Someone did: https://cran.r-project.org/web/packages/comprehenr/vignettes/Introduction.html\n00:47:58    collinberke:    https://purrr.tidyverse.org/reference/safely.html\n00:48:24    Ron:    it's a function operator !\n00:49:37    Ron:    \\(x) length(unique(x) is not too verbose though\n00:49:39    Ron:    ;)\n01:06:50    collinberke:    https://colinfay.me/purrr-mappers/\n01:07:45    collinberke:    https://colinfay.me/purrr-web-mining/"
  },
  {
    "objectID": "videos/09/06.html",
    "href": "videos/09/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:15:49    Matt Dupree:    did anyone else lose audio?\n00:15:59    Federica Gazzelloni:    not me\n00:16:02    Arthur Shaw:    Not me either\n00:16:04    Trevin: okay for me\n00:16:27    Matt Dupree:    gonna try rejoining\n00:43:14    Matt Dupree:    oh i didn't know they invisibly returned .x! That's useful!\n00:48:29    Arthur Shaw:    Very cool trick !"
  },
  {
    "objectID": "videos/11/06.html",
    "href": "videos/11/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:01:42    Oluwafemi Oyedele:  Hi, Good Evening !!!\n00:05:52    Arthur Shaw:    @federica, love the hex stickers behind you. All from rstudio::conf?\n00:07:12    Arthur Shaw:    I tried doing the same. I had a hard time ordering them. I also thought I'd make the stickers into magnets so that I could rearrange them in future.\n00:48:34    Oluwafemi Oyedele:  Thank you !!!"
  },
  {
    "objectID": "videos/12/07.html",
    "href": "videos/12/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:35:43    Stone: base::InternalMethods\n00:48:04    collinberke: https://cran.r-project.org/doc/manuals/R-exts.html"
  },
  {
    "objectID": "videos/13/06.html",
    "href": "videos/13/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:05:30    Oluwafemi Oyedele:  Hi everyone, Good Evening !!!\n00:09:44    Trevin: I agree Arthur, need to look at that package some more"
  },
  {
    "objectID": "videos/14/07.html",
    "href": "videos/14/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:06:57    Ron Legere: https://arxiv.org/abs/2303.12712\n00:07:07    Ron Legere: ^^ shows some of the power and limitations\n00:39:41    collinberke:    https://www.youtube.com/watch?v=3GEFd8rZQgY&list=WL&index=11\n00:49:20    iPhone: Sorry fellas need to jump early. See you next week!\n01:05:21    collinberke:    https://github.com/r4ds/bookclub-advr\n01:09:30    Ron Legere: makeActiveBinding"
  },
  {
    "objectID": "videos/17/06.html",
    "href": "videos/17/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:32:31    Oluwafemi Oyedele:  When should eval_tidy() be used instead of eval()?\nbase::eval() is sufficient for simple evaluation. Use eval_tidy() when you'd like to support expressions referring to the .data pronoun, or when you need to support quosures.\n00:37:08    Trevin (he/him):    https://rlang.r-lib.org/reference/topic-defuse.html\n00:38:38    Federica Gazzelloni:    https://rlang.r-lib.org/reference/eval_tidy.html\n00:39:57    Arthur Shaw:    Tidy eval book: https://bookdown.dongzhuoer.com/tidyverse/tidyeval/\n00:40:14    Arthur Shaw:    Also very useful resource: https://dplyr.tidyverse.org/articles/programming.html\n00:40:28    Trevin (he/him):    https://ggplot2.tidyverse.org/reference/aes.html\n00:40:37    Federica Gazzelloni:    https://ggplot2.tidyverse.org/reference/tidyeval.html\n00:41:22    Oluwafemi Oyedele:  It is Tidyverse design\n00:49:13    Federica Gazzelloni:    https://www.youtube.com/watch?v=2NixH3QAerQ&list=PL3x6DOfs2NGi9lH7q-phZlPrl6HKXYDbn&index=15\n00:50:13    Federica Gazzelloni:    Minute: 17:04\n00:54:03    Federica Gazzelloni:    con &lt;- DBI::dbConnect(RSQLite::SQLite(), filename = \":memory:\")\n00:54:18    Federica Gazzelloni:    DBI::dbDisconnect(con)"
  },
  {
    "objectID": "videos/18/07.html",
    "href": "videos/18/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:50:48    Stone:  https://www.r-bloggers.com/2018/10/quasiquotation-in-r-via-bquote/\n00:58:26    iPhone: See ya next week!"
  },
  {
    "objectID": "videos/19/06.html",
    "href": "videos/19/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n01:02:07    Trevin: Yeah, that was a great workshop\n01:02:18    Trevin: Glad they posted the resources online\n01:06:39    Trevin: Thank you!"
  },
  {
    "objectID": "videos/20/07.html",
    "href": "videos/20/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:55:22    collinberke:    https://rlang.r-lib.org/reference/embrace-operator.html?q=enquo#under-the-hood"
  },
  {
    "objectID": "videos/21/03.html",
    "href": "videos/21/03.html",
    "title": "Cohort 3",
    "section": "",
    "text": "(no video)"
  },
  {
    "objectID": "videos/22/06.html",
    "href": "videos/22/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:12:43    Trevin Flickinger:  Hello everyone!\n00:13:03    Oluwafemi Oyedele:  Hello, Good evening!!!\n00:22:10    Trevin Flickinger:  My connection is slow so I‚Äôll be in the chat\n00:32:45    Trevin Flickinger:  If you start with ‚Äúcontinue‚Äù it should error out after the first call\n00:56:18    Trevin Flickinger:  Sys.frame(-1) shows it goes back one frame\n00:59:55    fg: thanks\n01:03:11    Arthur Shaw:    Anyone else lose the presentation?\n01:03:20    fg: yes\n01:03:22    fg: ?\n01:04:26    Trevin Flickinger:  I thought that was my internet connection\n01:05:07    Trevin Flickinger:  Thank you!\n01:08:42    Trevin Flickinger:  I need to use debug( ) more as well\n01:10:15    Trevin Flickinger:  21st works for me\n01:10:29    Oluwafemi Oyedele:  Same here!!!"
  },
  {
    "objectID": "videos/24/06.html",
    "href": "videos/24/06.html",
    "title": "Cohort 6",
    "section": "",
    "text": "Meeting chat log\n\n00:24:42    Arthur Shaw:    I wonder if there's a task view for R Universe: https://r-universe.dev/search/\n01:01:13    Arthur Shaw:    https://www.alexejgossmann.com/benchmarking_r/\n01:04:34    Trevin: I agree that the chapter is a good jumping off point. Gonna have to dig into some of the listed resources üòÑ"
  },
  {
    "objectID": "videos/24/01.html",
    "href": "videos/24/01.html",
    "title": "Cohort 1",
    "section": "",
    "text": "(no video)"
  },
  {
    "objectID": "videos/25/07.html",
    "href": "videos/25/07.html",
    "title": "Cohort 7",
    "section": "",
    "text": "Meeting chat log\n\n00:43:02    Gus Lipkin: I think I found the definition for `mean`\nAn R call goes to *a which then calls the C function *b\n*a: https://github.com/wch/r-source/blob/trunk/src/library/base/R/mean.R\n*b: https://github.com/wch/r-source/blob/trunk/src/library/stats/src/cov.c#L207\nIt looks like the second pass only happens if `R_FINITE(mean_from_first_pass)` which tries to call `isfinite` from C++ and if it‚Äôs not there, it‚Äôll make sure it is a number and is not positive or negative infinity.\n00:49:55    Gus Lipkin: I feel bad for dropping in on the last chapter and getting Collin‚Äôs thanks üòÖ I wish I‚Äôd joined sooner."
  },
  {
    "objectID": "01.html",
    "href": "01.html",
    "title": "1. Introduction",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Getting Started",
      "1. Introduction"
    ]
  },
  {
    "objectID": "01.html#meeting-videos",
    "href": "01.html#meeting-videos",
    "title": "1. Introduction",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Getting Started",
      "1. Introduction"
    ]
  },
  {
    "objectID": "03.html",
    "href": "03.html",
    "title": "3. Vectors",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "3. Vectors"
    ]
  },
  {
    "objectID": "03.html#meeting-videos",
    "href": "03.html#meeting-videos",
    "title": "3. Vectors",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "3. Vectors"
    ]
  },
  {
    "objectID": "05.html",
    "href": "05.html",
    "title": "5. Control flow",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "5. Control flow"
    ]
  },
  {
    "objectID": "05.html#meeting-videos",
    "href": "05.html#meeting-videos",
    "title": "5. Control flow",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "5. Control flow"
    ]
  },
  {
    "objectID": "07.html",
    "href": "07.html",
    "title": "7. Environments",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Foundations",
      "7. Environments"
    ]
  },
  {
    "objectID": "07.html#meeting-videos",
    "href": "07.html#meeting-videos",
    "title": "7. Environments",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Foundations",
      "7. Environments"
    ]
  },
  {
    "objectID": "09.html",
    "href": "09.html",
    "title": "9. Functionals",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Functional programming",
      "9. Functionals"
    ]
  },
  {
    "objectID": "09.html#meeting-videos",
    "href": "09.html#meeting-videos",
    "title": "9. Functionals",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Functional programming",
      "9. Functionals"
    ]
  },
  {
    "objectID": "11.html",
    "href": "11.html",
    "title": "11. Function operators",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Functional programming",
      "11. Function operators"
    ]
  },
  {
    "objectID": "11.html#meeting-videos",
    "href": "11.html#meeting-videos",
    "title": "11. Function operators",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Functional programming",
      "11. Function operators"
    ]
  },
  {
    "objectID": "13.html",
    "href": "13.html",
    "title": "13. S3",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Object-oriented programming",
      "13. S3"
    ]
  },
  {
    "objectID": "13.html#meeting-videos",
    "href": "13.html#meeting-videos",
    "title": "13. S3",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Object-oriented programming",
      "13. S3"
    ]
  },
  {
    "objectID": "15.html",
    "href": "15.html",
    "title": "15. S4",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Object-oriented programming",
      "15. S4"
    ]
  },
  {
    "objectID": "15.html#meeting-videos",
    "href": "15.html#meeting-videos",
    "title": "15. S4",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Object-oriented programming",
      "15. S4"
    ]
  },
  {
    "objectID": "17.html",
    "href": "17.html",
    "title": "17. Metaprogramming big picture",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Metaprogramming",
      "17. Metaprogramming big picture"
    ]
  },
  {
    "objectID": "17.html#meeting-videos",
    "href": "17.html#meeting-videos",
    "title": "17. Metaprogramming big picture",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Metaprogramming",
      "17. Metaprogramming big picture"
    ]
  },
  {
    "objectID": "19.html",
    "href": "19.html",
    "title": "19. Quasiquotation",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Metaprogramming",
      "19. Quasiquotation"
    ]
  },
  {
    "objectID": "19.html#meeting-videos",
    "href": "19.html#meeting-videos",
    "title": "19. Quasiquotation",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Metaprogramming",
      "19. Quasiquotation"
    ]
  },
  {
    "objectID": "21.html",
    "href": "21.html",
    "title": "21. Translating R code",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Metaprogramming",
      "21. Translating R code"
    ]
  },
  {
    "objectID": "21.html#meeting-videos",
    "href": "21.html#meeting-videos",
    "title": "21. Translating R code",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Metaprogramming",
      "21. Translating R code"
    ]
  },
  {
    "objectID": "23.html",
    "href": "23.html",
    "title": "23. Measuring performance",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Techniques",
      "23. Measuring performance"
    ]
  },
  {
    "objectID": "23.html#meeting-videos",
    "href": "23.html#meeting-videos",
    "title": "23. Measuring performance",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Techniques",
      "23. Measuring performance"
    ]
  },
  {
    "objectID": "25.html",
    "href": "25.html",
    "title": "25. Rewriting R code in C++",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Techniques",
      "25. Rewriting R code in C++"
    ]
  },
  {
    "objectID": "25.html#meeting-videos",
    "href": "25.html#meeting-videos",
    "title": "25. Rewriting R code in C++",
    "section": "Meeting videos",
    "text": "Meeting videos\n\n\n\n\n\n\n\n\nCohort 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Techniques",
      "25. Rewriting R code in C++"
    ]
  }
]