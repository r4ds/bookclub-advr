---
engine: knitr
title: S3
---

# The S3 class is R's first and simplest functional OOP system in R

## Learning Objectives

1. Recognize S3 objects and classes.
2. Assign S3 classes to objects.
3. Create S3 generics and methods.
4. Implement advanced features of S3.

# What is an S3 object?

## We identify S3 objects by their attributes

An S3 object has atleast one attribute called 'class'.

```{r}
f <- factor(c("a", "b", "c"))
attributes(f)
```

## S3 classes provide an interface to a particular behavior

The `print` function is an S3 class that displays objects depending on the class attribute.

## 1. The `print` function is an S3 class

```{r}
sloop::ftype(print)
body(print)
sloop::s3_dispatch(print(f))
```

## `print` behaves or dispatches based on the object's class

```{r}
class(f)
print(f)
f_uc <- unclass(f)
class(f_uc)
print(f_uc)
```

## `body(print.factor)` shows the behavior for factors

```{r}
body(print.factor) #or sloop::s3_get_method("print.factor")
```

# How does one create an S3 class?

## Creating an S3 class means creating a new object with `structure`

```{r}
x <- structure(list(), class = "my_class")

x <- list()
class(x) <- "my_class"
attributes(x)
```

But currently, this is pretty useless...

## It is recommended that S3 classes be created with 3 functions

1. A **low-level constructor**, new_myclass(), that efficiently creates new objects with the correct structure.

2. A **validator**, validate_myclass(), that performs more computationally expensive checks to ensure that the object has correct values.

3. A **user-friendly helper**, myclass(), that provides a convenient way for others to create objects of your class.

## 1. The constructor creates your class appropriately

This super simple `factor` class inherits all the existing methods for this class.

```{r}
#| error: true
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

new_factor(1:3, c("a","b","c"))
```

## 2. The validator provides the checks  to ensure re-usability

```{r}
#| error: true
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
```

## 3. The helper provides a safer approach to create the object

```{r}
factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  new_factor(ind, levels) |> 
    validate_factor()
}

factor(c("a", "a", "b"))
```

## There are example S3 classes 'in the wild' using the recommended interface

-   `tibble::new_tibble`, `tibble::validate_tibble`, `tibble::tibble`

-   `dplyr::new_grouped_df`, `dplyr::validate_grouped_df`, `dplyr::grouped_df`

# How do S3 generics perform dispatching?

##  The function `summary` is a S3 class with a 'dispatching purpose'

```{r}
sloop::is_s3_generic("summary")

summary

sloop::s3_methods_generic(
  "summary"
) |> 
  knitr::kable()
```

## `summary` behaves differently given its input object's class

Polymorphism!

However, `summary` does not have a consistent output class.

::: {.panel-tabset}

### iris$Sepal.Length

```{r}
a <- iris$Sepal.Length
class(a)
(a_summary <- summary(a))
sloop::s3_class(a_summary)
```

### iris$Species

```{r}
b <- iris$Species
class(b)
(b_summary <- summary(b))
sloop::s3_class(b_summary)
```
:::

## The custom `summarizer` S3 generic summarizes different vectors

-   The goal is to summarize characters, factors, and numeric objects
-   The output should always be a length one character object

### There are two rules when creating a new S3 generic

1.   Only write a method if you own the generic. Otherwise, bad manners.
2.   Method must have same arguments as its generic--with one important exception: `...`

But this is just for demomstration purposes...

## The `summarizer` generic includes `UseMethod` for dispatching

```{r}
summarizer <- function(x, probs = c(0.25, 0.5, 0.75)) {
  UseMethod("summarizer")
}
```

:::{.callout-caution}
You donâ€™t pass any of the arguments of the generic to UseMethod(); it uses deep magic to pass to the method automatically. The precise process is complicated and frequently surprising, so you should avoid doing any computation in a generic. See `?UseMethod` for details.
:::

## `summarizer` outputs consistent summary strings

Don't need to worry about which to dispatch to - Encapsulation!

::: {.panel-tabset}

### Characters

```{r}
summarizer.character <- function(x, probs = c(0.25, 0.5, 0.75)) {
  tab <- sort(table(x), decreasing = TRUE)
  # Format as "value (n)"
  pairs <- paste0(names(tab), " (", tab, ")")
  paste(pairs, collapse = ", ")
}
```

### Numerics

```{r}
summarizer.numeric <- function(x, probs = c(0.25, 0.5, 0.75)) {
  # Remove NAs to avoid warnings
  x_no_na <- x[!is.na(x)]
  
  qs <- quantile(x_no_na, probs = probs, names = FALSE)
  names(qs) <- paste0("Q", seq_along(qs))

  stats <- c(
    Min = min(x_no_na),
    qs,
    Max = max(x_no_na)
  )
  
  paste0(
    paste(names(stats), format(stats), sep = ": ", collapse = ", ")
  )
}
```

### Factors

```{r}
summarizer.factor <- function(x, probs = c(0.25, 0.5, 0.75)) {
  # Just delegate to character method on the labels
  summarizer(as.character(x), probs = probs)
}
```

### Default

```{r}
summarizer.default <- function(x, probs = c(0.25, 0.5, 0.75)) {
  cls <- paste(class(x), collapse = ", ")
  paste0("No summarizer method for class: ", cls)
}
```

### Vector Examples

```{r}
summarizer(c("apple", "apple", "pear", "pear", "pear", "orange"))

summarizer(factor(c("a","b","b","a","c","c","c")))

summarizer(c(1,2,3,4,5,6,10))

summarizer(c(1,50,100,250), probs = c(.1, .9))

```

### Dataframe Example

```{r}
iris |> 
  vapply(
    summarizer,
    character(1)
  )

survival::lung |> 
  vapply(
    summarizer,
    character(1)
  )
```

:::

## If a `summarizer` generic doesn't exist for an object's class, it'll look at the next class

This is an example of *Inheritance*

```{r}
a <- iris$Species
summarizer(a)
(class(a) <- c("my_class",class(a)))
summarizer(a)

```

# What are advanced implementations of S3 classes?

## S3 classes can 'conceal' data elements from `length` for concise representation

-   Record style objects use a list of equal-length vectors to represent individual components of the object. 
-   The best example of this is POSIXlt, which underneath the hood is a list of 11 date-time components like year, month, and day. 
-   Record style classes override length() and subsetting methods to conceal this implementation detail.

```{r}
x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))
x

length(x)
length(unclass(x))

x[[1]] # the first date time
unclass(x)[[1]] # the first component, the number of seconds
```

## `NextMethod()`delegates dispatch behavior for classes without explicit generics

## Consider `secret` class that masks each character of the input with `x` in output

```{r}
new_secret <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "secret")
}

print.secret <- function(x, ...) {
  print(strrep("x", nchar(x)))
  invisible(x)
}

y <- new_secret(c(15, 1, 456))
y
```

## Without a `[` generic for the secret class, the behavior is unexpected

Notice that the `[` method is problematic in that it does not preserve the `secret` class.  Additionally, it returns `15` as the first element instead of `xx`.

```{r}
sloop::s3_dispatch(y[1])
y[1]
```

Fix this with a `[.secret` method:

## Inefficient `[` generic for the secret class

The first fix (not run) is inefficient because it creates a copy of `y`.

```{r eval = FALSE}
# not run
`[.secret` <- function(x, i) {
  x <- unclass(x)
  new_secret(x[i])
}
```

## Efficient `NextMethod()` for the secret class

-   Avoids copying and infinite loop

```{r}
`[.secret` <- function(x, i) {
  # first, dispatch to `[`
  # then, coerce subset value to `secret` class
  new_secret(NextMethod())
}
```

-   `[.secret` is selected, but delegates to internal `[`.
-   Makes secret object for that element alone

```{r}
sloop::s3_dispatch(y[1])
y[1]
```


## Allow subclassing to inherit 'heavy lifting'

::: {.panel-tabset}

### Include superclass

-   You should 'own' the superclass constructor

```{r}
new_secret <- function(x, ..., class = character()) {
  stopifnot(is.double(x))

  structure(
    x,
    ...,
    class = c(class, "secret")
  )
}
```

### Create subclass

-   Simply invoke the superclass constructor inside of the subclass constructor:

```{r}
new_supersecret <- function(x) {
  new_secret(x, class = "supersecret")
}

print.supersecret <- function(x, ...) {
  print(rep("xxxxx", length(x)))
  invisible(x)
}

x2 <- new_supersecret(c(15, 1, 456))
x2
```

### `vctrs::vec_restore`

- No way in base R to properly delegate methods in inheritance chain
- `vctrs::vec_restore` provides proper method chaining

```{r}
vec_restore.secret <- function(x, to, ...) new_secret(x)
vec_restore.supersecret <- function(x, to, ...) new_supersecret(x)
`[.secret` <- function(x, ...) {
  vctrs::vec_restore(NextMethod(), x)
}
x2[1:3]
```

:::
