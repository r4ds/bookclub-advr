---
engine: knitr
title: S3
---

# The S3 class is R's first and simplest OOP system in R

## Learning Objectives

1. What is an S3 object and class?
2. How to create an S3 class?
3. How to create S3 generic function?

# What is an S3 object?

## We identify S3 objects by their attributes

An S3 object has atleast one attribute called 'class'.

```{r}
f <- factor(c("a", "b", "c"))
attributes(f)
```

## S3 classes provide an interface to a particular behavior

The `print` function is an S3 class that displays objects depending on the class attribute.

## 1. The `print` function is an S3 class

```{r}
sloop::ftype(print)
body(print)
sloop::s3_dispatch(print(f))
```

## `print` behaves or dispatches based on the object's class

```{r}
class(f)
print(f)
f_uc <- unclass(f)
class(f_uc)
print(f_uc)
```

## `body(print.factor)` shows the behavior for factors

```{r}
body(print.factor) #or sloop::s3_get_method("print.factor")
```

# How does one create an S3 class?

## Creating an S3 class means creating a new object with `structure`

```{r}
x <- structure(list(), class = "my_class")

x <- list()
class(x) <- "my_class"
attributes(x)
```

But currently, this is pretty useless...

## It is recommended that S3 classes be created with 3 functions

1. A **low-level constructor**, new_myclass(), that efficiently creates new objects with the correct structure.

2. A **validator**, validate_myclass(), that performs more computationally expensive checks to ensure that the object has correct values.

3. A **user-friendly helper**, myclass(), that provides a convenient way for others to create objects of your class.

## 1. The constructor creates your class appropriately

This superc simple `factor` class inherits all the existing methods for this class.

```{r}
#| error: true
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

new_factor(1:5, "a")
new_factor(0:1, "a") #This errors
```

## 2. The validator provides the checks  to ensure re-usability

```{r}
#| error: true
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
```

## 3. The helper provides a safer approach to create the object

```{r}
factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  new_factor(ind, levels) |> 
    validate_factor()
}

factor(c("a", "a", "b"))
```

## There are example S3 classes 'in the wild' using the recommended interface

-   `tibble::new_tibble`, `tibble::validate_tibble`, `tibble::tibble`

-   `dplyr::new_grouped_df`, `dplyr::validate_grouped_df`, `dplyr::grouped_df`

# How do S3 generics perform dispatching?

##  The function `summary` is a S3 class with a 'dispatching purpose'

```{r}
sloop::is_s3_generic("summary")

sloop::s3_methods_generic(
  "summary"
) |> 
  knitr::kable()
```

## `summary` behaves differently given its input object's class

However, `summary` does not have a consistent output class.

::: {.panel-tabset}

### iris$Sepal.Length

```{r}
a <- iris$Sepal.Length
class(a)
(a_summary <- summary(a))
sloop::s3_class(a_summary)
```

### iris$Species

```{r}
b <- iris$Species
class(b)
(b_summary <- summary(b))
sloop::s3_class(b_summary)
```
:::

## The custom `summarizer` S3 generic summarizes different vectors

-   The goal is to summarize characters, factors, and numeric objects
-   The output should always be a length one character object

### There are two rules when creating a new S3 generic

1.   Only write a method if you own the generic. Otherwise, bad manners.
2.   Method must have same arguments as its generic--with one important exception: `...`

But this is just for demomstration purposes...

# Extra

## `NextMethod()`

Consider `secret` class that masks each character of the input with `x` in output

```{r}
new_secret <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "secret")
}

print.secret <- function(x, ...) {
  print(strrep("x", nchar(x)))
  invisible(x)
}

y <- new_secret(c(15, 1, 456))
y
```

Notice that the `[` method is problematic in that it does not preserve the `secret` class.  Additionally, it returns `15` as the first element instead of `xx`.

```{r}
sloop::s3_dispatch(y[1])
y[1]
```

Fix this with a `[.secret` method:

The first fix (not run) is inefficient because it creates a copy of `y`.

```{r eval = FALSE}
# not run
`[.secret` <- function(x, i) {
  x <- unclass(x)
  new_secret(x[i])
}
```

`NextMethod()` is more efficient.

```{r}
`[.secret` <- function(x, i) {
  # first, dispatch to `[`
  # then, coerce subset value to `secret` class
  new_secret(NextMethod())
}
```

Notice that `[.secret` is selected for dispatch, but that the method delegates to the internal `[`.

```{r}
sloop::s3_dispatch(y[1])
y[1]
```


## Allowing subclassing

Continue the example above to have a `supersecret` subclass that hides even the number of characters in the input (e.g., `123` -> `xxxxx`, 12345678 -> `xxxxx`, 1 -> `xxxxx`).

To allow for this subclass, the constructor function needs to include two additional arguments:

- `...` for passing an arbitrary set of arguments to different subclasses
- `class` for defining the subclass

```{r}
new_secret <- function(x, ..., class = character()) {
  stopifnot(is.double(x))

  structure(
    x,
    ...,
    class = c(class, "secret")
  )
}
```

To create the subclass, simply invoke the parent class constructor inside of the subclass constructor:

```{r}
new_supersecret <- function(x) {
  new_secret(x, class = "supersecret")
}

print.supersecret <- function(x, ...) {
  print(rep("xxxxx", length(x)))
  invisible(x)
}
```

But this means the subclass inherits all parent methods and needs to overwrite all parent methods with subclass methods that return the sublclass rather than the parent class.

There's no easy solution to this problem in base R.

There is a solution in the vectors package: `vctrs::vec_restore()`

<!-- TODO: read docs/vignettes to be able to summarize how this works -->
