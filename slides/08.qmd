---
engine: knitr
title: Conditions
---

## Chapter 8 learning objectives

- What conditions are
- How to generate ("signal") them
- How to consume ("handle") them

## R's condition system allows us to handle things going wrong

An error might occur due to events outside of your program---a missing file, a
full disk, a crashed server, etc.

"Errors aren't caused by bugs, but neglecting to handle an error is almost
certainly a bug." ---Seibel (2003)

Conditions help us maintain the illusion of "black box" functions.

## There are three types of conditions

1. `r emoji::emoji("x")` Errors
2. `r emoji::emoji("warning")` Warnings
3. `r emoji::emoji("speech_balloon")` Messages

Function authors _signal_ conditions

Function users _handle_ conditions

# Signaling conditions

## Errors indicate that a problem occurred and the function cannot continue

```{r}
#| label: errors-halt-immediately
#| error: true
f <- function() {
  cat("starting f()\n")
  g()
  cat("finishing f()\n")
}

g <- function() {
  cat("starting g()\n")
  stop("This is an error!")
  cat("finishing g()\n")
}

f()
```

::: {.notes}
Errors halt execution immediately

By default the function that raised the error is prepended to the message
:::

## Pass objects to `stop()` to print error messages

- `stop(...)` can accept zero or more objects
  - If the first object is not a condition object[^objs], its arguments are
    converted to `character` and pasted together with no separator

- Pass `call. = FALSE` to prevent the function that raised the error from being
  added to the message

- `rlang::abort()` signals errors with a different interface

[^objs]: _Condition objects_ will be described later

## Tracebacks display the call stack at the time of the last error

```{r}
#| label: traceback-example
#| eval: false
f()
traceback()
```

    #> 4: stop("This is an error!") at #2
    #> 2: g() at #3
    #> 1: f()

This is one reason to prefer `stop(..., call. = FALSE)`

## `rlang::last_trace()` has prettier printing

```{r}
#| label: lasttrace-example
#| eval: false
f()
rlang::last_trace()
```

    #> <error/rlang_error>
    #> Error in `g()`:
    #> ! This is an error!
    #> ---
    #> Backtrace:
    #>     ▆
    #>  1. └─global f()
    #>  2.   └─global g()
    #> Run rlang::last_trace(drop = FALSE) to see 1 hidden frame.

## Warnings indicate that a problem occurred but the function can continue

<!---
I'm using eval = false and embedding the output myself because Quarto displays
warnings immediately unlike the R console (with `options(warn = 0)`)
-->

```{r}
#| label: warning-example
#| eval: false
f <- function() {
  warning("F1")
  g()
  warning("F2")
  cat("finishing f()\n")
}

g <- function() {
  warning("G1")
  cat("finishing g()\n")
}

f()
```

    #> finishing g()
    #> finishing f()
    #> Warning messages:
    #> 1: In f() : F1
    #> 2: In g() : G1
    #> 3: In f() : F2

::: {.notes}
By default warnings are cached and printed when control returns to the top
level, as shown here (use `options(warn = 0)` to get this behavior)

Warnings can appear immediately with `options(warn = 1)`

Warnings can turn into errors with `options(warn = 2)`, which is ideal for
debugging
:::

## Use warnings sparingly

- Ideal for deprecating functions
- Good when "you are reasonably certain" that a problem is recoverable
- "Base R tends to overuse warnings, and many warnings in base R would be
  better off as errors"

::: aside
`warning()` has similar arguments to `stop()`

`call. = TRUE` is generally more useful with `warning()` than `stop()`

`rlang::warn()` is an alternative (cf. `rlang::abort()`)
:::

## Messages indicate that something noteworthy has happened

```{r}
#| label: message-example
#| message: true
f <- function() {
  message("F1")
  g()
  message("F2")
  cat("finishing f()\n")
}

g <- function() {
  message("G1")
  cat("finishing g()\n")
}

f()
```

## Recommended uses for messages

- Explaining default arguments
- Status updates of functions used primarily for side-effects
  - Interaction with web API, file downloaded, etc.
- Progress of long-running process
  - But see `utils::txtProgressBar()` and others
- Package loading message (e.g., attaching package, objects masked)

::: aside
See `rlang::inform()` for an alternative interface
:::

# Handling conditions

## Ignore errors with `try()`

::: {.notes}
- Displays error
- But continues execution after error
:::

```{r}
#| label: try-example
#| error: true
bad_log <- function(x) {
  try(log(x))
  10
}

bad_log("bad")
```

## `try()` with assignment can support default values in case of failure

```{r}
#| label: try-with-assignment
file_contents <- NULL
try(file_contents <- read.csv("possibly-bad-input.csv"), silent = TRUE)
is.null(file_contents)
```

## Warnings and messages can be independently suppressed

<!---
I'm turning off evaluation and manually pasting the results again because I
want to make the formatting match
-->

```{r}
#| label: suppresswarnings-example
#| eval: false
chatty_function <- function() {
  warning("warning 1")
  message("message 1")
  warning("warning 2")
  message("message 2")
  42
}

suppressWarnings(chatty_function())
```

    #> message 1
    #> message 2
    #> [1] 42

```{r}
#| label: suppressmessages-example
#| eval: false
suppressMessages(chatty_function())
```

    #> [1] 42
    #> Warning messages:
    #> 1: In chatty_function() : warning 1
    #> 2: In chatty_function() : warning 2

## Every condition has a default behavior

- `r emoji::emoji("x")` Errors halt execution
- `r emoji::emoji("warning")` Warnings are collected during execution and
  displayed in bulk after execution
- `r emoji::emoji("speech_balloon")` Messages are displayed immediately

These can be changed through _exiting_ and _calling_ handlers

## `tryCatch()` specifies or modifies exiting handlers

```{r}
#| label: trycatch-no-error
#| error: true
exp_log <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    {
      y <- log(x)
      cat("Reconstituting 'x'\n")
      exp(y)
    }
  )
}

exp_log(23)
```

```{r}
#| label: trycatch-with-error
#| error: true
exp_log("x")
```

::: {.notes}
Notice that, unlike with `try()`, the function still stops  
(the next slide has more detail)
:::

## Exiting handlers never return control to the original code

```{r}
#| label: trycatch-catching-messages
tryCatch(
  message = function(cnd) {
    cat("Caught a message condition:", conditionMessage(cnd))
    "The return value of the message handler"
  },
  {
    message("This is a message")
    cat("This code won't be run inside 'tryCatch()' if messages are caught\n")
    "The return value of the original expression"
  },
  finally = {
    cat("The code in 'finally' is always run\n")
  }
)
```

::: {.notes}
This snippet illustrates a few things about `tryCatch()`:
- exiting handlers can be established for exceptions other than errors
- The use of `finally`
- And, like it says in the title, the original code exits and doesn't resume
:::

## `withCallingHandlers()` specifies or modifies calling handlers

```{r}
#| label: withcallinghandlers-example
withCallingHandlers(
  message = function(cnd) {
    cat("Caught a message condition:", conditionMessage(cnd))
    "The return value of the message handler is ignored"
  },
  {
    message("This is a message")
    cat("This code should run\n")
    message("This is another message")
    "The return value of the original expression"
  }
  # No finally option
)
```

## Conditions "bubble up" to other calling handlers by default

```{r}
#| label: withcallinghandlers-propagation
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    {
      message("Hello")
      cat("Finishing code block\n")
    }
  )
)
```

## Conditions also bubble up to `tryCatch()`

```{r}
#| label: withcallinghandlers-propagation-to-trycatch
tryCatch(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    {
      message("Hello")
      cat("This exiting handler prevents this from running\n")
    }
  )
)
```

## `rlang::cnd_muffle()` will stop the propagation to calling handlers "higher up"

```{r}
#| label: withcallinghandlers-muffled
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) {
      cat("Level 1\n")
      rlang::cnd_muffle(cnd)
    },
    message("Hello")
  )
)
```

## Calling handlers are called in the context of the call that signaled the condition

```{r}
#| label: withcallinghandlers-call-stack
f <- function() g()
g <- function() message("hello")

withCallingHandlers(f(), message = function(cnd) {
  lobstr::cst()
  rlang::cnd_muffle(cnd)
})
```

## Exiting handlers are called in the context of the call to `tryCatch()`

```{r}
#| label: trycatch-call-stack
tryCatch(f(), message = function(cnd) lobstr::cst())
```

# Condition objects

## Built-in conditions are lists with two elements

```{r}
#| label: cond-str
cnd <- rlang::catch_cnd(stop("An error!"))
str(cnd)
```

- `message` can be accessed with `conditionMessage(cnd)`
- `call` is not generally useful
- The `class` attribute will be explained alongside S3

## Custom conditions can introduce additional attributes

```{r}
#| label: rlang-cond-str
cnd <- rlang::catch_cnd(rlang::abort("An error!"))
str(cnd)
```

## `rlang::abort()` can compose and throw custom conditions

We create a function that will signal an error condition

```{r}
#| label: rlang-abort-custom-condition
#| error: true
abort_missing_file <- function(file_path) {
  rlang::abort(
    "error_not_found",
    message = glue::glue("Path `{file_path}` not found"),
    path = file_path
  )
}
abort_missing_file("blah.csv")
```

This makes it easy to format messages

::: aside
`rlang::abort()` doesn't format messages like `stop()` does
:::

## Deal with custom conditions by creating specific handlers

```{r}
#| label: use-custom-condition
my_csv_reader <- function(file) {
  if (!file.exists(file)) abort_missing_file(file)
  read.csv(file)
}

dat <- tryCatch(
  error_not_found = function(cnd) data.frame(),
  error = function(cnd) NULL,
  my_csv_reader("blah.csv")
)

dat
```

::: aside
The first matching handler is chosen, not the "most specific"
:::

::: {.notes}
If we were writing all of the code ourselves, we'd probably put this behavior
in `my_csv_reader()` ourselves.

Custom conditions' strength relates to the principle of "separation of
concerns": the decision about what constitutes an error belongs to the function
author, and the decision of how to handle an error belongs to the function
user. This is especially useful for authors and users of packages.
:::

## Applications

See [the sub-section in the
book](https://adv-r.hadley.nz/conditions.html#condition-applications) for
more excellent examples.

## Resources

- Conditions articles in rlang vignettes: 
  - [Including function calls in error
    messages](https://rlang.r-lib.org/reference/topic-error-call.html)
  - [Including contextual information with error
    chains](https://rlang.r-lib.org/reference/topic-error-chaining.html)
  - [Formatting messages with
    cli](https://rlang.r-lib.org/reference/topic-condition-formatting.html)
- [Other
  resources](https://github.com/rstudio-conf-2022/pkg-dev-masterclass/blob/main/materials/5-error-resources.md)
from error message segment of rstudio::conf(2022) workshop "Package Development
Masterclass"
  - [Error messages](https://style.tidyverse.org/errors.html) from the
    Tidyverse style guide
