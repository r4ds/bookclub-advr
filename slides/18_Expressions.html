<!DOCTYPE html>
<html lang="en"><head>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-2fef5ea3f8957b3e4ecc936fc74692ca.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.7.32">

  <title>Advanced R Book Club – expressions</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-5fa723a4ee799f64e44b6fe0747a0a63.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-dark">
  <div class="reveal">
    <div class="slides">


<section>
<section id="expressions" class="title-slide slide level1 center">
<h1>Expressions</h1>
<p><strong>Learning objectives:</strong></p>
<ul>
<li>Understand the idea of the abstract syntax tree (AST).</li>
<li>Discuss the data structures that underlie the AST:
<ul>
<li>Constants</li>
<li>Symbols</li>
<li>Calls</li>
</ul></li>
<li>Explore the idea behind parsing.</li>
<li>Explore some details of R’s grammar.</li>
<li>Discuss the use or recursive functions to compute on the language.</li>
<li>Work with three other more specialized data structures:
<ul>
<li>Pairlists</li>
<li>Missing arguments</li>
<li>Expression vectors</li>
</ul></li>
</ul>
</section>
<section id="introduction" class="slide level2">
<h2>Introduction</h2>
<blockquote>
<p>To compute on the language, we first need to understand its structure.</p>
</blockquote>
<ul>
<li>This requires a few things:
<ul>
<li>New vocabulary.</li>
<li>New tools to inspect and modify expressions.</li>
<li>Approach the use of the language with new ways of thinking.</li>
</ul></li>
<li>One of the first new ways of thinking is the distinction between an operation and its result.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-error">
<pre><code>#&gt; Error: object 'x' not found</code></pre>
</div>
</div>
<ul>
<li>We can capture the intent of the code without executing it using the rlang package.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; y &lt;- x * 10</code></pre>
</div>
</div>
<ul>
<li>We can then evaluate the expression using the <strong>base::eval</strong> function.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 40</code></pre>
</div>
</div>
<h3 id="evaluating-multiple-expressions">Evaluating multiple expressions</h3>
<ul>
<li><p>The function <code>expression()</code> allows for multiple expressions, and in some ways it acts similarly to the way files are <code>source()</code>d in. That is, we <code>eval()</code>uate all of the expressions at once.</p></li>
<li><p><code>expression()</code> returns a vector and can be passed to <code>eval()</code>.</p></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 40</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li><code>exprs()</code> does not evaluate everything at once. To evaluate each expression, the individual expressions must be evaluated in a loop.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x &lt;- 4
#&gt; [1] 4
#&gt; x * 10
#&gt; [1] 40</code></pre>
</div>
</div>
</section>
<section id="abstract-syntax-tree-ast" class="slide level2">
<h2>Abstract Syntax Tree (AST)</h2>
<ul>
<li>Expressions are objects that capture the structure of code without evaluating it.</li>
<li>Expressions are also called abstract syntax trees (ASTs) because the structure of code is hierarchical and can be naturally represented as a tree.</li>
<li>Understanding this tree structure is crucial for inspecting and modifying expressions.
<ul>
<li>Branches = Calls</li>
<li>Leaves = Symbols and constants</li>
</ul></li>
</ul>
<p><img data-src="images/simple.png"></p>
<h3 id="with-lobstrast">With <code>lobstr::ast():</code></h3>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─f 
#&gt; ├─x 
#&gt; ├─"y" 
#&gt; └─1</code></pre>
</div>
</div>
<ul>
<li>Some functions might also contain more calls like the example below:</li>
</ul>
<p><img data-src="images/complicated.png"></p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─f 
#&gt; ├─█─g 
#&gt; │ ├─1 
#&gt; │ └─2 
#&gt; └─█─h 
#&gt;   ├─3 
#&gt;   ├─4 
#&gt;   └─█─i</code></pre>
</div>
</div>
<ul>
<li>Read the <strong>hand-drawn diagrams</strong> from left-to-right (ignoring vertical position)</li>
<li>Read the <strong>lobstr-drawn diagrams</strong> from top-to-bottom (ignoring horizontal position).</li>
<li>The depth within the tree is determined by the nesting of function calls.</li>
<li>Depth also determines evaluation order, <strong>as evaluation generally proceeds from deepest-to-shallowest, but this is not guaranteed because of lazy evaluation</strong>.</li>
</ul>
<h3 id="infix-calls">Infix calls</h3>
<blockquote>
<p>Every call in R can be written in tree form because any call can be written in prefix form.</p>
</blockquote>
<p>An infix operator is a function where the function name is placed between its arguments. Prefix form is when then function name comes before the arguments, which are enclosed in parentheses. [Note that the name infix comes from the words prefix and suffix.]</p>
<ul>
<li>A characteristic of the language is that infix functions can always be written as prefix functions; therefore, all function calls can be represented using an AST.</li>
</ul>
<p><img data-src="images/prefix.png"></p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`&lt;-` 
#&gt; ├─y 
#&gt; └─█─`*` 
#&gt;   ├─x 
#&gt;   └─10</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`&lt;-` 
#&gt; ├─y 
#&gt; └─█─`*` 
#&gt;   ├─x 
#&gt;   └─10</code></pre>
</div>
</div>
<ul>
<li>There is no difference between the ASTs for the infix version vs the prefix version, and if you generate an expression with prefix calls, R will still print it in infix form:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; y &lt;- x * 10</code></pre>
</div>
</div>
</section>
<section id="expression" class="slide level2">
<h2>Expression</h2>
<ul>
<li>Collectively, the data structures present in the AST are called expressions.</li>
<li>These include:
<ol type="1">
<li>Constants</li>
<li>Symbols</li>
<li>Calls</li>
<li>Pairlists</li>
</ol></li>
</ul>
<h3 id="constants">Constants</h3>
<ul>
<li>Scalar constants are the simplest component of the AST.</li>
<li>A constant is either <strong>NULL</strong> or a <strong>length-1</strong> atomic vector (or scalar)
<ul>
<li>e.g., <code>TRUE</code>, <code>1L</code>, <code>2.5</code>, <code>"x"</code>, or <code>"hello"</code>.</li>
</ul></li>
<li>We can test for a constant with <code>rlang::is_syntactic_literal()</code>.</li>
<li>Constants are self-quoting in the sense that the expression used to represent a constant is the same constant:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<h3 id="symbols">Symbols</h3>
<ul>
<li>A symbol represents the name of an object.
<ul>
<li><code>x</code></li>
<li><code>mtcars</code></li>
<li><code>mean</code></li>
</ul></li>
<li>In base R, the terms symbol and name are used interchangeably (i.e., <code>is.name()</code> is identical to <code>is.symbol()</code>), but this book used symbol consistently because <strong>“name”</strong> has many other meanings.</li>
<li>You can create a symbol in two ways:
<ol type="1">
<li>by capturing code that references an object with <code>expr()</code>.</li>
<li>turning a string into a symbol with <code>rlang::sym()</code>.</li>
</ol></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x</code></pre>
</div>
</div>
<ul>
<li>A symbol can be turned back into a string with <code>as.character()</code> or <code>rlang::as_string()</code>.</li>
<li><code>as_string()</code> has the advantage of clearly signalling that you’ll get a character vector of length 1.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "x"</code></pre>
</div>
</div>
<ul>
<li>We can recognize a symbol because it is printed without quotes</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x</code></pre>
</div>
</div>
<ul>
<li><code>str()</code> tells you that it is a symbol, and <code>is.symbol()</code> is TRUE:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt;  symbol x</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li>The symbol type is not vectorised, i.e., a symbol is always length 1.</li>
<li>If you want multiple symbols, you’ll need to put them in a list, using <code>rlang::syms()</code>.</li>
</ul>
<p>Note that <code>as_string()</code> will not work on expressions which are not symbols.</p>
<div class="cell">
<div class="cell-output cell-output-error">
<pre><code>#&gt; Error in `as_string()`:
#&gt; ! Can't convert a call to a string.</code></pre>
</div>
</div>
<h3 id="calls">Calls</h3>
<ul>
<li>A call object represents a captured function call.</li>
<li>Call objects are a special type of list.
<ul>
<li>The first component specifies the function to call (usually a symbol, i.e., the name fo the function).</li>
<li>The remaining elements are the arguments for that call.</li>
</ul></li>
<li>Call objects create branches in the AST, because calls can be nested inside other calls.</li>
<li>You can identify a call object when printed because it looks just like a function call.</li>
<li>Confusingly <code>typeof()</code> and <code>str()</code> print language for call objects (where we might expect it to return that it is a “call” object), but <code>is.call()</code> returns TRUE:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─read.table 
#&gt; ├─"important.csv" 
#&gt; └─row.names = FALSE</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "language"</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<h3 id="subsetting">Subsetting</h3>
<ul>
<li>Calls generally behave like lists.</li>
<li>Since they are list-like, you can use standard subsetting tools.</li>
<li>The first element of the call object is the function to call, which is usually a symbol:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; read.table</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li>The remainder of the elements are the arguments:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [[1]]
#&gt; [1] "important.csv"
#&gt; 
#&gt; $row.names
#&gt; [1] FALSE</code></pre>
</div>
</div>
<ul>
<li>We can extract individual arguments with [[ or, if named, $:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "important.csv"</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
</div>
<ul>
<li>We can determine the number of arguments in a call object by subtracting 1 from its length:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 2</code></pre>
</div>
</div>
<ul>
<li>Extracting specific arguments from calls is challenging because of R’s flexible rules for argument matching:
<ul>
<li>It could potentially be in any location, with the full name, with an abbreviated name, or with no name.</li>
</ul></li>
<li>To work around this problem, you can use <code>rlang::call_standardise()</code> which standardizes all arguments to use the full name:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; read.table(file = "important.csv", row.names = FALSE)</code></pre>
</div>
</div>
<ul>
<li>But If the function uses … it’s not possible to standardise all arguments.</li>
<li>Calls can be modified in the same way as lists:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; read.table("important.csv", row.names = FALSE, header = TRUE)</code></pre>
</div>
</div>
<h3 id="function-position">Function position</h3>
<ul>
<li>The first element of the call object is the function position. This contains the function that will be called when the object is evaluated, and is usually a symbol.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─foo</code></pre>
</div>
</div>
<ul>
<li>While R allows you to surround the name of the function with quotes, the parser converts it to a symbol:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─foo</code></pre>
</div>
</div>
<ul>
<li>However, sometimes the function doesn’t exist in the current environment and you need to do some computation to retrieve it:
<ul>
<li>For example, if the function is in another package, is a method of an R6 object, or is created by a function factory. In this case, the function position will be occupied by another call:</li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─█─`::` 
#&gt; │ ├─pkg 
#&gt; │ └─foo 
#&gt; └─1</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─█─`$` 
#&gt; │ ├─obj 
#&gt; │ └─foo 
#&gt; └─1</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─█─foo 
#&gt; │ └─1 
#&gt; └─2</code></pre>
</div>
</div>

<img data-src="images/call-call.png" class="r-stretch"><h3 id="constructing">Constructing</h3>
<ul>
<li>You can construct a call object from its components using <code>rlang::call2()</code>.</li>
<li>The first argument is the name of the function to call (either as a string, a symbol, or another call).</li>
<li>The remaining arguments will be passed along to the call:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; mean(x = x, na.rm = TRUE)</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; base::mean(x = x, na.rm = TRUE)</code></pre>
</div>
</div>
<ul>
<li>Infix calls created in this way still print as usual.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x &lt;- 10</code></pre>
</div>
</div>
</section>
<section id="parsing-and-grammar" class="slide level2">
<h2>Parsing and grammar</h2>
<ul>
<li><strong>Parsing</strong> - The process by which a computer language takes a string and constructs an expression. Parsing is governed by a set of rules known as a grammar.</li>
<li>We are going to use <code>lobstr::ast()</code> to explore some of the details of R’s grammar, and then show how you can transform back and forth between expressions and strings.</li>
<li><strong>Operator precedence</strong> - Conventions used by the programming language to resolve ambiguity.</li>
<li>Infix functions introduce two sources of ambiguity.</li>
<li>The first source of ambiguity arises from infix functions: what does 1 + 2 * 3 yield? Do you get 9 (i.e., (1 + 2) * 3), or 7 (i.e., 1 + (2 * 3))? In other words, which of the two possible parse trees below does R use?</li>
</ul>

<img data-src="images/ambig-order.png" class="r-stretch"><ul>
<li>Programming languages use conventions called operator precedence to resolve this ambiguity. We can use <code>ast()</code> to see what R does:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`+` 
#&gt; ├─1 
#&gt; └─█─`*` 
#&gt;   ├─2 
#&gt;   └─3</code></pre>
</div>
</div>
<ul>
<li>PEMDAS (or BEDMAS or BODMAS, depending on where in the world you grew up) is pretty clear on what to do. Other operator precedence isn’t as clear.</li>
<li>There’s one particularly surprising case in R:
<ul>
<li>! has a much lower precedence (i.e., it binds less tightly) than you might expect.</li>
<li>This allows you to write useful operations like:</li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`!` 
#&gt; └─█─`%in%` 
#&gt;   ├─x 
#&gt;   └─y</code></pre>
</div>
</div>
<ul>
<li><strong>R has over 30 infix operators divided into 18 precedence</strong> groups.</li>
<li>While the details are described in <code>?Syntax</code>, very few people have memorized the complete ordering.</li>
<li>If there’s any confusion, use parentheses!</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`*` 
#&gt; ├─█─`(` 
#&gt; │ └─█─`+` 
#&gt; │   ├─1 
#&gt; │   └─2 
#&gt; └─3</code></pre>
</div>
</div>
<h3 id="associativity">Associativity</h3>
<ul>
<li>The second source of ambiguity is introduced by repeated usage of the same infix function.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 6</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 6</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 6</code></pre>
</div>
</div>
<ul>
<li><p>In this case it doesn’t matter. Other places it might, like in <code>ggplot2</code>.</p></li>
<li><p>In R, most operators are left-associative, i.e., the operations on the left are evaluated first:</p></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`+` 
#&gt; ├─█─`+` 
#&gt; │ ├─1 
#&gt; │ └─2 
#&gt; └─3</code></pre>
</div>
</div>
<ul>
<li>There are two exceptions to the left-associative rule:
<ol type="1">
<li>exponentiation</li>
<li>assignment</li>
</ol></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`^` 
#&gt; ├─2 
#&gt; └─█─`^` 
#&gt;   ├─2 
#&gt;   └─3</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`&lt;-` 
#&gt; ├─x 
#&gt; └─█─`&lt;-` 
#&gt;   ├─y 
#&gt;   └─z</code></pre>
</div>
</div>
<h3 id="parsing-and-deparsing">Parsing and deparsing</h3>
<ul>
<li>Parsing - turning characters you’ve typed into an AST (i.e., from strings to expressions).</li>
<li>R usually takes care of parsing code for us.</li>
<li>But occasionally you have code stored as a string, and you want to parse it yourself.</li>
<li>You can do so using <code>rlang::parse_expr()</code>:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "y &lt;- x + 10"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; y &lt;- x + 10</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li><code>parse_expr()</code> always returns a single expression.</li>
<li>If you have multiple expression separated by <code>;</code> or <code>,</code>, you’ll need to use <code>rlang::parse_exprs()</code> which is the plural version of <code>rlang::parse_expr()</code>. It returns a list of expressions:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [[1]]
#&gt; a &lt;- 1
#&gt; 
#&gt; [[2]]
#&gt; a + 1</code></pre>
</div>
</div>
<ul>
<li>If you find yourself parsing strings into expressions often, <strong>quasiquotation</strong> may be a safer approach.
<ul>
<li>More about quasiquaotation in Chapter 19.</li>
</ul></li>
<li>The inverse of parsing is deparsing.</li>
<li><strong>Deparsing</strong> - given an expression, you want the string that would generate it.</li>
<li>Deparsing happens automatically when you print an expression.</li>
<li>You can get the string with <code>rlang::expr_text()</code>:</li>
<li>Parsing and deparsing are not symmetric.
<ul>
<li>Parsing creates the AST which means that we lose backticks around ordinary names, comments, and whitespace.</li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; {
#&gt;     x &lt;- x + 1
#&gt; }</code></pre>
</div>
</div>
</section>
<section id="using-the-ast-to-solve-more-complicated-problems" class="slide level2">
<h2>Using the AST to solve more complicated problems</h2>
<ul>
<li>Here we focus on what we learned to perform recursion on the AST.</li>
<li>Two parts of a recursive function:
<ul>
<li>Recursive case: handles the nodes in the tree. Typically, you’ll do something to each child of a node, usually calling the recursive function again, and then combine the results back together again. For expressions, you’ll need to handle calls and pairlists (function arguments).</li>
<li>Base case: handles the leaves of the tree. The base cases ensure that the function eventually terminates, by solving the simplest cases directly. For expressions, you need to handle symbols and constants in the base case.</li>
</ul></li>
</ul>
<h3 id="two-helper-functions">Two helper functions</h3>
<ul>
<li>First, we need an <code>epxr_type()</code> function to return the type of expression element as a string.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "constant"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "symbol"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "call"</code></pre>
</div>
</div>
<ul>
<li>Second, we need a wrapper function to handle exceptions.</li>
</ul>
<ul>
<li>Lastly, we can write a basic template that walks the AST using the <code>switch()</code> statement.</li>
</ul>
<h3 id="specific-use-cases-for-recurse_call">Specific use cases for <code>recurse_call()</code></h3>
<h3 id="example-1-finding-f-and-t">Example 1: Finding F and T</h3>
<ul>
<li>Using <code>F</code> and <code>T</code> in our code rather than <code>FALSE</code> and <code>TRUE</code> is bad practice.</li>
<li>Say we want to walk the AST to find times when we use <code>F</code> and <code>T</code>.</li>
<li>Start off by finding the type of <code>T</code> vs <code>TRUE</code>.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "constant"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "symbol"</code></pre>
</div>
</div>
<ul>
<li>With this knowledge, we can now write the base cases of our recursive function.</li>
<li>The logic is as follows:
<ul>
<li>A constant is never a logical abbreviation and a symbol is an abbreviation if it is “F” or “T”:</li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li>It’s best practice to write another wrapper, assuming every input you receive will be an expression.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] FALSE</code></pre>
</div>
</div>
<h4 id="next-step-code-for-the-recursive-cases">Next step: code for the recursive cases</h4>
<ul>
<li>Here we want to do the same thing for calls and for pairlists.</li>
<li>Here’s the logic: recursively apply the function to each subcomponent, and return <code>TRUE</code> if any subcomponent contains a logical abbreviation.</li>
<li>This is simplified by using the <code>purrr::some()</code> function, which iterates over a list and returns <code>TRUE</code> if the predicate function is true for any element.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<h3 id="example-2-finding-all-variables-created-by-assignment">Example 2: Finding all variables created by assignment</h3>
<ul>
<li>Listing all the variables is a little more complicated.</li>
<li>Figure out what assignment looks like based on the AST.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; █─`&lt;-` 
#&gt; ├─x 
#&gt; └─10</code></pre>
</div>
</div>
<ul>
<li>Now we need to decide what data structure we’re going to use for the results.
<ul>
<li>Easiest thing will be to return a character vector.</li>
<li>We would need to use a list if we wanted to return symbols.</li>
</ul></li>
</ul>
<h3 id="dealing-with-the-base-cases">Dealing with the base cases</h3>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; character(0)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; character(0)</code></pre>
</div>
</div>
<h3 id="dealing-with-the-recursive-cases">Dealing with the recursive cases</h3>
<ul>
<li>Here is the function to flatten pairlists.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "a" "b" "b" "b" "c" "c"</code></pre>
</div>
</div>
<ul>
<li>Here is the code needed to identify calls.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "a"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "a" "b"</code></pre>
</div>
</div>
<h3 id="make-the-function-more-robust">Make the function more robust</h3>
<ul>
<li>Throw cases at it that we think might break the function.</li>
<li>Write a function to handle these cases.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "a" "b" "c"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "x" "y"</code></pre>
</div>
</div>
<ul>
<li>This approach certainly is more complicated, but it’s important to start simple and move up.</li>
</ul>
</section>
<section id="specialised-data-structures" class="slide level2">
<h2>Specialised data structures</h2>
<ul>
<li>Pairlists</li>
<li>Missing arguments</li>
<li>Expression vectors</li>
</ul>
<h3 id="pairlists">Pairlists</h3>
<ul>
<li>Pairlists are a remnant of R’s past and have been replaced by lists almost everywhere.</li>
<li>The only place you are likely to see pairlists in R is when working with calls to the function, as the formal arguments to a function are stored in a pairlist:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; $x
#&gt; 
#&gt; 
#&gt; $y
#&gt; [1] 10</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "pairlist"</code></pre>
</div>
</div>
<ul>
<li>Fortunately, whenever you encounter a pairlist, you can treat it just like a regular list:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 2</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 1</code></pre>
</div>
</div>
<h3 id="missing-arguments">Missing arguments</h3>
<ul>
<li>Empty symbols</li>
<li>To create an empty symbol, you need to use <code>missing_arg()</code> or <code>expr()</code>.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "symbol"</code></pre>
</div>
</div>
<ul>
<li>Empty symbols don’t print anything.
<ul>
<li>To check, we need to use <code>rlang::is_missing()</code></li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<ul>
<li>These are usually present in function formals:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] TRUE</code></pre>
</div>
</div>
<h3 id="expression-vectors">Expression vectors</h3>
<ul>
<li>An expression vector is just a list of expressions.
<ul>
<li>The only difference is that calling <code>eval()</code> on an expression evaluates each individual expression.</li>
<li>Instead, it might be more advantageous to use a list of expressions.</li>
</ul></li>
<li>Expression vectors are only produced by two base functions: <code>expression()</code> and <code>parse()</code>:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; expression(x &lt;- 4, x)</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; expression(x &lt;- 4, x)</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "expression"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] "expression"</code></pre>
</div>
</div>
<ul>
<li>Like calls and pairlists, expression vectors behave like lists:</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; [1] 2</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>#&gt; x &lt;- 4</code></pre>
</div>
</div>
</section>
<section id="meeting-videos" class="slide level2">
<h2>Meeting Videos</h2>
<h3 id="cohort-1">Cohort 1</h3>
<iframe src="https://www.youtube.com/embed/2NixH3QAerQ" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-2">Cohort 2</h3>
<iframe src="https://www.youtube.com/embed/mYOUgzoRcjI" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-3">Cohort 3</h3>
<iframe src="https://www.youtube.com/embed/5RLCRFli6QI" width="100%" height="400px" data-external="1">
</iframe>
<iframe src="https://www.youtube.com/embed/F8df5PMNC8Y" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-4">Cohort 4</h3>
<iframe src="https://www.youtube.com/embed/tSVBlAP5DIY" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-5">Cohort 5</h3>
<iframe src="https://www.youtube.com/embed/Jc_R4yFsYeE" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-6">Cohort 6</h3>
<iframe src="https://www.youtube.com/embed/K8w28ee3CR8" width="100%" height="400px" data-external="1">
</iframe>
<h3 id="cohort-7">Cohort 7</h3>
<iframe src="https://www.youtube.com/embed/XPs-TI4BYjk" width="100%" height="400px" data-external="1">
</iframe>
<iframe src="https://www.youtube.com/embed/8LPw_VTBsmQ" width="100%" height="400px" data-external="1">
</iframe>
<details>
<summary>
Meeting chat log
</summary>
<pre><code>00:50:48    Stone:  https://www.r-bloggers.com/2018/10/quasiquotation-in-r-via-bquote/
00:58:26    iPhone: See ya next week!</code></pre>
</details>


</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">
<p><a href="../" target="advr_club-index">DSLC.io/advr</a> | <a href="https://DSLC.io" target="_blank">DSLC.io</a></p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    
    <script>
      // htmlwidgets need to know to resize themselves when slides are shown/hidden.
      // Fire the "slideenter" event (handled by htmlwidgets.js) when the current
      // slide changes (different for each slide format).
      (function () {
        // dispatch for htmlwidgets
        function fireSlideEnter() {
          const event = window.document.createEvent("Event");
          event.initEvent("slideenter", true, true);
          window.document.dispatchEvent(event);
        }

        function fireSlideChanged(previousSlide, currentSlide) {
          fireSlideEnter();

          // dispatch for shiny
          if (window.jQuery) {
            if (previousSlide) {
              window.jQuery(previousSlide).trigger("hidden");
            }
            if (currentSlide) {
              window.jQuery(currentSlide).trigger("shown");
            }
          }
        }

        // hookup for slidy
        if (window.w3c_slidy) {
          window.w3c_slidy.add_observer(function (slide_num) {
            // slide_num starts at position 1
            fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);
          });
        }

      })();
    </script>

    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
            const codeEl = trigger.previousElementSibling.cloneNode(true);
            for (const childEl of codeEl.children) {
              if (isCodeAnnotation(childEl)) {
                childEl.remove();
              }
            }
            return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp("https:\/\/r4ds\.github\.io\/bookclub-advr\/");
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
                // target, if specified
                link.setAttribute("target", "_blank");
                if (link.getAttribute("rel") === null) {
                  link.setAttribute("rel", "noopener");
                }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>