---
engine: knitr
title: Control flow
---

## Learning objectives:

- Understand the two primary tools for control flow: **choices** and **loops**
- Learn best practices to void common pitfalls
- Distinguish when to use `if`, `ifelse()`, and `switch()` for choices
- Distinguish when to use `for`, `while`, and `repeat` for loops

::: {.callout-note}
Basic familiarity with choices and loops is assumed.
:::

# Choices

[Section 5.2 Choices]: #

## `if` is the basic statement for a **choice** 

Single line format

```{r}
#| eval: false
if (condition) true_action
if (condition) true_action else false_action
```

Compound statement within `{`

```{r}
grade <- function(x) {
  if (x > 90) {
    "A"
  } else if (x > 80) {
    "B"
  } else if (x > 50) {
    "C"
  } else {
    "F"
  }
}
```

## Results of `if` can be assigned

```{r}
x1 <- if (TRUE) 1 else 2
x2 <- if (FALSE) 1 else 2

c(x1, x2)
```

:::{.callout-tip}
Only recommended with single line format; otherwise hard to read.
:::

## `if` without `else` can be combined with `c()` or `paste()` to create compact expressions

 - `if` without `else` invisibly returns `NULL` when `FALSE`.

```{r}
greet <- function(name, birthday = FALSE) {
  paste0(
    "Hi ", name,
    if (birthday) " and HAPPY BIRTHDAY"
  )
}
greet("Maria", FALSE)
greet("Jaime", TRUE)
```

[Section 5.2.1 Invalid Inputs]: #

## `if` should have a single `TRUE` or `FALSE` condition, other inputs generate errors

```{r}
#| error: true
if ("x") 1
if (logical()) 1
if (NA) 1
if (c(TRUE, FALSE)) 1
```

[Section 5.2.2 Vectorized If]: #

## Use `ifelse()` for vectorized conditions

```{r}
x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))
ifelse(x %% 2 == 0, "even", "odd")
```

::: {.callout-tip}
Only use `ifesle()` if both results are of the same type; otherwise output type is hard to predict.
:::

## Use `dplyr::case_when()` for multiple condition-vector pairs

```{r}
dplyr::case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "???",
  TRUE ~ as.character(x)
)
```


[Section 5.2.3 switch()]: #

## `switch()` is a special purpose equivalent to `if` that can be used to compact code

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
:::: {.columns}
::: {.column}
```{r}
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}
```
:::

::: {.column}
```{r}
x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
```
:::
::::
:::

::: {.fragment .fade-up fragment-index=1}
::: {.callout-tip}
 - The last component of a `switch()` should always throw an error, otherwise unmatched inputs will invisibly return `NULL`.
 - Only use `switch()` with character inputs. Numeric inputs are hard to read and have undesirable failure modes.
:::

::: {.callout-caution}
Like `if`, `switch()` can only take a single condition, not vector conditions
:::
:::
:::

## Avoid repeat outputs by leaving the right side of `=` empty

- Inputs will "fall through" to the next value.

```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow")
legs("dog")
```

[Section 5.3 Loops]: #

# Loops

## To iterate over items in a vector, use `for`

:::{.r-stack}
:::{.fragment .fade-out fragment-index=1}

```{r}
#| eval: false
for (item in vector) perform_action
```

```{r}
for (i in 1:3) {
  print(i)
}
```

::: {.callout-note}
Convention uses short variables like `i`, `j`, or `k` for iterating vector indices
:::
:::
::: {.fragment .fade-up fragment-index=1}
::: {.callout-caution}
`for` will overwrite existing variables in the current environment
:::
```{r}
i <- 100
for (i in 1:3) {}
i
```
:::
:::

## Use `next` or `break` to terminate loops early

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
- `next` exits the current iteration, but continues the loop
- `break` exits the entire loop
:::
::: {.fragment .fade-up fragment-index=1}
```{r}
for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
```
:::
:::

[Section 5.3.1 Common pitfalls]: #

## Preallocate an output container to avoid slow loops

```{r}
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```

:::{.callout-tip}
`vector()` function is helpful for preallocation
:::

## Use `seq_along(x)` instead of `1:length(x)`

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
 - `1:length(x)` causes unexpected failure for 0 length vectors
 - `:` works with both increasing and decreasing sequences
```{r}
means <- c()
1:length(means)
seq_along(means)
```
:::
::: {.fragment .fade-up fragment-index=1}
:::: {.columns}
::: {.column}
```{r}
#| error: true
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
out
```
:::
::: {.column}
```{r}
out <- vector("list", length(means))
for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
out
```
:::
::::
:::
:::

## Avoid problems when iterating over S3 vectors by using seq_along(x) and x[[i]]
- loops typically strip attributes
:::: {.columns}
::: {.column}
```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (x in xs) {
  print(x)
}
```
:::
::: {.column}
```{r}
for (i in seq_along(xs)) {
  print(xs[[i]])
}
```
:::
 
[Section 5.3.2 Related tools]: #
 
## Use `while` or `repeat` when you don't know the number of iterations

- `while(condition) action`: perfoms `action` while `condition` is `TRUE`
- `repeat(action)`: repeats `action` forever (or until a `break`) 
 
## Always use the least-flexible loop option possible

- Use `for` before `while` or `repeat`
- In data analysis use `apply()` or `purrr::map()` before `for`

# Quiz & Exercises {visibility="uncounted"}

[Section 5.1 Quiz]

## What is the difference between if and ifelse()?

::: {.fragment .fade-in}
`if` works with scalars; `ifelse()` works with vectors.
:::

## In the following code, what will the value of y be if x is TRUE? What if x is FALSE? What if x is NA?

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
```{r}
#| eval: false
y <- if (x) 3
```
:::
::: {.fragment .fade-up fragment-index=1}
When `x` is `TRUE`, `y` will be `3`; when `FALSE`, `y` will be `NULL`; when `NA` the `if` statement will throw an error.
:::
:::

## What does `switch("x", x = , y = 2, z = 3)` return?

::: {.fragment .fade-in}
This `switch()` statement makes use of fall-through so it will return `2`.
:::

[Section 5.2.4 Exercises]: #

## What type of vector does each of the following calls to ifelse() return?

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
```{r}
#| eval: false
ifelse(TRUE, 1, "no")
ifelse(FALSE, 1, "no")
ifelse(NA, 1, "no")
```

Read the documentation and write down the rules in your own words.
:::
::: {.fragment .fade-up fragment-index=1}
::: {.fragment .fade-out fragment-index=2}
The arguments of `ifelse()` are named `test`, `yes` and `no`.
In general, `ifelse()` returns the entry for `yes` when `test` is `TRUE`,
the entry for `no` when `test` is `FALSE` 
and `NA` when `test` is `NA`.
Therefore, the expressions above return vectors of type `double (1)`, `character ("no")` and `logical (NA)`.
:::
:::
::: {.fragment .fade-up fragment-index=2}
In practice, `test` is first converted to `logical` and if the result is neither `TRUE` nor `FALSE`, then `as.logical(test)` is returned.
```{r}
ifelse(logical(), 1, "no")
ifelse(NaN, 1, "no")
ifelse(NA_character_, 1, "no")
ifelse("a", 1, "no")
ifelse("true", 1, "no")
```
:::
:::

## Why does the following code work?

::: {.r-stack}
::: {.fragment .fade-out fragment-index=1}
```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"
x <- numeric()
if (length(x)) "not empty" else "empty"
```
:::
::: {.fragment .fade-up fragment-index=1}
`if()` expects a logical condition, but also accepts a numeric vector where `0` is treated as `FALSE` and all other numbers are treated as `TRUE`.
Numerical missing values (including `NaN`) lead to an error in the same way that a logical missing, `NA`, does.
:::
:::

[Section 5.3.3 Exercises]: #

## Why does this code succeed without errors or warnings?

```{r}
x <- numeric()
out <- vector("list", length(x))
for (i in 1:length(x)) {
  out[i] <- x[i] ^ 2
}
out
```

## Answer

As we use `[<-` and `[` for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.

During the first iteration `x[1]` will generate an `NA` (out-of-bounds indexing for atomics). The resulting `NA` (from squaring) will be assigned to the empty length-1 list `out[1]` (out-of-bounds indexing for lists).

In the next iteration, `x[0]` will return `numeric(0)` (zero indexing for atomics). Again, squaring doesn't change the value and `numeric(0)` is assigned to `out[0]` (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn't change the object.

Overall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).

## When the following code is evaluated, what can you say about the vector being iterated?

```{r}
xs <- c(1, 2, 3)
for (x in xs) {
  xs <- c(xs, x * 2)
}
xs
```

::: {.fragment .fade-in}
In this loop `x` takes on the values of the initial `xs` (`1`, `2` and `3`), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)
:::

## What does the following code tell you about when the index is updated?

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i) 
}
```

::: {.fragment .fade-in}
In a `for` loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn't affect the following iterations. (Again, we would otherwise run into an infinite loop.)
:::
