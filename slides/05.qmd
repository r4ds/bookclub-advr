---
engine: knitr
title: Control flow
---

## Learning objectives:

- Understand the two primary tools for control flow: **choices** and **loops**
- Learn best practices to void common pitfalls
- Distinguish when to use `if`, `ifelse()`, and `switch()` for choices
- Distinguish when to use `for`, `while`, and `repeat` for loops

::: {.callout-note}
Basic familiarity with choices and loops is assumed.
:::

# Choices

[Section 5.2 Choices]: #

## `if` is the basic statement for a **choice** 

Single line format

```{r}
#| eval: false
if (condition) true_action
if (condition) true_action else false_action
```

Compound statement within `{`

```{r}
grade <- function(x) {
  if (x > 90) {
    "A"
  } else if (x > 80) {
    "B"
  } else if (x > 50) {
    "C"
  } else {
    "F"
  }
}
```

## Results of `if` can be assigned

```{r}
x1 <- if (TRUE) 1 else 2
x2 <- if (FALSE) 1 else 2

c(x1, x2)
```

:::{.callout-tip}
Only recommended with single line format; otherwise hard to read.
:::

## `if` without `else` can be combined with `c()` or `paste()` to create compact expressions

 - `if` without `else` invisibly returns `NULL` when `FALSE`.

```{r}
greet <- function(name, birthday = FALSE) {
  paste0(
    "Hi ", name,
    if (birthday) " and HAPPY BIRTHDAY"
  )
}
greet("Maria", FALSE)
greet("Jaime", TRUE)
```

[Section 5.2.1 Invalid Inputs]: #

## `if` should have a single `TRUE` or `FALSE` condition, other inputs generate errors

```{r}
#| error: true
if ("x") 1
if (logical()) 1
if (NA) 1
if (c(TRUE, FALSE)) 1
```

[Section 5.2.2 Vectorized If]: #

## Use `ifelse()` for vectorized conditions

```{r}
x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))
ifelse(x %% 2 == 0, "even", "odd")
```

::: {.callout-tip}
Only use `ifelse()` if both results are of the same type; otherwise output type is hard to predict.
:::

## Use `dplyr::case_when()` for multiple condition-vector pairs

```{r}
dplyr::case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "???",
  TRUE ~ as.character(x)
)
```


[Section 5.2.3 switch()]: #

## `switch()` is a special purpose equivalent to `if` that can be used to compact code {transition="none-out"}

:::: {.columns}
::: {.column}
```{r}
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}
```
:::

::: {.column}
```{r}
x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
```
:::
::::

## `switch()` is a special purpose equivalent to `if` that can be used to compact code {transition="none-in"}

::: {.callout-tip}
 - The last component of a `switch()` should always throw an error, otherwise unmatched inputs will invisibly return `NULL`.
 - Only use `switch()` with character inputs. Numeric inputs are hard to read and have undesirable failure modes.
:::

::: {.callout-caution}
Like `if`, `switch()` can only take a single condition, not vector conditions
:::


## Avoid repeat outputs by leaving the right side of `=` empty

- Inputs will "fall through" to the next value.

```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow")
legs("dog")
```

[Section 5.3 Loops]: #

# Loops

## To iterate over items in a vector, use a `for` **loop**

```{r}
#| eval: false
for (item in vector) perform_action
```

```{r}
for (i in 1:3) {
  print(i)
}
```

::: {.callout-note}
Convention uses short variables like `i`, `j`, or `k` for iterating vector indices
:::

## `for` will overwrite existing variables in the current environment

```{r}
i <- 100
for (i in 1:3) {}
i
```

## Use `next` or `break` to terminate loops early {transition="none-out"}
- `next` exits the current iteration, but continues the loop
- `break` exits the entire loop

## Use `next` or `break` to terminate loops early {transition="none-in"}
```{r}
for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
```

[Section 5.3.1 Common pitfalls]: #

## Preallocate an output container to avoid slow loops

```{r}
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```

:::{.callout-tip}
`vector()` function is helpful for preallocation
:::

## Use `seq_along(x)` instead of `1:length(x)` {transition="none-out"}
- `1:length(x)` causes unexpected failure for 0 length vectors
- `:` works with both increasing and decreasing sequences
```{r}
means <- c()
1:length(means)
seq_along(means)
```

## Use `seq_along(x)` instead of `1:length(x)` {transition="none-in"}
:::: {.columns}
::: {.column}
```{r}
#| error: true
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```
:::
::: {.column}
```{r}
out <- vector("list", length(means))
for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
out
```
:::
::::

## Avoid problems when iterating over S3 vectors by using `seq_along(x)` and `x[[i]]`
::: {}
- loops typically strip attributes
```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
```
:::
:::: {.columns}
::: {.column}
```{r}
for (x in xs) {
  print(x)
}
```
:::
::: {.column}
```{r}
for (i in seq_along(xs)) {
  print(xs[[i]])
}
```
:::
::::
 
[Section 5.3.2 Related tools]: #
 
## Use `while` or `repeat` when you don't know the number of iterations

- `while(condition) action`: perfoms `action` while `condition` is `TRUE`
- `repeat(action)`: repeats `action` forever (or until a `break`) 
 
## Always use the least-flexible loop option possible

- Use `for` before `while` or `repeat`
- In data analysis use `apply()` or `purrr::map()` before `for`

# Quiz & Exercises {visibility="uncounted"}

[Section 5.1 Quiz]: #

## What is the difference between if and ifelse()? {visibility="uncounted"}

::: {.fragment .fade-in}
`if` works with scalars; `ifelse()` works with vectors.
:::

## In the following code, what will the value of `y` be if `x` is `TRUE`? What if `x` is `FALSE`? What if `x` is `NA`? {visibility="uncounted"}


```{r}
#| eval: false
y <- if (x) 3
```

::: {.fragment .fade-up fragment-index=1}
When `x` is `TRUE`, `y` will be `3`; when `FALSE`, `y` will be `NULL`; when `NA` the `if` statement will throw an error.
:::

## What does `switch("x", x = , y = 2, z = 3)` return? {visibility="uncounted"}


```{r}
#| eval: false
switch(
  "x",
  x = ,
  y = 2,
  x = 3
)
```

::: {.fragment .fade-in}
This `switch()` statement makes use of fall-through so it will return `2`.
:::

[Section 5.2.4 Exercises]: #

## What type of vector does each of the following calls to ifelse() return? {visibility="uncounted" transition="none-out"}

Read the documentation and write down the rules in your own words.
```{r}
#| eval: false
ifelse(TRUE, 1, "no")
ifelse(FALSE, 1, "no")
ifelse(NA, 1, "no")
```

## What type of vector does each of the following calls to ifelse() return? {visibility="uncounted" transition="none"}

The arguments of `ifelse()` are named `test`, `yes` and `no`.
In general, `ifelse()` returns the entry for `yes` when `test` is `TRUE`,
the entry for `no` when `test` is `FALSE` 
and `NA` when `test` is `NA`.

```{r}
ifelse(TRUE, 1, "no")
ifelse(FALSE, 1, "no")
ifelse(NA, 1, "no")
```

## What type of vector does each of the following calls to ifelse() return? {visibility="uncounted" transition="none-in"}
In practice, `test` is first converted to `logical` and if the result is neither `TRUE` nor `FALSE`, then `as.logical(test)` is returned.
```{r}
ifelse(logical(), 1, "no")
ifelse(NaN, 1, "no")
ifelse(NA_character_, 1, "no")
ifelse("a", 1, "no")
ifelse("true", 1, "no")
```

## Why does the following code work? {visibility="uncounted"}

```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"
x <- numeric()
if (length(x)) "not empty" else "empty"
```
::: {.fragment .fade-up fragment-index=1}
`if()` expects a logical condition, but also accepts a numeric vector where `0` is treated as `FALSE` and all other numbers are treated as `TRUE`.
Numerical missing values (including `NaN`) lead to an error in the same way that a logical missing, `NA`, does.
:::

[Section 5.3.3 Exercises]: #

## Why does this code succeed without errors or warnings? {visibility="uncounted" transition="none-out"}

```{r}
x <- numeric()
out <- vector("list", length(x))
for (i in 1:length(x)) {
  out[i] <- x[i] ^ 2
}
out
```

## Why does this code succeed without errors or warnings? {visibility="uncounted" transition="none-in"}
- Subsetting behavior for out-of-bounds & `0` indices when using `[<-` and `[`
- `x[1]` generates an `NA`. `NA` is assigned to the empty length-1 list `out[1]`
- `x[0]` returns `numeric(0)`. `numeric(0)` is assigned to `out[0]`. Assigning a 0-length vector to a 0-length subset doesn't change the object.
- Each step includes valid R operations (even though the result may not be what the user intended).

## Walk-through {visibility="uncounted" transition="none-out"}

Setup
```{r}
x <- numeric()
out <- vector("list", length(x))
1:length(x)
```

## Walk-through {visibility="uncounted" transition="none"}

First Iteration
```{r}
x[1]
x[1]^2
out[1]
out[1] <- x[1]^2
out[1]
```

## Walk-through {visibility="uncounted" transition="none"}

Second Iteration
```{r}
x[0]
x[0]^2
out[0]
out[0] <- x[0]^2
out[0]
```

## Walk-through {visibility="uncounted" transition="none-in"}

Final Result
```{r}
out
```

## When the following code is evaluated, what can you say about the vector being iterated? {visibility="uncounted"}

```{r}
xs <- c(1, 2, 3)
for (x in xs) {
  xs <- c(xs, x * 2)
}
xs
```

::: {.fragment .fade-in}
In this loop `x` takes on the values of the initial `xs` (`1`, `2` and `3`), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)
:::

## What does the following code tell you about when the index is updated? {visibility="uncounted"}

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i) 
}
```

::: {.fragment .fade-in}
In a `for` loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn't affect the following iterations. (Again, we would otherwise run into an infinite loop.)
:::
